<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bue源码阅读笔记（1）</title>
    <url>/my-notes/2017/05/09/bue/1/</url>
    <content><![CDATA[<p>最简单的数据绑定 <a href="https://github.com/youngwind/bue/tree/d7dedf6ff8b3cecd68903b878690fef2ef8f18c8">对应版本</a></p>
<h3 id="代码执行顺序"><a href="#代码执行顺序" class="headerlink" title="代码执行顺序"></a>代码执行顺序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_init() --&gt; $mount() --&gt; _compile() --&gt; _compileNode() --&gt;</span><br><span class="line"></span><br><span class="line">检查html节点 &#123;</span><br><span class="line">  nodeType &#x3D;&#x3D; 1 (元素节点) : 遍历子节点，再次检查html节点,</span><br><span class="line">  nodeType &#x3D;&#x3D; 3 (文本节点) : 用正则匹配&#123;&#123;&#125;&#125;，并替换成数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="不熟悉知识点总结"><a href="#不熟悉知识点总结" class="headerlink" title="不熟悉知识点总结"></a>不熟悉知识点总结</h3><ul>
<li>1 Array.from:把其他数据类型转为array</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const bar &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];</span><br><span class="line">Array.from(bar);</span><br><span class="line">&#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line"></span><br><span class="line">Array.from(&#39;foo&#39;);</span><br><span class="line">&#x2F;&#x2F; [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Bue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Bue源码阅读笔记（2）</title>
    <url>/my-notes/2017/05/09/bue/2/</url>
    <content><![CDATA[<p><a href="https://github.com/youngwind/bue/tree/81138df4d36e50015ac8962a50da8259651ec9eb">对应版本</a></p>
<ul>
<li>✅ 监听对象变化</li>
<li>✅ 监听数组变化</li>
<li>✅ watch库</li>
<li>✅ 动态数据绑定</li>
<li>❎ 不支持多层对象操作</li>
</ul>
<hr>
<h3 id="代码执行顺序"><a href="#代码执行顺序" class="headerlink" title="代码执行顺序"></a>代码执行顺序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this._init() --&gt; 创建观察对象Observer.create() --&gt; 判断数据类型(数组或对象) --&gt;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  数组：重写Bue数组的方法，遍历子元素 -----------------↑</span><br><span class="line">  对象：重定义对象属性(添加了消息触发函数)，遍历子元素----↑</span><br><span class="line">&#125; -------&gt;</span><br><span class="line"></span><br><span class="line">订阅监听数据并重新渲染的事件this.observer.on(&#39;set&#39;, this.$mount.bind(this));</span><br><span class="line"></span><br><span class="line">this.$watch 手动订阅监听事件</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="不熟悉知识点"><a href="#不熟悉知识点" class="headerlink" title="不熟悉知识点"></a>不熟悉知识点</h3><ul>
<li>1 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法 Object.defineProperty(obj, prop, descriptor)</span><br><span class="line"></span><br><span class="line">参数 &#123;</span><br><span class="line">  obj：要在其上定义属性的对象。</span><br><span class="line">  prop：要定义或修改的属性的名称。</span><br><span class="line">  descriptor：将被定义或修改的属性的描述符。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">返回值：被传递给函数的对象。</span><br><span class="line"></span><br><span class="line">Object.defineProperty(this.value, key, &#123;</span><br><span class="line">    enumerable: true,  &#x2F;&#x2F;可定义的</span><br><span class="line">    configurable: true, &#x2F;&#x2F;可枚举的</span><br><span class="line">   &#x2F;&#x2F; value:&quot;111&quot;,         &#x2F;&#x2F;值</span><br><span class="line">    writable:true,     &#x2F;&#x2F;可写的</span><br><span class="line">    get: function () &#123;</span><br><span class="line">        return val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function (newVal) &#123;</span><br><span class="line">        if (newVal &#x3D;&#x3D;&#x3D; val) return;</span><br><span class="line">        val &#x3D; newVal;</span><br><span class="line">        console.log(&#39;你设置了&#39; + key + &#39; 新的&#39; + key + &#39; &#x3D; &#39; + newVal);</span><br><span class="line">        ob.notify(&#39;set&#39;, key, newVal);</span><br><span class="line">        ob.notify(&#96;set:$&#123;key&#125;&#96;, key, newVal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>1.数据初始化的时候会给$observer所有的字段添加一个parent字段，方便之后一层层的出发监听事件</li>
</ul>
]]></content>
      <tags>
        <tag>Bue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Bue源码阅读笔记（3）</title>
    <url>/my-notes/2017/05/16/bue/3/</url>
    <content><![CDATA[<p><a href="https://github.com/youngwind/bue/tree/89c0d93071d117eddb9b85edde96fb6e13173d66">当前版本</a></p>
<h2 id="相比之前-：-分离directive和watch的update操作"><a href="#相比之前-：-分离directive和watch的update操作" class="headerlink" title="相比之前 ： 分离directive和watch的update操作"></a>相比之前 ： 分离directive和watch的update操作</h2><h3 id="代码执行顺序"><a href="#代码执行顺序" class="headerlink" title="代码执行顺序"></a>代码执行顺序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_initData() 数据初始化 同 2 --&gt;</span><br><span class="line"></span><br><span class="line">_initBindings() 创建一个Binding,在observer上订阅set监听函数 --&gt;</span><br><span class="line"></span><br><span class="line">$mount() --&gt; compile() --&gt; 初始化节点并渲染dom,若是node节点,遍历子元素;若是文本节点，绑定directive，watcher(函数绕来绕去的感觉好乱，只能大致理解意思)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  node: 遍历</span><br><span class="line">  text: &#123;</span><br><span class="line">    普通文本节点：直接插入，</span><br><span class="line">    指令节点：_bindDirective --&gt; 指令构造函数new Directive() --&gt; 添加new Watcher(),第一次手动触发dom更新</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">当数据变动时, 执行_updateBindingAt()，它会去把对应改变了的数据那里找出所有的watcher, 然后一一执行他们的cb, 一个都不放过</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Bue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Bue源码阅读笔记（4）</title>
    <url>/my-notes/2017/05/18/bue/4/</url>
    <content><![CDATA[<p><a href="https://github.com/youngwind/bue/tree/63454b08627ba6ccc459ae8615c62d5f1f788818">当前版本</a></p>
<h3 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h3><ul>
<li>✅ 监听对象变化</li>
<li>✅ 监听数组变化</li>
<li>✅ watch库</li>
<li>✅ 动态数据绑定</li>
<li>✅ 批处理更新DOM</li>
<li>✅ 计算属性computed</li>
</ul>
<h3 id="代码执行补充"><a href="#代码执行补充" class="headerlink" title="代码执行补充"></a>代码执行补充</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">批处理更新DOM : new Batcher() --&gt; 在Watcher.update的时候Batcher.push()将事件添加到队列中,</span><br><span class="line">  利用setTimeout执行机制，在里面执行flush --&gt; flush()内执行并清空队列</span><br><span class="line"></span><br><span class="line">计算属性computed(静态 -&gt; 动态) : &#123;</span><br><span class="line">  静态 ：_initComputed(),把函数定义到了Object get上面 ,就能获取到值了</span><br><span class="line">  动态 ：在_initBindings()的时候, 订阅了get事件,之后$mount --&gt; _compile() --&gt; new Direcitve() </span><br><span class="line">    --&gt; new Watcher() 在这里，进行了取值操作，就触发了get事件 --&gt; 收集依赖_collectDep() --&gt; </span><br><span class="line">    把watcher放在了_sub数组里面, 当computed内部有变量改动时, 触发了set事件, 这个时候, </span><br><span class="line">    会执行Watcher.cb, 即更新dom </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ps:这里我想错了，一直在找user.name的跟新触发了info的跟新的函数，其实即便在静态那里，user.name的跟新也会导致info数据的跟新，只不过没触发dom跟新，所以这里的动态只是在user.name的_sub里绑了一个触发info的dom更新的Watcher</p>
<p>ps2:nonono，上面我还是搞错了，<code>并不是</code>user.name的跟新导致了info数据的跟新，而是user.name的_sub里绑了一个触发info的dom更新的Watcher，在info的dom更新的时候，需要访问info,从而触发了info的get方法，最终进行的是computed上info的函数，重新给info赋值了，所以导致了info的改变(因为这个时候user.name已经改变了)</p>
<h3 id="本文总结"><a href="#本文总结" class="headerlink" title="本文总结"></a>本文总结</h3><p>这个版本的代码我反反复复的看了一个下午，总算是更加深入的了解的代码的含义，也弥补了上一篇中一知半解的地方，配合作者的文章说明，理清了代码的执行流程，不过这个代码真的是绕的不行。。。最后吐槽一下这代码的耦合程度虽然低，但是文件分的太散，每次找函数定义都要花上不少的时间</p>
]]></content>
      <tags>
        <tag>Bue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Bue源码阅读笔记（5）</title>
    <url>/my-notes/2017/05/23/bue/5/</url>
    <content><![CDATA[<p><a href="https://github.com/youngwind/bue/tree/8151c62a2fa3c65581f91c783cbf15aad3078ac9">当前版本</a></p>
<h3 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h3><p>完成动态v-if指令</p>
<h3 id="代码执行补充"><a href="#代码执行补充" class="headerlink" title="代码执行补充"></a>代码执行补充</h3><p>当代码执行到dom渲染前，这个时候会进行attribute检查，如果存在自定义attr(b-if), 直接走指令绑定_bindDirective –&gt; new Directive() –&gt; _initDef(),这里不同指令对应的更新update函数不同, 所以需要分类处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let def &#x3D; this.vm.$options.directives[this.name];</span><br><span class="line">    _.extend(this, def);</span><br></pre></td></tr></table></figure>
<p>–&gt; _bind() –&gt; this.update(this._watcher.value); 决定是否插入dom (至此静态渲染已完成) –&gt; 渲染dom，对内部变量进行赋值, 但需要在先前做一些准备(这部分代码的思路有问题，仅仅用于应付if指令)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; init.js</span><br><span class="line">if (this.$parent) &#123;</span><br><span class="line">  this.$data &#x3D; options.parent.$data;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  this.$data &#x3D; options.data || &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (this.$parent) &#123;</span><br><span class="line">    this.observer &#x3D; this.$parent.observer;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    this.observer &#x3D; Observer.create(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="不熟悉知识点"><a href="#不熟悉知识点" class="headerlink" title="不熟悉知识点"></a>不熟悉知识点</h3><ul>
<li>document.createComment 插入注释，在这里主要用于dom占位</li>
</ul>
]]></content>
      <tags>
        <tag>Bue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Bue源码阅读笔记（6）</title>
    <url>/my-notes/2017/05/25/bue/6/</url>
    <content><![CDATA[<p><a href="https://github.com/youngwind/bue/tree/9e9804c2ee802c2658199236b10da42d6ea16136">当前版本</a></p>
<h3 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h3><ul>
<li>v-on 实现</li>
<li>完成动态 v-if 指令</li>
</ul>
<h3 id="代码执行补充"><a href="#代码执行补充" class="headerlink" title="代码执行补充"></a>代码执行补充</h3><p>v-on: 和 v-if 类似, _init()中把 on 指令相关函数放在了 directives 里面 –&gt; 使用 on 相关指令绑定事件</p>
<p>v-repeat: 和 v-if 类似, _init()中把 on 指令相关函数放在了 directives 里面 –&gt; 使用 repeat 相关指令绑定事件</p>
<p>5.30 补充<br>这里需要详细的了解一下 repeat 指令里面的流程</p>
<ul>
<li><ol>
<li>首先执行 bind(), 给 repeat 指定了唯一的 uid, 并创建 repeat 注释</li>
</ol>
</li>
<li><ol start="2">
<li>upadate<br>a.首次执行：进入 diff, 调用 build(), 给 v-repeat 内部变量 item 赋值，为 item 创建了 Bue 实例和数据缓存(循环的子数据(最终来看就是 item)[this.id] = vm(即新创建的 Bue 实例)), 渲染 dom<br>b.再次执行: 数据变化之后, 进入 diff, 判断是否有旧数据并打上记号, 删除不存在的实例, 把新实例插入到正确的位置(感觉这里的第三步代码有问题。。。)</li>
</ol>
</li>
</ul>
]]></content>
      <tags>
        <tag>Bue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>说明</title>
    <url>/my-notes/2017/05/25/bue/readme/</url>
    <content><![CDATA[<p>百度 ife 任务里根据 vue 早期版本的源码研究而实现的简单 vue 项目—Bue</p>
<p>这里是我对 bue 的学习笔记</p>
]]></content>
      <tags>
        <tag>Bue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js简介</title>
    <url>/my-notes/2019/06/14/js%E9%AB%98%E7%BA%A7/1.js%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h3 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h3><ul>
<li>􏵛􏴞􏲛 核心（ECMAScript􏲜）</li>
<li>文档对象模型（DOM）</li>
<li>浏览器对象模型（BOM）</li>
</ul>
]]></content>
      <tags>
        <tag>javascript高级笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM</title>
    <url>/my-notes/2019/06/14/js%E9%AB%98%E7%BA%A7/10.DOM/</url>
    <content><![CDATA[<h2 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h2><h3 id="Node-类型"><a href="#Node-类型" class="headerlink" title="Node 类型"></a>Node 类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ELEMENT_NODE: 1 &#x2F;&#x2F; div等</span><br><span class="line">ATTRBUTE_NODE: 2</span><br><span class="line">TEXT_NODE: 3 &#x2F;&#x2F; 文本节点</span><br><span class="line">CDATA_SECTION_NODE: 4</span><br><span class="line">ENTITY_REFERENCE_NODE: 5</span><br><span class="line">ENTITY_NODE: 6</span><br><span class="line">PROCESSING_INSTRUCTION_NODE: 7</span><br><span class="line">COMMENT_NODE: 8 &#x2F;&#x2F; 注释节点</span><br><span class="line">DOCUMENT_NODE: 9 &#x2F;&#x2F; document类型</span><br><span class="line">DOCUMENT_TYPE_NODE: 10</span><br><span class="line">DOCUMENT_FRAGMENT_NODE: 11</span><br><span class="line">NOTATION_NODE: 12</span><br></pre></td></tr></table></figure>

<h3 id="document-类型"><a href="#document-类型" class="headerlink" title="document 类型"></a>document 类型</h3><p>document 是 HTMLDocument 的一个实例，表示整个 html 页面。document 对象是 window 的一个属性</p>
<h3 id="element-类型-1"><a href="#element-类型-1" class="headerlink" title="element 类型 (1)"></a>element 类型 (1)</h3><ol>
<li>html 元素</li>
</ol>
<p>包含<code>id</code>,<code>title</code>,<code>lang</code>,<code>className</code>,<code>dir</code>5 个基本特性，可以直接通过 div.xxx 读取或设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var div &#x3D; document.getElementById(&quot;myDiv&quot;);</span><br><span class="line">console.log(div.id)</span><br><span class="line">div.id &#x3D; &#39;id&#39;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>操作特性</li>
</ol>
<p><code>getAttribute()􏴎</code> <code>setAttribute()􏲪</code> <code>removeAttribute()</code></p>
<p>可以操作 html 自带的和自定义的特性</p>
<ol start="3">
<li>attribute 属性</li>
</ol>
<p>Element 类型是使用 attribute 属性的唯一一个 DOM 节点类型。<br>保存在 NamedNodeMap 中，拥有以下方法</p>
<ul>
<li>getNamedItem(name) 返回 nodeName 属性等于 name 的节点</li>
<li>removeNamedItem(name) 删除</li>
<li>setNamedItem(node) 向列表中添加节点、以节点的 nodeName 属性为索引</li>
<li>item(pos) 返回唯一数字 pos 位置的节点</li>
</ul>
<h3 id="Text-类型-3"><a href="#Text-类型-3" class="headerlink" title="Text 类型 (3)"></a>Text 类型 (3)</h3><p>可以通过 nodeValue 属性或 data 属性访问 Text 节点中包含的文本</p>
<ul>
<li>appendData(text) text 添加到末尾</li>
<li>deleteData(offset, count) 删除(offset, offset+count)位置的文本</li>
<li>insertData(offset, text) 在 offset 处插入 text</li>
<li>replaceData(offset, count, text) 用 text 替换(offset, offset+count)位置的文本</li>
<li>splitText(offset) 在 offset 处将文本节点拆分为两个</li>
<li>substringData(offset, count) 获得(offset, offset+count)位置的文本</li>
</ul>
<ol>
<li>创建文本节点</li>
</ol>
<p>document.createTextNode()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var element &#x3D; document.createElement(&quot;div&quot;);</span><br><span class="line">element.className &#x3D; &quot;message&quot;;</span><br><span class="line">var textNode &#x3D; document.createTextNode(&quot;Hello world!&quot;);</span><br><span class="line">element.appendChild(textNode);</span><br><span class="line">document.body.appendChild(element);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>规范化文本节点</li>
</ol>
<p><code>normalize</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var element &#x3D; document.createElement(&quot;div&quot;);</span><br><span class="line">element.className &#x3D; &quot;message&quot;;</span><br><span class="line">var textNode &#x3D; document.createTextNode(&quot;Hello world!&quot;);</span><br><span class="line">element.appendChild(textNode);</span><br><span class="line">var anotherTextNode &#x3D; document.createTextNode(&quot;Yippee!&quot;);</span><br><span class="line">element.appendChild(anotherTextNode);</span><br><span class="line">document.body.appendChild(element);</span><br><span class="line">alert(element.childNodes.length);    &#x2F;&#x2F;2</span><br><span class="line">element.normalize();</span><br><span class="line">alert(element.childNodes.length);    &#x2F;&#x2F;1</span><br><span class="line">alert(element.firstChild.nodeValue); &#x2F;&#x2F; &quot;Hello world!Yippee!&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Comment-类型-8"><a href="#Comment-类型-8" class="headerlink" title="Comment 类型 (8)"></a>Comment 类型 (8)</h3><p>Comment 类型与 Text 类型继承自相同的基类，因此他拥有除 splitText 外的所有字符串操作方法</p>
<h3 id="CDATASection-类型-4"><a href="#CDATASection-类型-4" class="headerlink" title="CDATASection 类型 (4)"></a>CDATASection 类型 (4)</h3><p>CDATASection 类型只针对基于 XML 的文档，表示的是 CDATA 区域，方法与 Comment 类似(拥有除 splitText 方法)</p>
<h3 id="DocumentType-类型-10"><a href="#DocumentType-类型-10" class="headerlink" title="DocumentType 类型 (10)"></a>DocumentType 类型 (10)</h3><p>包含于文档的 doctype 有关的所有信息，很少使用。</p>
<p>通过<code>document.doctype</code>读取</p>
<h3 id="DocumentFragment-类型-11"><a href="#DocumentFragment-类型-11" class="headerlink" title="DocumentFragment 类型 (11)"></a>DocumentFragment 类型 (11)</h3><p>可以包含和控制节点，但不会像完整的文档那样占用额外的资源，一般当做‘临时仓库’来使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fragment &#x3D; document.createDocumentFragment();</span><br><span class="line">    var ul &#x3D; document.getElementById(&quot;myList&quot;);</span><br><span class="line">    var li &#x3D; null;</span><br><span class="line">    for (var i&#x3D;0; i &lt; 3; i++)&#123;</span><br><span class="line">        li &#x3D; document.createElement(&quot;li&quot;);</span><br><span class="line">        li.appendChild(document.createTextNode(&quot;Item &quot; + (i+1)));</span><br><span class="line">        fragment.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line">    ul.appendChild(fragment);</span><br></pre></td></tr></table></figure>

<h3 id="Attr-类型-2"><a href="#Attr-类型-2" class="headerlink" title="Attr 类型 (2)"></a>Attr 类型 (2)</h3><p>元素的特性，id、class 等属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var attr &#x3D; document.createAttribute(&quot;align&quot;);</span><br><span class="line">attr.value &#x3D; &quot;left&quot;;</span><br><span class="line">element.setAttributeNode(attr);</span><br><span class="line">alert(element.attributes[&quot;align&quot;].value);</span><br><span class="line">alert(element.getAttributeNode(&quot;align&quot;).value); &#x2F;&#x2F;&quot;left&quot;</span><br><span class="line">alert(element.getAttribute(&quot;align&quot;));           &#x2F;&#x2F;&quot;left&quot;</span><br></pre></td></tr></table></figure>

<h2 id="DOM-操作技术"><a href="#DOM-操作技术" class="headerlink" title="DOM 操作技术"></a>DOM 操作技术</h2><h3 id="动态插入脚本"><a href="#动态插入脚本" class="headerlink" title="动态插入脚本"></a>动态插入脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function loadScriptString(code)&#123;</span><br><span class="line">    var script &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">    script.type &#x3D; &quot;text&#x2F;javascript&quot;;</span><br><span class="line">    try &#123;</span><br><span class="line">        script.appendChild(document.createTextNode(code));</span><br><span class="line">    &#125; catch (ex)&#123;</span><br><span class="line">        script.text &#x3D; code;</span><br><span class="line">    &#125;</span><br><span class="line">    document.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function loadStyleString(css)&#123;</span><br><span class="line">        var style &#x3D; document.createElement(&quot;style&quot;);</span><br><span class="line">        style.type &#x3D; &quot;text&#x2F;css&quot;;</span><br><span class="line">    try&#123;</span><br><span class="line">        style.appendChild(document.createTextNode(css));</span><br><span class="line">    &#125; catch (ex)&#123;</span><br><span class="line">        style.styleSheet.cssText &#x3D; css;</span><br><span class="line">    &#125;</span><br><span class="line">    var head &#x3D; document.getElementsByTagName(&quot;head&quot;)[0];</span><br><span class="line">    head.appendChild(style);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NodeList"><a href="#NodeList" class="headerlink" title="NodeList"></a>NodeList</h3><p>NodeList、NamedNodeMap、HTMLCollection 都是即时的，一直保持最新</p>
]]></content>
      <tags>
        <tag>javascript高级笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM扩展</title>
    <url>/my-notes/2019/06/14/js%E9%AB%98%E7%BA%A7/11.DOM%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h2 id="选择符-api"><a href="#选择符-api" class="headerlink" title="选择符 api"></a>选择符 api</h2><h3 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector"></a>querySelector</h3><h3 id="queryselectorAll"><a href="#queryselectorAll" class="headerlink" title="queryselectorAll"></a>queryselectorAll</h3><h3 id="matchesSelector"><a href="#matchesSelector" class="headerlink" title="matchesSelector"></a>matchesSelector</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> if (document.body.matchesSelector(&quot;body.page1&quot;))&#123;</span><br><span class="line">        &#x2F;&#x2F; document.body.matchesSelector is not a function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>chrome 现在还没支持(2019-6)</p>
<h2 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h2><ul>
<li>childElementCount 返回子元素个数（不包过文本节点和注释）</li>
<li>firstElementChild 返回第一个子元素</li>
<li>lastElementChild 返回最后一个子元素</li>
<li>previousElementSibling 前一个同辈元素</li>
<li>nextElementSibling 后一个同辈元素</li>
</ul>
<h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="class-相关扩充"><a href="#class-相关扩充" class="headerlink" title="class 相关扩充"></a>class 相关扩充</h3><ol>
<li>getElementByClassName</li>
<li>classList</li>
</ol>
<ul>
<li>add(value) 添加一个类，重复不添加</li>
<li>contains(vale) 是否包含一个类</li>
<li>remove(value) 删除一个类</li>
<li>toggle(value) 存在就删除，不存在就添加</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div.classList.remove(&quot;disabled&quot;);</span><br><span class="line">div.classList.add(&quot;current&quot;);</span><br></pre></td></tr></table></figure>

<p>只有 firefox 和 chrome 支持</p>
<h3 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var button &#x3D; document.getElementById(&quot;myButton&quot;);</span><br><span class="line">button.focus();</span><br><span class="line">alert(document.activeElement &#x3D;&#x3D;&#x3D; button);   &#x2F;&#x2F;true</span><br><span class="line">alert(document.hasFocus());  &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p>document.activeElement 默认是 document.body</p>
<h3 id="HTMLDocument-变化"><a href="#HTMLDocument-变化" class="headerlink" title="HTMLDocument 变化"></a>HTMLDocument 变化</h3><ul>
<li>readyState: loading(正在加载) complete(加载完文档)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (document.readyState &#x3D;&#x3D; &quot;complete&quot;)&#123;</span><br><span class="line">    &#x2F;&#x2F; TODO􏴤􏱣􏰉􏰊</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>兼容模式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (document.compatMode &#x3D;&#x3D; &quot;CSS1Compat&quot;)&#123;</span><br><span class="line">        alert(&quot;Standards mode&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">        alert(&quot;Quirks mode&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>head</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var head &#x3D; document.head || document.getElementsByTagName(&quot;head&quot;)[0];</span><br></pre></td></tr></table></figure>

<h3 id="字符集属性"><a href="#字符集属性" class="headerlink" title="字符集属性"></a>字符集属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert(document.charset); &#x2F;&#x2F;&quot;UTF-16&quot;</span><br><span class="line">document.charset &#x3D; &quot;UTF-8&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>data-*</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var div &#x3D; document.getElementById(&quot;myDiv&quot;);</span><br><span class="line">&#x2F;&#x2F;􏱏􏷚􏰎定􏰐􏰪􏰌的􏰯</span><br><span class="line">var appId &#x3D; div.dataset.appId; var myName &#x3D; div.dataset.myname;</span><br><span class="line">&#x2F;&#x2F;􏰓􏰔􏰯</span><br><span class="line">div.dataset.appId &#x3D; 23456; div.dataset.myname &#x3D; &quot;Michael&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="插入标记"><a href="#插入标记" class="headerlink" title="插入标记"></a>插入标记</h3><ol>
<li>innerHTML</li>
<li>outerHTML</li>
<li>insertAdjacentHTML</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;􏰊􏰝􏱛􏰚􏰒􏱐􏺘􏰶􏰷􏶈􏳖 作为前一个同辈元素插入</span><br><span class="line">element.insertAdjacentHTML(&quot;beforebegin&quot;, &quot;&lt;p&gt;Hello world!&lt;&#x2F;p&gt;&quot;);</span><br><span class="line">&#x2F;&#x2F;􏰊􏰝􏰀􏰚􏰒􏱁􏰶􏰷􏶈􏳖 第一个</span><br><span class="line">element.insertAdjacentHTML(&quot;afterbegin&quot;, &quot;&lt;p&gt;Hello world!&lt;&#x2F;p&gt;&quot;);</span><br><span class="line">&#x2F;&#x2F;􏰊􏰝􏰣􏲄􏰚􏰒􏱁􏰶􏰷􏶈􏳖 最后一个</span><br><span class="line">element.insertAdjacentHTML(&quot;beforeend&quot;, &quot;&lt;p&gt;Hello world!&lt;&#x2F;p&gt;&quot;);</span><br><span class="line">&#x2F;&#x2F;􏰊􏰝􏲄􏰚􏰒􏱐􏺘􏰶􏰷􏶈􏳖 后一个</span><br><span class="line">element.insertAdjacentHTML(&quot;afterend&quot;, &quot;&lt;p&gt;Hello world!&lt;&#x2F;p&gt;&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="scrollIntoView"><a href="#scrollIntoView" class="headerlink" title="scrollIntoView"></a>scrollIntoView</h3><p>让元素进入可见范围</p>
]]></content>
      <tags>
        <tag>javascript高级笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM2和DOM3</title>
    <url>/my-notes/2019/06/14/js%E9%AB%98%E7%BA%A7/12.DOM2%E5%92%8CDOM3/</url>
    <content><![CDATA[<h2 id="DOM-变化"><a href="#DOM-变化" class="headerlink" title="DOM 变化"></a>DOM 变化</h2><p>和 XML 有关，先不看</p>
<h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><h3 id="访问元素样式"><a href="#访问元素样式" class="headerlink" title="访问元素样式"></a>访问元素样式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myDiv &#x3D; document.getElementById(&quot;myDiv&quot;);</span><br><span class="line">myDiv.style.backgroundColor &#x3D; &quot;red&quot;;</span><br><span class="line">myDiv.style.width &#x3D; &quot;100px&quot;;</span><br><span class="line">myDiv.style.height &#x3D; &quot;200px&quot;;</span><br></pre></td></tr></table></figure>

<h4 id="dom-样式的属性和方法"><a href="#dom-样式的属性和方法" class="headerlink" title="dom 样式的属性和方法"></a>dom 样式的属性和方法</h4><ul>
<li>cssText: 能通过它访问到 style 特性中的 css 代码</li>
<li>length: style 中 css 数量</li>
<li>parentRule: 表示 css 信息的 cssRule 对象</li>
<li>getPropertyCSSValue(propertyName): 返回包含给定属性值的 cssValue 对象</li>
<li>getPropertyPriority(propertyName): 如果给定的属性使用了!import，返回 import;否则返回空字符串</li>
<li>getPropertyValue(propertyName): 返回给定属性的字符串值</li>
<li>item(index): 返回给定位置的 css 属性的名称</li>
<li>removeProperty(propertyName): 从样式中删除属性</li>
<li>setProperty(propertyName,value,priority): 给属性设值，！import</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myDiv.style.cssText &#x3D; &quot;width: 25px; height: 100px; background-color: green&quot;; alert(myDiv.style.cssText);</span><br></pre></td></tr></table></figure>

<h4 id="计算的样式"><a href="#计算的样式" class="headerlink" title="计算的样式"></a>计算的样式</h4><p>xxx.style 只能获取 style 里面的属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Computed Styles Example&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">        #myDiv &#123;</span><br><span class="line">            background-color: blue;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;myDiv&quot; style&#x3D;&quot;background-color: red; border: 1px solid black&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line">var myDiv &#x3D; document.getElementById(&quot;myDiv&quot;);</span><br><span class="line">var computedStyle &#x3D; document.defaultView.getComputedStyle(myDiv, null);</span><br><span class="line">var computedStyle &#x3D; myDiv.currentStyle; &#x2F;&#x2F; IE</span><br><span class="line"> alert(computedStyle.backgroundColor);</span><br><span class="line">alert(computedStyle.width);</span><br><span class="line">alert(computedStyle.height);</span><br><span class="line">alert(computedStyle.border);</span><br></pre></td></tr></table></figure>

<h3 id="元素大小"><a href="#元素大小" class="headerlink" title="元素大小"></a>元素大小</h3><h4 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h4><ul>
<li>offsetHeight: 元素在垂直方向上占用空间大小，包括元素的高度、(可见的)水平滚动条的高度、上下边框高度</li>
<li>offsetWidth: 水平方向。。。。</li>
<li>offsetLeft: 元素左外边框至父元素左内边框之间的距离</li>
<li>offsetTop: 上。。。</li>
</ul>
<h4 id="客户区大小"><a href="#客户区大小" class="headerlink" title="客户区大小"></a>客户区大小</h4><p>元素内容及其内边距所占据的空间大小</p>
<ul>
<li>clientWidth: 内容+内边距的宽度</li>
<li>clientHeight: 内容+内边距的高度</li>
</ul>
<h4 id="滚动大小"><a href="#滚动大小" class="headerlink" title="滚动大小"></a>滚动大小</h4><ul>
<li>scrollHeight: 没有滚动条的情况下，元素内容的总高度</li>
<li>scrollWidth: 。。。。总宽度</li>
<li>scrollLeft: 被影藏在内容区左侧的像素数，可以用来设置滚动条位置</li>
<li>scrollTop: 上方</li>
</ul>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="NodeIterator"><a href="#NodeIterator" class="headerlink" title="NodeIterator"></a>NodeIterator</h4><p>document.createNodeIterator(root, whatToShow, filter, entityReferenceExpansion)</p>
<ul>
<li>root: 搜索起点的节点</li>
<li>whatToShow: 表示要访问哪些节点的数字代码</li>
<li>filter: 是一个 NodeFilter 对象，或一个表示应该接受还是拒绝某种特定节点的函数</li>
<li>entityReferenceExpansion: 表示是否要扩展实体引用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var div &#x3D; document.getElementById(&quot;div1&quot;);</span><br><span class="line">    var filter &#x3D; function(node)&#123;</span><br><span class="line">        return node.tagName.toLowerCase() &#x3D;&#x3D; &quot;li&quot; ?</span><br><span class="line">            NodeFilter.FILTER_ACCEPT :</span><br><span class="line">            NodeFilter.FILTER_SKIP;</span><br><span class="line">&#125;;</span><br><span class="line">var iterator &#x3D; document.createNodeIterator(div, NodeFilter.SHOW_ELEMENT, filter, false);</span><br><span class="line">var node &#x3D; iterator.nextNode();</span><br><span class="line">while (node !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    alert(node.tagName);</span><br><span class="line">    node &#x3D; iterator.nextNode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TreeWorker"><a href="#TreeWorker" class="headerlink" title="TreeWorker"></a>TreeWorker</h4><p>document.createTreeWalker() 4 个参数同 createNodeIterator</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var div &#x3D; document.getElementById(&quot;div1&quot;);</span><br><span class="line">var walker &#x3D; document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, null, false);</span><br><span class="line">walker.firstChild();</span><br><span class="line">walker.nextSibling();</span><br><span class="line">var node &#x3D; walker.firstChild();</span><br><span class="line">while (node !&#x3D;&#x3D; null) &#123; alert(node.tagName);</span><br><span class="line">node &#x3D; walker.nextSibling();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2>]]></content>
      <tags>
        <tag>javascript高级笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>事件</title>
    <url>/my-notes/2019/06/14/js%E9%AB%98%E7%BA%A7/13.%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>javascript高级笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Canvas</title>
    <url>/my-notes/2019/06/14/js%E9%AB%98%E7%BA%A7/15.Canvas/</url>
    <content><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>创建获取 canvas</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;canvas id&#x3D;&quot;drawing&quot; width&#x3D;&quot; 200&quot; height&#x3D;&quot;200&quot;&gt;A drawing of something.&lt;&#x2F;canvas&gt;</span><br><span class="line"></span><br><span class="line">var drawing &#x3D; document.getElementById(&quot;drawing&quot;);</span><br><span class="line">if (drawing.getContext)&#123;</span><br><span class="line">    var context &#x3D; drawing.getContext(&quot;2d&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;􏴺􏸿􏸞􏴿 canvas转化为图片链接</span><br><span class="line">    var imgURI &#x3D; drawing.toDataURL(&quot;image&#x2F;png&quot;);</span><br><span class="line">    var image &#x3D; document.createElement(&quot;img&quot;); image.src &#x3D; imgURI; document.body.appendChild(image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2D-上下文"><a href="#2D-上下文" class="headerlink" title="2D 上下文"></a>2D 上下文</h2><h3 id="填充-fillStyle-和描边-strokeStyle"><a href="#填充-fillStyle-和描边-strokeStyle" class="headerlink" title="填充(fillStyle)和描边(strokeStyle)"></a>填充(fillStyle)和描边(strokeStyle)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var drawing &#x3D; document.getElementById(&quot;drawing&quot;);</span><br><span class="line">if (drawing.getContext)&#123;</span><br><span class="line">    var context &#x3D; drawing.getContext(&quot;2d&quot;);</span><br><span class="line">    context.strokeStyle &#x3D; &quot;red&quot;;</span><br><span class="line">    context.fillStyle &#x3D; &quot;#0000ff&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><p><code>fillRect</code>在画布上绘制矩形会填充指定颜色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var drawing &#x3D; document.getElementById(&quot;drawing&quot;);</span><br><span class="line">if (drawing.getContext)&#123;</span><br><span class="line">    var context &#x3D; drawing.getContext(&quot;2d&quot;);</span><br><span class="line"></span><br><span class="line">    context.fillStyle &#x3D; &quot;#ff0000&quot;;</span><br><span class="line">    context.fillRect(10, 10, 50, 50);</span><br><span class="line"></span><br><span class="line">    context.fillStyle &#x3D; &quot;rgba(0,0,255,0.5)&quot;;</span><br><span class="line">    context.fillRect(30, 30, 50, 50);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>strokeRect</code>指定矩形描边颜色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">context.strokeStyle &#x3D; &quot;#ff0000&quot;;</span><br><span class="line">context.strokeRect(10, 10, 50, 50);</span><br></pre></td></tr></table></figure>

<p><code>clearRect</code>清除画布上指定矩形区域</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">context.clearRect(40, 40, 10, 10);</span><br></pre></td></tr></table></figure>

<h3 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h3><ul>
<li>arc(x, y, radius, startAngle, endAngle, counterclockwise): 以(x,y)为圆心，radius 为半径画弧线，startAngle 和 endAngle 是起始结束角度，counterclockwise 为 true 是逆时针</li>
<li>arcTo(x1, y1, x2, y2, radius): 从上一点开始画一条经过(x1,y1)(x2,y2)的以 radius 为半径的弧线</li>
<li>bezierCurveTo(c1x, c1y, c2x, c2y, x, y)：从上一点开始绘制一条到(x,y)的曲线，以(c1x,c1y)(c2x,c2y)为控制点。三次贝塞尔曲线</li>
<li>lineTo(x, y): 从上一点开始画到(x,y)的直线</li>
<li>moveTo(x, y): 把游标移到想 x,y,不划线</li>
<li>quadraticCurveTo(cx, cy, x, y): 二次曲线</li>
<li>rect(x, y, width, height): 绘制矩形路径</li>
</ul>
<h3 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">context.font &#x3D; &quot;bold 14px Arial&quot;;</span><br><span class="line">context.textAlign &#x3D; &quot;center&quot;;</span><br><span class="line">context.textBaseline &#x3D; &quot;middle&quot;;</span><br><span class="line">context.fillText(&quot;文本&quot;, 100, 20);</span><br></pre></td></tr></table></figure>

<h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><ul>
<li>rotate(angle): 围绕远点旋转</li>
<li>scale(scaleX,scaleY): 缩放</li>
<li>translate(x,y)􏴣: 将坐标远点移到(x,y)</li>
<li>transform(m1_1, m1_2, m2_1, m2_2, dx, dy): 直接修改变换矩阵,即乘以下面矩阵<br>m1_1 m1_2 dx<br>m2_1 m2_2 dy<br>0 0 1</li>
<li>setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy): 先将矩阵变为默认状态，在用 transform 处理</li>
</ul>
<h3 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var image &#x3D; document.images[0];</span><br><span class="line">context.drawImage(image, 10, 10); &#x2F;&#x2F; 指定点绘制图像</span><br><span class="line">context.drawImage(image, 50, 10, 20, 30); &#x2F;&#x2F; 指钉点绘制指定大小的图形</span><br><span class="line">context.drawImage(image, 0, 10, 50, 50, 0, 100, 40, 60) &#x2F;&#x2F; 从原图上选取区域指定点绘制图像</span><br></pre></td></tr></table></figure>

<h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><ul>
<li>shadowColor: 阴影颜色，默认黑</li>
<li>shadowOffsetX: x 方向偏移量，默认 0</li>
<li>shadowOffsetY: y 方向偏移量，默认 0</li>
<li>shadowBlur: 模糊像素，默认 0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">context.shadowOffsetX &#x3D; 5; context.shadowOffsetY &#x3D; 5;</span><br><span class="line">context.shadowBlur &#x3D; 4; context.shadowColor &#x3D; &quot;rgba(0, 0, 0, 0.5)&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var gradient &#x3D; context.createLinearGradient(30, 30, 70, 70);</span><br><span class="line">   gradient.addColorStop(0, &quot;white&quot;);</span><br><span class="line">   gradient.addColorStop(1, &quot;black&quot;);</span><br><span class="line">   context.fillStyle &#x3D; gradient;</span><br><span class="line">   context.fillRect(30, 30, 50, 50);</span><br></pre></td></tr></table></figure>

<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var image &#x3D; document.images[0],</span><br><span class="line">pattern &#x3D; context.createPattern(image, &quot;repeat&quot;);</span><br><span class="line">context.fillStyle &#x3D; pattern; context.fillRect(10, 10, 150, 150);</span><br></pre></td></tr></table></figure>

<h3 id="使用图像数据"><a href="#使用图像数据" class="headerlink" title="使用图像数据"></a>使用图像数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var imageData &#x3D; context.getImageData(10, 5, 50, 50);</span><br></pre></td></tr></table></figure>

<p>imageData 有 width,height,data 这些属性</p>
<p>其中 data 是一个数组，保存了每一个像素点的色值，每个像素点取 4 个位置，如第一个点的 rgba 是 data<a href="r">0</a>,data<a href="g">1</a>,data<a href="b">2</a>,data<a href="a">3</a></p>
<h3 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h3><ul>
<li>globalAlpha: 操作透明值</li>
<li>globalCompositionOperation: 当两个图像重叠时，控制重叠方案</li>
</ul>
<h2 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h2><p>TODO:暂时没必要看</p>
]]></content>
      <tags>
        <tag>javascript高级笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5脚本编程</title>
    <url>/my-notes/2019/06/14/js%E9%AB%98%E7%BA%A7/16.HTML5%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="跨文档消息传递-XDM"><a href="#跨文档消息传递-XDM" class="headerlink" title="跨文档消息传递(XDM)"></a>跨文档消息传递(XDM)</h2><p>发送消息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var iframeWindow &#x3D; document.getElementById(&quot;myframe&quot;).contentWindow; iframeWindow.postMessage(&quot;A secret&quot;, &quot;http:&#x2F;&#x2F;www.wrox.com&quot;);</span><br></pre></td></tr></table></figure>

<p>接受消息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EventUtil.addHandler(window, &quot;message&quot;, function(event)&#123;</span><br><span class="line">    if (event.origin &#x3D;&#x3D; &quot;http:&#x2F;&#x2F;www.wrox.com&quot;)&#123;</span><br><span class="line">        processMessage(event.data);</span><br><span class="line">        event.source.postMessage(&quot;Received!&quot;, &quot;http:&#x2F;&#x2F;p2p.wrox.com&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="原生拖放"><a href="#原生拖放" class="headerlink" title="原生拖放"></a>原生拖放</h2><h3 id="拖放事件"><a href="#拖放事件" class="headerlink" title="拖放事件"></a>拖放事件</h3><p>拖放元素会触发下面方法<br>(1) dragstart<br>(2) drag<br>(3) dragend</p>
<p>目标元素会触发下面方法<br>(1) dragenter<br>(2) dragover<br>(3) dragleave 或 drop</p>
<h3 id="dataTransfer-对象"><a href="#dataTransfer-对象" class="headerlink" title="dataTransfer 对象"></a>dataTransfer 对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">event.dataTransfer.setData(&quot;text&quot;, &quot;some text&quot;);</span><br><span class="line">var text &#x3D; event.dataTransfer.getData(&quot;text&quot;);</span><br><span class="line"></span><br><span class="line">event.dataTransfer.setData(&quot;URL&quot;, &quot;http:&#x2F;&#x2F;www.wrox.com&#x2F;&quot;);</span><br><span class="line">var url &#x3D; event.dataTransfer.getData(&quot;URL&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="dropEffect-与-effectAllowed"><a href="#dropEffect-与-effectAllowed" class="headerlink" title="dropEffect 与 effectAllowed"></a>dropEffect 与 effectAllowed</h3><p>传递行为</p>
<h2 id="媒体元素"><a href="#媒体元素" class="headerlink" title="媒体元素"></a>媒体元素</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;video src&#x3D;&quot;conference.mpg&quot; id&#x3D;&quot;myVideo&quot;&gt;Video player not available.&lt;&#x2F;video&gt;</span><br><span class="line">&lt;audio src&#x3D;&quot;song.mp3&quot; id&#x3D;&quot;myAudio&quot;&gt;Audio player not available.&lt;&#x2F;audio&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript高级笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>错误的处理与调试</title>
    <url>/my-notes/2019/06/14/js%E9%AB%98%E7%BA%A7/17.%E9%94%99%E8%AF%AF%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h2 id="浏览器报告的错误"><a href="#浏览器报告的错误" class="headerlink" title="浏览器报告的错误"></a>浏览器报告的错误</h2><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    &#x2F;&#x2F; 可能会出错的代码</span><br><span class="line">&#125; catch(error)&#123;</span><br><span class="line">    &#x2F;&#x2F; 处理</span><br><span class="line">    console.error(error)</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    &#x2F;&#x2F; 都会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h4><ul>
<li>Error</li>
<li>EvalError: eval 报错 eg: new eval();</li>
<li>RangeError: 数值超出范围 eg: var items1 = new Array(-20);</li>
<li>ReferenceError: 访问不存在的变量</li>
<li>SyntaxError: 在 eval 中使用错误语法 eg: eval(“a ++ b”)</li>
<li>TypeError: 类型错误 eg: var o = new 10;</li>
<li>URIError: encodeURI 传入格式不正确</li>
</ul>
<h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">throw 12345;</span><br><span class="line">&#x2F;&#x2F; 模拟浏览器错误</span><br><span class="line">throw new SyntaxError(&quot;I don’t like your syntax.&quot;);</span><br><span class="line">throw new TypeError(&quot;What type of variable do you take me for?&quot;); throw new RangeError(&quot;Sorry, you just don’t have the range.&quot;);</span><br><span class="line">throw new EvalError(&quot;That doesn’t evaluate.&quot;);</span><br><span class="line">throw new URIError(&quot;Uri, is that you?&quot;);</span><br><span class="line">throw new ReferenceError(&quot;You didn’t cite your references properly.&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="错误事件"><a href="#错误事件" class="headerlink" title="错误事件"></a>错误事件</h3><p>没有通过 try-catch 处理的错误都会触发 window.error</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onerror &#x3D; function(message, url, line)&#123;</span><br><span class="line">        alert(message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript高级笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>在html使用js</title>
    <url>/my-notes/2019/06/14/js%E9%AB%98%E7%BA%A7/2.%E5%9C%A8html%E4%BD%BF%E7%94%A8js/</url>
    <content><![CDATA[<h3 id="script"><a href="#script" class="headerlink" title="script"></a>script</h3><ul>
<li>async 异步加载，立即执行</li>
<li>defer 异步加载，延迟执行（在所有元素解析完成之后，DOMContentLoaded 事件触发之前）</li>
</ul>
]]></content>
      <tags>
        <tag>javascript高级笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax与Comet</title>
    <url>/my-notes/2019/06/14/js%E9%AB%98%E7%BA%A7/21.Ajax%E4%B8%8EComet/</url>
    <content><![CDATA[<h2 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ie7以前</span><br><span class="line">function createXHR()&#123;</span><br><span class="line">    if (typeof arguments.callee.activeXString !&#x3D; &quot;string&quot;)&#123;</span><br><span class="line">        var versions &#x3D; [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;,</span><br><span class="line">                        &quot;MSXML2.XMLHttp&quot;],i, len;</span><br><span class="line">        for (i&#x3D;0,len&#x3D;versions.length; i &lt; len; i++)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                new ActiveXObject(versions[i]);</span><br><span class="line">                arguments.callee.activeXString &#x3D; versions[i];</span><br><span class="line">                break;</span><br><span class="line">            &#125; catch (ex)&#123;</span><br><span class="line">                &#x2F;&#x2F;􏰳􏰴</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new ActiveXObject(arguments.callee.activeXString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ie7之后</span><br><span class="line">new XMLHttpRequest()</span><br></pre></td></tr></table></figure>

<h3 id="XHR-用法"><a href="#XHR-用法" class="headerlink" title="XHR 用法"></a>XHR 用法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.open(&quot;get&quot;, &quot;example.php&quot;, false); &#x2F;&#x2F; 方法、url、是否异步</span><br><span class="line">xhr.send(null); &#x2F;&#x2F; 发送数据</span><br></pre></td></tr></table></figure>

<p>响应之后 hxr 会有以下属性</p>
<ul>
<li>responseText: 返回数据</li>
<li>responseXML: 内容类型</li>
<li>status: http 状态</li>
<li>statusText: http 状态说明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ((xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt; 300) || xhr.status &#x3D;&#x3D; 304)&#123;</span><br><span class="line">      alert(xhr.responseText);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      alert(&quot;Request was unsuccessful: &quot; + xhr.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步发送时，需判断 xhr 的 readyState,才能确定 ajax 的状态</p>
<ul>
<li>0：未初始化。未调用 open</li>
<li>1：启动。已 open 未 send</li>
<li>2：发送。已 send 未接收到响应</li>
<li>3：接收。已接收到部分响应数据</li>
<li>4：完成。接收到全部数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xhr &#x3D; createXHR();</span><br><span class="line">xhr.onreadystatechange &#x3D; function()&#123;</span><br><span class="line">    if (xhr.readyState &#x3D;&#x3D; 4)&#123;</span><br><span class="line">        if ((xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt; 300) || xhr.status &#x3D;&#x3D; 304)&#123;</span><br><span class="line">              alert(xhr.responseText);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">             alert(&quot;Request was unsuccessful: &quot; + xhr.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(&quot;get&quot;, &quot;example.txt&quot;, true);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>

<h3 id="HTTP-头部信息"><a href="#HTTP-头部信息" class="headerlink" title="HTTP 头部信息"></a>HTTP 头部信息</h3><p>发送头部信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.setRequestHeader(&quot;MyHeader&quot;, &quot;MyValue&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="XMLHttpRequest-2-级"><a href="#XMLHttpRequest-2-级" class="headerlink" title="XMLHttpRequest 2 级"></a>XMLHttpRequest 2 级</h2><h3 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h3><p>发送表单数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var form &#x3D; document.getElementById(&quot;user-info&quot;);</span><br><span class="line">xhr.send(new FormData(form));</span><br></pre></td></tr></table></figure>

<h3 id="超时设定"><a href="#超时设定" class="headerlink" title="超时设定"></a>超时设定</h3><p>响应时间过长会停止</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.timeout &#x3D; 1000; &#x2F;&#x2F;􏿬􏼭􏾭􏱵􏱹􏱺1􏱻􏱼􏱽􏱾􏱖􏿅􏱗IE8+􏱿</span><br><span class="line">xhr.ontimeout &#x3D; function()&#123;</span><br><span class="line">    alert(&quot;Request did not return in a second.&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="overrideMimeType"><a href="#overrideMimeType" class="headerlink" title="overrideMimeType()"></a>overrideMimeType()</h3><p>重写返回的 MIME 类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xhr &#x3D; createXHR();</span><br><span class="line">xhr.open(&quot;get&quot;, &quot;text.php&quot;, true); xhr.overrideMimeType(&quot;text&#x2F;xml&quot;);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>

<h2 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h2><ul>
<li>loadstart: 在接收到相应数据的第一个字节时触发</li>
<li>progress: 响应期间持续触发</li>
<li>error: 请求发生错误触发</li>
<li>abort: 在主动调用 abort 时触发</li>
<li>load: 接收完整数据后触发</li>
<li>loadend: 类似 finally,结束都会触发</li>
</ul>
<p>progress 进度条</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xhr &#x3D; createXHR(); 21 xhr.onload &#x3D; function(event)&#123;</span><br><span class="line">    if ((xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt; 300) ||</span><br><span class="line">            xhr.status &#x3D;&#x3D; 304)&#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        alert(&quot;Request was unsuccessful: &quot; + xhr.status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.onprogress &#x3D; function(event)&#123;</span><br><span class="line">    var divStatus &#x3D; document.getElementById(&quot;status&quot;);</span><br><span class="line">    if (event.lengthComputable)&#123;</span><br><span class="line">        divStatus.innerHTML &#x3D; &quot;Received &quot; + event.position + &quot; of &quot; +</span><br><span class="line">            event.totalSize +&quot; bytes&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">xhr.open(&quot;get&quot;, &quot;altevents.php&quot;, true);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>

<h2 id="跨域资源共享"><a href="#跨域资源共享" class="headerlink" title="跨域资源共享"></a>跨域资源共享</h2><h2 id="其他跨域技术"><a href="#其他跨域技术" class="headerlink" title="其他跨域技术"></a>其他跨域技术</h2><h3 id="图像-ping"><a href="#图像-ping" class="headerlink" title="图像 ping"></a>图像 ping</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var img &#x3D; new Image();</span><br><span class="line">img.onload &#x3D; img.onerror &#x3D; function()&#123;</span><br><span class="line">    alert(&quot;Done!&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">img.src &#x3D; &quot;http:&#x2F;&#x2F;www.example.com&#x2F;test?name&#x3D;Nicholas&quot;;</span><br></pre></td></tr></table></figure>

<p>只能 get,无法响应返回文本，是单向通信</p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>利用 script 请求数据</p>
<h3 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h3><p>服务器推送技术，有长轮询和流两种实现方式</p>
<h4 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h4><p>浏览器发送请求，和服务器保持连接状态，直到服务器有数据更新，结束然后开始新的一次</p>
<h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><p>readyState 会周期性的变更为 3<br>利用 readyState 状态 3，持续接收比较数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createStreamingClient(url, progress, finished)&#123;</span><br><span class="line">    var xhr &#x3D; new XMLHttpRequest(),</span><br><span class="line">        received &#x3D; 0;</span><br><span class="line">    xhr.open(&quot;get&quot;, url, true);</span><br><span class="line">    xhr.onreadystatechange &#x3D; function()&#123;</span><br><span class="line">        var result;</span><br><span class="line">        if (xhr.readyState &#x3D;&#x3D; 3)&#123;</span><br><span class="line">            result &#x3D; xhr.responseText.substring(received);</span><br><span class="line">            received +&#x3D; result.length;</span><br><span class="line">            progress(result);</span><br><span class="line">        &#125; else if (xhr.readyState &#x3D;&#x3D; 4)&#123;</span><br><span class="line">            finished(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.send(null);</span><br><span class="line">    return xhr;</span><br><span class="line">&#125;</span><br><span class="line">var client &#x3D; createStreamingClient(&quot;streaming.php&quot;, function(data)&#123;</span><br><span class="line">    alert(&quot;Received: &quot; + data);</span><br><span class="line">&#125;, function(data)&#123;</span><br><span class="line">   alert(&quot;Done!&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="服务器发送事件"><a href="#服务器发送事件" class="headerlink" title="服务器发送事件"></a>服务器发送事件</h3><p>SSE api 用于创建到服务器的单向连接，服务器可发送任意数据。服务器的响应 MIME 必须是 text/event-stream</p>
<h4 id="SSE-API"><a href="#SSE-API" class="headerlink" title="SSE API"></a>SSE API</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var source &#x3D; new EventSource(&quot;myevents.php&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>open: 建立连接是触发</li>
<li>mesage：从服务器收到新事件时触发</li>
<li>error: 无法建立连接触发</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source.onmessage &#x3D; function(event)&#123;</span><br><span class="line">    var data &#x3D; event.data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">source.close(); &#x2F;&#x2F; 关闭</span><br></pre></td></tr></table></figure>

<h3 id="Web-Sockets"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</h3><p>Web Sockets 的目标是在一个单独的持久连接上提供全双工、双向通信。</p>
<h4 id="Web-Sockets-API"><a href="#Web-Sockets-API" class="headerlink" title="Web Sockets API"></a>Web Sockets API</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var socket &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;www.example.com&#x2F;server.php&quot;);</span><br></pre></td></tr></table></figure>

<p>同源策略对 websockets 不适用<br>WebSocket 也有 readyState 属性</p>
<ul>
<li>WebSocket.OPENING (0)：正在建立连接</li>
<li>WebSocket.OPEN (1)􏴣：已经建立连接</li>
<li>WebSocket.CLOSING (2)：正在关闭连接</li>
<li>WebSocket.CLOSE (3)：已经关闭连接</li>
</ul>
<p>socket.close(); 可以主动关闭连接</p>
<h4 id="发送和接收数据"><a href="#发送和接收数据" class="headerlink" title="发送和接收数据"></a>发送和接收数据</h4><p>只能发送纯文本数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var socket &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;www.example.com&#x2F;server.php&quot;);</span><br><span class="line">    socket.send(&quot;Hello world!&quot;);</span><br><span class="line">    socket.send(JSON.stringify(message));</span><br></pre></td></tr></table></figure>

<p>接收数据(只能纯文本)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socket.onmessage &#x3D; function(event)&#123;</span><br><span class="line">    var data &#x3D; event.data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h4><p>在生命周期阶段触发</p>
<ul>
<li>open：成功建立连接触发</li>
<li>error：发生错误是触发，连接不能持续</li>
<li>close：连接关闭时触发</li>
</ul>
<p>只有 close 有 event<br>wasClean􏱢(是否关闭)、code(状态码)、reason(服务器返回信息)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socket.onclose &#x3D; function(event)&#123;</span><br><span class="line">    console.log(&quot;Was clean? &quot; + event.wasClean + &quot; Code&#x3D;&quot; + event.code + &quot; Reason&#x3D;&quot; + event.reason);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript高级笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>高级技巧</title>
    <url>/my-notes/2019/06/14/js%E9%AB%98%E7%BA%A7/22.%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h2><h3 id="安全的类型检测"><a href="#安全的类型检测" class="headerlink" title="安全的类型检测"></a>安全的类型检测</h3><p><code>Object.prototype.toString.call</code></p>
<h3 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">    if (this instanceof Person)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">        this.job &#x3D; job;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return new Person(name, age, job);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h3><p>在判断之后直接把判断后的函数赋给当前函数，这样就不用每次都判断了</p>
<h3 id="函数-curry-化"><a href="#函数-curry-化" class="headerlink" title="函数 curry 化"></a>函数 curry 化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function curry(fn)&#123;</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var innerArgs &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">        var finalArgs &#x3D; args.concat(innerArgs);</span><br><span class="line">        return fn.apply(null, finalArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="防篡改对象"><a href="#防篡改对象" class="headerlink" title="防篡改对象"></a>防篡改对象</h2><h3 id="不可扩展对象"><a href="#不可扩展对象" class="headerlink" title="不可扩展对象"></a>不可扩展对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person &#x3D; &#123; name: &quot;Nicholas&quot; &#125;;</span><br><span class="line">Object.preventExtensions(person);</span><br><span class="line">person.age &#x3D; 29;</span><br><span class="line">alert(person.age); &#x2F;&#x2F;undefined</span><br><span class="line">alert(Object.isExtensible(person)); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<h3 id="密封的对象"><a href="#密封的对象" class="headerlink" title="密封的对象"></a>密封的对象</h3><p>不可扩展，[[Configurable]]为 flase</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person &#x3D; &#123; name: &quot;Nicholas&quot; &#125;;</span><br><span class="line">Object.seal(person);</span><br><span class="line">person.age &#x3D; 29;</span><br><span class="line">alert(person.age); &#x2F;&#x2F;undefined</span><br><span class="line">delete person.name;</span><br><span class="line">alert(person.name); &#x2F;&#x2F;&quot;Nicholas&quot;</span><br><span class="line">alert(Object.isExtensible(person)); &#x2F;&#x2F;false</span><br><span class="line">alert(Object.isSealed(person));     &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<h3 id="冻结对象"><a href="#冻结对象" class="headerlink" title="冻结对象"></a>冻结对象</h3><p>既不可扩展，又是密封的，[[Writable]]为 false</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person &#x3D; &#123; name: &quot;Nicholas&quot; &#125;;</span><br><span class="line">Object.freeze(person);</span><br><span class="line">person.age &#x3D; 29;</span><br><span class="line">alert(person.age); &#x2F;&#x2F;undefined</span><br><span class="line">delete person.name;</span><br><span class="line">alert(person.name); &#x2F;&#x2F;&quot;Nicholas&quot;</span><br><span class="line">person.name &#x3D; &quot;Greg&quot;;</span><br><span class="line">alert(person.name); &#x2F;&#x2F;&quot;Nicholas&quot;</span><br><span class="line">alert(Object.isExtensible(person)); &#x2F;&#x2F; false</span><br><span class="line">alert(Object.isSealed(person)); &#x2F;&#x2F; true</span><br><span class="line">alert(Object.isFrozen(person)); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h2 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h2><h3 id="重复的定时器"><a href="#重复的定时器" class="headerlink" title="重复的定时器"></a>重复的定时器</h3><p><code>setTimeout</code> <code>setInterval</code><br>定时器的时间并不一定准确</p>
<h3 id="Yielding-Processes"><a href="#Yielding-Processes" class="headerlink" title="Yielding Processes"></a>Yielding Processes</h3><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>观察者模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function EventTarget()&#123;</span><br><span class="line">        this.handlers &#x3D; &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">    EventTarget.prototype &#x3D; &#123;</span><br><span class="line">        constructor: EventTarget,</span><br><span class="line">        addHandler: function(type, handler)&#123;</span><br><span class="line">            if (typeof this.handlers[type] &#x3D;&#x3D; &quot;undefined&quot;)&#123;</span><br><span class="line">                this.handlers[type] &#x3D; [];</span><br><span class="line">&#125;</span><br><span class="line">            this.handlers[type].push(handler);</span><br><span class="line">        &#125;,</span><br><span class="line">        fire: function(event)&#123;</span><br><span class="line">            if (!event.target)&#123;</span><br><span class="line">                event.target &#x3D; this;</span><br><span class="line">            &#125;</span><br><span class="line">            if (this.handlers[event.type] instanceof Array)&#123;</span><br><span class="line">                var handlers &#x3D; this.handlers[event.type];</span><br><span class="line">                for (var i&#x3D;0, len&#x3D;handlers.length; i &lt; len; i++)&#123;</span><br><span class="line">                    handlers[i](event);</span><br><span class="line">                &#125;</span><br><span class="line">&#125; &#125;,</span><br><span class="line">        removeHandler: function(type, handler)&#123;</span><br><span class="line">            if (this.handlers[type] instanceof Array)&#123;</span><br><span class="line">                var handlers &#x3D; this.handlers[type];</span><br><span class="line">                for (var i&#x3D;0, len&#x3D;handlers.length; i &lt; len; i++)&#123;</span><br><span class="line">                    if (handlers[i] &#x3D;&#x3D;&#x3D; handler)&#123;</span><br><span class="line">                        break;</span><br><span class="line">&#125; &#125;</span><br><span class="line">                handlers.splice(i, 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript高级笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>离线应用与客户端储存</title>
    <url>/my-notes/2019/06/14/js%E9%AB%98%E7%BA%A7/23.%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%82%A8%E5%AD%98/</url>
    <content><![CDATA[<h2 id="离线检测"><a href="#离线检测" class="headerlink" title="离线检测"></a>离线检测</h2><p>1、<br><code>navigator.onLine</code></p>
<p>2、</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EventUtil.addHandler(window, &quot;online&quot;, function()&#123;</span><br><span class="line">    alert(&quot;Online&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">EventUtil.addHandler(window, &quot;offline&quot;, function()&#123;</span><br><span class="line">    alert(&quot;Offline&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h2><p>/offline.manifest 中包含着描述文件，这个文件的 MIME 类型必须是 text/cache-manifest</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html manifest&#x3D;&quot;&#x2F;offline.manifest&quot;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><p>每个浏览器的 cookie 数量限制不一样, 最少的只有 20 个<br>尺寸限制 20k 以内</p>
<h4 id="cookie-的构成"><a href="#cookie-的构成" class="headerlink" title="cookie 的构成"></a>cookie 的构成</h4><ul>
<li>名称</li>
<li>值</li>
<li>域</li>
<li>路径</li>
<li>失效时间</li>
<li>安全标志</li>
</ul>
<h3 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h3><p>最少的 2.5M</p>
<h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h3><p>浏览器数据库<br>TODO: 用的时候再看</p>
]]></content>
      <tags>
        <tag>javascript高级笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>New Api</title>
    <url>/my-notes/2019/06/14/js%E9%AB%98%E7%BA%A7/25.New%20Api/</url>
    <content><![CDATA[<h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">        function draw(timestamp)&#123;</span><br><span class="line">        var drawStart &#x3D; (timestamp || Date.now()),</span><br><span class="line">        diff &#x3D; drawStart - startTime;</span><br><span class="line">        startTime &#x3D; drawStart;</span><br><span class="line">            requestAnimationFrame(draw);</span><br><span class="line">        &#125;</span><br><span class="line">        var requestAnimationFrame &#x3D; window.requestAnimationFrame ||</span><br><span class="line">                                    window.mozRequestAnimationFrame ||</span><br><span class="line">                                    window.webkitRequestAnimationFrame ||</span><br><span class="line">                                    window.msRequestAnimationFrame,</span><br><span class="line">            startTime &#x3D; window.mozAnimationStartTime || Date.now();</span><br><span class="line">        requestAnimationFrame(draw);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="Page-Visibility-API"><a href="#Page-Visibility-API" class="headerlink" title="Page Visibility API"></a>Page Visibility API</h2><ul>
<li>document.hidden: 页面影藏。包括页面在后台标签或浏览器最小化</li>
<li>document.visibilityState (现不推荐使用)<ul>
<li>页面在后台标签或浏览器最小化</li>
<li>页面在前台标签</li>
<li>页面已隐藏，但通过类似 win7 的预览窗口看到</li>
<li>页面在屏幕外执行预渲染处理</li>
</ul>
</li>
<li>visibilitychange: 文档可见(不可见)变化触发</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isHiddenSupported()&#123;</span><br><span class="line">        return typeof (document.hidden || document.msHidden ||</span><br><span class="line">            document.webkitHidden) !&#x3D; &quot;undefined&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">if (document.hidden || document.msHidden || document.webKitHidden)&#123;</span><br><span class="line">    &#x2F;&#x2F;􏸌􏴌􏸍􏸎􏿲页面隐藏了</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F;􏸌􏴌􏾼􏸍􏸎没隐藏</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function handleVisibilityChange()&#123;</span><br><span class="line">    var output &#x3D; document.getElementById(&quot;output&quot;),</span><br><span class="line">    msg;</span><br><span class="line">    if (document.hidden || document.msHidden || document.webkitHidden)&#123;</span><br><span class="line">        msg &#x3D; &quot;Page is now hidden. &quot; + (new Date()) + &quot;&lt;br&gt;&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        msg &#x3D; &quot;Page is now visible. &quot; + (new Date()) + &quot;&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    output.innerHTML +&#x3D; msg;</span><br><span class="line">&#125;</span><br><span class="line">EventUtil.addHandler(document, &quot;msvisibilitychange&quot;, handleVisibilityChange); EventUtil.addHandler(document, &quot;webkitvisibilitychange&quot;,handleVisibilityChange)</span><br></pre></td></tr></table></figure>

<h2 id="Geolocation-API"><a href="#Geolocation-API" class="headerlink" title="Geolocation API"></a>Geolocation API</h2><p>地理定位<code>navigator.geolocation </code></p>
<p>getCurrentPosition()</p>
<ul>
<li>latitude: 十进制维度</li>
<li>longitude：十进制经度</li>
<li>accuracy：坐标精度，单位米</li>
<li>altitude：海拔高度(m)</li>
<li>altitudeAccuracy: 海拔高度精度(m)</li>
<li>heading: 指南针方向 0 表示正北</li>
<li>speed：每秒移动多少米</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(function(position)&#123;</span><br><span class="line">    drawMapCenteredAt(position.coords.latitude, positions.coords.longitude);</span><br><span class="line">&#125;, function(error)&#123; &#x2F;&#x2F; 错误处理</span><br><span class="line">    console.log(&quot;Error code: &quot; + error.code); console.log(&quot;Error message: &quot; + error.message);</span><br><span class="line">&#125;, &#123; &#x2F;&#x2F; 设定信息类型</span><br><span class="line">        enableHighAccuracy: true, &#x2F;&#x2F; 尽可能使用最准确的信息</span><br><span class="line">        timeout: 5000, &#x2F;&#x2F; 等待位置信息最长时间</span><br><span class="line">        maximumAge: 25000 &#x2F;&#x2F; 重获坐标时间</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>watchPosition</code> 持续获取位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var watchId &#x3D; navigator.geolocation.watchPosition(function(position)&#123;</span><br><span class="line">    drawMapCenteredAt(position.coords.latitude, positions.coords.longitude);</span><br><span class="line">&#125;, function(error)&#123;</span><br><span class="line">    console.log(&quot;Error code: &quot; + error.code); console.log(&quot;Error message: &quot; + error.message);</span><br><span class="line">&#125;);</span><br><span class="line">clearWatch(watchId); &#x2F;&#x2F; 取消</span><br></pre></td></tr></table></figure>

<h2 id="file-API"><a href="#file-API" class="headerlink" title="file API"></a>file API</h2><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><ul>
<li><p>readAsText(file,encoding)：以纯文本读取文件</p>
</li>
<li><p>readAsDataURL(file)：读取文件并以数据 uri 的形式保存</p>
</li>
<li><p>readAsBinaryString(file)：读取文件字符窜，字符窜中的每一个字符表示一个字节</p>
</li>
<li><p>readAsArrayBuffer(file)：读取文件 ArrayBuffer 形式</p>
</li>
<li><p>progress􏱢 50ms 触发一次</p>
</li>
<li><p>error</p>
</li>
<li><p>load</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reader &#x3D; new FileReader();</span><br><span class="line">reader.onerror &#x3D; function()&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取部分内容"><a href="#读取部分内容" class="headerlink" title="读取部分内容"></a>读取部分内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function blobSlice(blob, startByte, length)&#123;</span><br><span class="line">    if (blob.slice)&#123;</span><br><span class="line">        return blob.slice(startByte, length);</span><br><span class="line">    &#125; else if (blob.webkitSlice)&#123;</span><br><span class="line">        return blob.webkitSlice(startByte, length);</span><br><span class="line">    &#125; else if (blob.mozSlice)&#123;</span><br><span class="line">        return blob.mozSlice(startByte, length);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">blob &#x3D; blobSlice(files[0], 0, 32);</span><br></pre></td></tr></table></figure>

<h3 id="对象-URL"><a href="#对象-URL" class="headerlink" title="对象 URL"></a>对象 URL</h3><p>引用保存在 Blob 或 File 中数据的 url</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createObjectURL(blob)&#123;</span><br><span class="line">    if (window.URL)&#123;</span><br><span class="line">        return window.URL.createObjectURL(blob);</span><br><span class="line">    &#125; else if (window.webkitURL)&#123;</span><br><span class="line">        return window.webkitURL.createObjectURL(blob);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">url &#x3D; createObjectURL(files[0]);</span><br><span class="line">...</span><br><span class="line">output.innerHTML &#x3D; &quot;&lt;img src&#x3D;\&quot;&quot; + url + &quot;\&quot;&gt;&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="读取拖放的文件"><a href="#读取拖放的文件" class="headerlink" title="读取拖放的文件"></a>读取拖放的文件</h3><p><code>files = event.dataTransfer.files;</code></p>
<h3 id="使用-XHR-上传文件"><a href="#使用-XHR-上传文件" class="headerlink" title="使用 XHR 上传文件"></a>使用 XHR 上传文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data &#x3D; new FormData();</span><br><span class="line">files &#x3D; event.dataTransfer.files;</span><br><span class="line">i &#x3D; 0;</span><br><span class="line">len &#x3D; files.length;</span><br><span class="line">while (i &lt; len)&#123;</span><br><span class="line">    data.append(&quot;file&quot; + i, files[i]);</span><br><span class="line">i++; &#125;</span><br><span class="line">xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&quot;post&quot;, &quot;FileAPIExample06Upload.php&quot;, true);</span><br><span class="line">xhr.onreadystatechange &#x3D; function()&#123;</span><br><span class="line">    if (xhr.readyState &#x3D;&#x3D; 4)&#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">&#125; &#125;;</span><br><span class="line">        xhr.send(data);</span><br></pre></td></tr></table></figure>

<h2 id="Web-计时"><a href="#Web-计时" class="headerlink" title="Web 计时"></a>Web 计时</h2><p><code>window.performance </code></p>
<h2 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h2><p>让 javascript 在后台运行</p>
<h3 id="使用-Worker"><a href="#使用-Worker" class="headerlink" title="使用 Worker"></a>使用 Worker</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var worker &#x3D; new Worker(&quot;stufftodo.js&quot;);</span><br><span class="line">worker.postMessage(􏸢start! &quot;); &#x2F;&#x2F; 发送消息，可传对象</span><br><span class="line">worker.postMessage(&#123;</span><br><span class="line">        type: &quot;command&quot;,</span><br><span class="line">        message: &quot;start! &quot;</span><br><span class="line"> &#125;);</span><br><span class="line"> worker.onmessage &#x3D; function(event)&#123;</span><br><span class="line">        var data &#x3D; event.data;</span><br><span class="line">&#125;</span><br><span class="line">worker.onerror &#x3D; function(event)&#123; &#x2F;&#x2F; 运行错误</span><br><span class="line">        console.log(&quot;ERROR: &quot; + event.filename + &quot; (&quot; + event.lineno + &quot;): &quot; +</span><br><span class="line">                    event.message);</span><br><span class="line">&#125;;</span><br><span class="line">worker.terminate(); &#x2F;&#x2F; 停止worker</span><br></pre></td></tr></table></figure>

<h3 id="Worker-全局作用域"><a href="#Worker-全局作用域" class="headerlink" title="Worker 全局作用域"></a>Worker 全局作用域</h3><p>worker 与当前网页不共享作用域，也不能访问 dom</p>
<ul>
<li>navigator 部分属性</li>
<li>只读 location 对象</li>
<li>定时器</li>
<li>XMLHttpRequest</li>
</ul>
<p>eg: worker 排序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// worker内部代码</span></span><br><span class="line">self.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.data;</span><br><span class="line">    data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> a – b;</span><br><span class="line">    &#125;);</span><br><span class="line">    self.postMessage(data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面代码</span></span><br><span class="line"><span class="keyword">var</span> data = [<span class="number">23</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">651</span>,<span class="number">87</span>,<span class="number">41</span>,<span class="number">7798</span>,<span class="number">24</span>],</span><br><span class="line">    worker = <span class="keyword">new</span> Worker(<span class="string">&quot;WebWorkerExample01.js&quot;</span>);</span><br><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.data;</span><br><span class="line">    <span class="comment">// data是排序后的数组</span></span><br><span class="line">&#125;;</span><br><span class="line">worker.postMessage(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker内部</span></span><br><span class="line">self.close(); <span class="comment">// 关闭worker</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript高级笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>基本概念</title>
    <url>/my-notes/2019/06/14/js%E9%AB%98%E7%BA%A7/3.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h3 id="􏽃􏽄􏽅􏸀􏽃􏽄􏽅􏸀-数据类型"><a href="#􏽃􏽄􏽅􏸀􏽃􏽄􏽅􏸀-数据类型" class="headerlink" title="􏽃􏽄􏽅􏸀􏽃􏽄􏽅􏸀 数据类型"></a>􏽃􏽄􏽅􏸀􏽃􏽄􏽅􏸀 数据类型</h3><p>undefined, null, boolean, string, number, object, symbol(es6)</p>
<h3 id="boolean-转换"><a href="#boolean-转换" class="headerlink" title="boolean 转换"></a>boolean 转换</h3><p>true: 非空字符串、非零数值、任何对象<br>false: ‘’、0|NaN、null、undefined</p>
<h3 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h3><ul>
<li>调用 toString 方法</li>
<li>特定值：null, undedined, NaN -&gt; ‘null’, ‘undefined’, ‘NaN’</li>
</ul>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h3><ul>
<li>true -&gt; 1, false -&gt; 0</li>
<li>null -&gt; 0, undefined -&gt; NaN</li>
<li>字符串只有纯数字和进制会被转成 10 进制，’’ -&gt; 0，其他 -&gt; NaN</li>
<li>对象 先调用 valueof,如果是 NaN,在调用 toString</li>
</ul>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><ul>
<li>constructor 构造函数</li>
<li>hasOwnProperty 检测属性是否在对象</li>
<li>isPrototypeOf 检查传入的对象是否是原型</li>
<li>propertyIsEnumerable 是否能用 for-in 枚举</li>
<li>toLocalString 返回对象的字符串表示，结果和执行所在地区有关</li>
<li>toString 返回对象的字符串表示</li>
<li>valueOf 返回对象字符串、数值或布尔表示，通常与 toString 相同</li>
</ul>
]]></content>
      <tags>
        <tag>javascript高级笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>变量作用域内存</title>
    <url>/my-notes/2019/06/14/js%E9%AB%98%E7%BA%A7/4.%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>javascript高级笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>引用类型</title>
    <url>/my-notes/2019/06/14/js%E9%AB%98%E7%BA%A7/5.%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="RegExp-实力属性"><a href="#RegExp-实力属性" class="headerlink" title="RegExp 实力属性"></a>RegExp 实力属性</h3><ul>
<li>global g 全局</li>
<li>ignoreCase i 不区分大小写</li>
<li>lastIndex 开始搜索下一个匹配项的字符位置，默认 0</li>
<li>multiline m 多行</li>
<li>source 正则的字符串表示</li>
</ul>
]]></content>
      <tags>
        <tag>javascript高级笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象</title>
    <url>/my-notes/2019/06/14/js%E9%AB%98%E7%BA%A7/6.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><h4 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h4><ul>
<li><p>[[Configurable]] 能否通过 delete 删除属性, 通过 defineProperty 编辑数据属性 默认 true</p>
</li>
<li><p>[[Enumerable]] 能否用 for-in 循环属性 默认 true</p>
</li>
<li><p>[[Wtirable]] 能否修改属性的值 默认 true</p>
</li>
<li><p>[[Value]] 属性的数据值 默认 undefined</p>
</li>
<li><p>[[Get]] 在读取属性时调用的函数 默认 undefined 旧浏览器兼容可使用<strong>defineGetter</strong></p>
</li>
<li><p>[[Set]] 在写入属性时调用的函数 默认 undefined 旧浏览器兼容可使用<strong>defineSetter</strong></p>
</li>
</ul>
<h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><p>Object.defineProperties(obj, {xxx:{value:sss}})</p>
<h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3><p>Object.getOwnPropertyDescriptor(obj, key) 读取 configurable 等属性</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createPerson(name, age, job)&#123;</span><br><span class="line">        var o &#x3D; new Object();</span><br><span class="line">        o.name &#x3D; name;</span><br><span class="line">        o.age &#x3D; age;</span><br><span class="line">        o.job &#x3D; job;</span><br><span class="line">        o.sayName &#x3D; function()&#123;</span><br><span class="line">            alert(this.name);</span><br><span class="line">        &#125;;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">var person1 &#x3D; createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br></pre></td></tr></table></figure>

<p>缺点：不能识别对象</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">        this.job &#x3D; job;</span><br><span class="line">        this.sayName &#x3D; function()&#123;</span><br><span class="line">            alert(this.name);</span><br><span class="line">&#125;; &#125;</span><br><span class="line">    var person1 &#x3D; new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br></pre></td></tr></table></figure>

<p>使用 new 会经历 4 个步骤</p>
<ol>
<li>创建一个新的对象</li>
<li>设置原型链</li>
<li>把 this 指向新对象并执行</li>
<li>判断返回值类型，如果是值类型(undexfined 等),返回上面对象;如果是引用类型(this 等),返回引用类型的对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function newFunc (name) &#123;</span><br><span class="line">    var o &#x3D; &#123;&#125;;</span><br><span class="line">    o.__proto__ &#x3D; Person.prototype;&#x2F;&#x2F;绑定Person的原型</span><br><span class="line">    Person.call(o, name);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：MeloGuo</span><br><span class="line">链接：https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;36440948&#x2F;answer&#x2F;213711157</span><br><span class="line">来源：知乎</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>缺点：部分属性不共享，浪费内存</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Person.prototype.name &#x3D; &quot;Nicholas&quot;;</span><br><span class="line">    Person.prototype.age &#x3D; 29;</span><br><span class="line">    Person.prototype.job &#x3D; &quot;Software Engineer&quot;;</span><br><span class="line">    Person.prototype.sayName &#x3D; function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    var person1 &#x3D; new Person();</span><br><span class="line">    person1.sayName();   &#x2F;&#x2F;&quot;Nicholas&quot;</span><br></pre></td></tr></table></figure>

<h4 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h4><p>只要创建一个新函数，就会为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。默认情况下，所有的原型对象都会获得一个 constructor(构造函数)属性，指向原型对象所在函数本身。<br>Person.prototype.constructor === Person</p>
<h4 id="原型与-in"><a href="#原型与-in" class="headerlink" title="原型与 in"></a>原型与 in</h4><p>无论属性存在实例还是原型中，in 都能访问到<br>hasPrototypeProperty 只能访问到实例属性<br>下面方法能判断属性只存在于原型中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function hasPrototypeProperty(object, name)&#123;</span><br><span class="line">        return !object.hasOwnProperty(name) &amp;&amp; (name in object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for-in 能访问到可枚举的,存在于原型或实例中的属性<br>Object.keys 能访问到可枚举的，只存在于实例中的属性<br>Object.getOwnPropertyNames 能访问到枚举或不可枚举的，只存在于实例中的属性</p>
<h4 id="同时设置多个-prototype"><a href="#同时设置多个-prototype" class="headerlink" title="同时设置多个 prototype"></a>同时设置多个 prototype</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Person.prototype &#x3D; &#123;</span><br><span class="line">        name : &quot;Nicholas&quot;,</span><br><span class="line">        age : 29,</span><br><span class="line">        job : &quot;Software Engineer&quot;,</span><br><span class="line">        sayName : function () &#123;&#125;,</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123;</span><br><span class="line">        enumerable: false,</span><br><span class="line">        value: Person</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>constructor 是不可枚举的，不能直接设置 Person.prototype.constructor = Person</p>
<p>缺点：所有值都是共享的，如果是数组等数据，会出现无法单独修改的情况</p>
<h3 id="组合使用原型模式和构造函数模式"><a href="#组合使用原型模式和构造函数模式" class="headerlink" title="组合使用原型模式和构造函数模式"></a>组合使用原型模式和构造函数模式</h3><p>构造函数用于定义实例属性，原型模式用于定义方法和共享属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.job &#x3D; job;</span><br><span class="line">    this.friends &#x3D; [&quot;Shelby&quot;, &quot;Court&quot;];</span><br><span class="line">  &#125;</span><br><span class="line">Person.prototype &#x3D; &#123;</span><br><span class="line">    constructor : Person,</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1 &#x3D; new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">var person2 &#x3D; new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</span><br><span class="line"></span><br><span class="line">person1.friends.push(&quot;Van&quot;);</span><br><span class="line">alert(person1.friends);    &#x2F;&#x2F;&quot;Shelby,Count,Van&quot;</span><br><span class="line">alert(person2.friends);    &#x2F;&#x2F;&quot;Shelby,Count&quot;</span><br><span class="line">alert(person1.friends &#x3D;&#x3D;&#x3D; person2.friends);</span><br><span class="line">alert(person1.sayName &#x3D;&#x3D;&#x3D; person2.sayName);</span><br><span class="line">&#x2F;&#x2F;false</span><br><span class="line">&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line">    if (typeof this.sayName !&#x3D; &quot;function&quot;)&#123;</span><br><span class="line">        Person.prototype.sayName &#x3D; function()&#123;</span><br><span class="line">                alert(this.name);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">        var o &#x3D; new Object();</span><br><span class="line">        o.name &#x3D; name;</span><br><span class="line">        o.age &#x3D; age;</span><br><span class="line">        o.job &#x3D; job;</span><br><span class="line">        o.sayName &#x3D; function()&#123;</span><br><span class="line">            alert(this.name);</span><br><span class="line">        &#125;;</span><br><span class="line">        return o;</span><br><span class="line">&#125;</span><br><span class="line">    var friend &#x3D; new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">    friend.sayName();  &#x2F;&#x2F;&quot;Nicholas&quot;</span><br></pre></td></tr></table></figure>

<p>可以用这种方式扩展原生对象属性，但创建出来的对象和构造函数无关，也不能用 instanceof 确定类型，一般不使用</p>
<h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unction Person(name, age, job)&#123;</span><br><span class="line">        var o &#x3D; new Object();</span><br><span class="line">        var name &#x3D; name;</span><br><span class="line">        ...</span><br><span class="line">        o.sayName &#x3D; function()&#123;</span><br><span class="line">            alert(this.name);</span><br><span class="line">        &#125;;</span><br><span class="line">        return o;</span><br><span class="line">&#125;</span><br><span class="line">    var friend &#x3D; new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">    friend.sayName();  &#x2F;&#x2F;&quot;Nicholas&quot;</span><br></pre></td></tr></table></figure>

<p>属性不会被外部修改，推荐用在安全环境</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">        this.property &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue &#x3D; function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    this.subproperty &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;􏸕􏴫􏽙 SuperType</span><br><span class="line">SubType.prototype &#x3D; new SuperType();</span><br><span class="line">SubType.prototype.getSubValue &#x3D; function ()&#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">  &#125;;</span><br><span class="line">var instance &#x3D; new SubType();</span><br><span class="line">alert(instance.getSuperValue()); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>缺点：引用类型属性共享，没有办法在不影响所有对象实例的情况下给超类型的构造函数传参（超类型的实例属性会被改变）</p>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.colors &#x3D; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line"> function SubType()&#123;</span><br><span class="line">    SuperType.call(this);</span><br><span class="line">&#125;</span><br><span class="line">var instance1 &#x3D; new SubType();</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);    &#x2F;&#x2F;&quot;red,blue,green,black&quot;</span><br><span class="line">var instance2 &#x3D; new SubType();</span><br><span class="line">alert(instance2.colors);    &#x2F;&#x2F;&quot;red,blue,green&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    SuperType.call(this, &quot;Nicholas&quot;);</span><br><span class="line">    this.age &#x3D; 29;</span><br><span class="line">&#125;</span><br><span class="line">var instance &#x3D; new SubType();</span><br><span class="line">alert(instance.name);    &#x2F;&#x2F;&quot;Nicholas&quot;;</span><br><span class="line">alert(instance.age);     &#x2F;&#x2F;29</span><br></pre></td></tr></table></figure>

<p>缺点：无法复用</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.colors &#x3D; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName &#x3D; function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function SubType(name, age)&#123;</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype &#x3D; new SuperType();</span><br><span class="line">SubType.prototype.constructor &#x3D; SubType;</span><br><span class="line">SubType.prototype.sayAge &#x3D; function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;;</span><br><span class="line">var instance1 &#x3D; new SubType(&quot;Nicholas&quot;, 29);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors); &#x2F;&#x2F;&quot;red,blue,green,black&quot;</span><br><span class="line">instance1.sayName(); &#x2F;&#x2F;&quot;Nicholas&quot;;</span><br><span class="line">instance1.sayAge(); &#x2F;&#x2F;29</span><br><span class="line"></span><br><span class="line">var instance2 &#x3D; new SubType(&quot;Greg&quot;, 27);</span><br><span class="line">alert(instance2.colors); &#x2F;&#x2F;&quot;red,blue,green&quot;</span><br><span class="line">instance2.sayName(); &#x2F;&#x2F;&quot;Greg&quot;;</span><br><span class="line">instance2.sayAge(); &#x2F;&#x2F;27</span><br></pre></td></tr></table></figure>

<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>Object.create()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function object(o)&#123;</span><br><span class="line">    function F()&#123;&#125;</span><br><span class="line">    F.prototype &#x3D; o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createAnother(original)&#123;</span><br><span class="line">    var clone&#x3D;object(original);</span><br><span class="line">    clone.sayHi &#x3D; function()&#123;</span><br><span class="line">        alert(&quot;hi&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在原型式继承的基础上添加了自己的方法(sayHi)</p>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function inheritPrototype(subType, superType)&#123;</span><br><span class="line">    var prototype &#x3D; object(superType.prototype);</span><br><span class="line">    prototype.constructor &#x3D; subType;</span><br><span class="line">    subType.prototype &#x3D; prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.colors &#x3D; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName &#x3D; function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function SubType(name, age)&#123;</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line">SubType.prototype.sayAge &#x3D; function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只调用了一次 SuperType 构造函数，并且在 SubType 的 prototype 上没有多余的属性，可以说是目前能选择的最佳继承方案了</p>
]]></content>
      <tags>
        <tag>javascript高级笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>函数表达式</title>
    <url>/my-notes/2019/06/14/js%E9%AB%98%E7%BA%A7/7.%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="函数闭包"><a href="#函数闭包" class="headerlink" title="函数闭包"></a>函数闭包</h2><p><code>闭包</code>是指有权访问另一个函数作用域中的变量的函数</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function assignHandler()&#123;</span><br><span class="line">        var element &#x3D; document.getElementById(&quot;someElement&quot;);</span><br><span class="line">        element.onclick &#x3D; function()&#123;</span><br><span class="line">            alert(element.id);</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>↓</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function assignHandler()&#123;</span><br><span class="line">var element &#x3D; document.getElementById(&quot;someElement&quot;); var id &#x3D; element.id;</span><br><span class="line">        element.onclick &#x3D; function()&#123;</span><br><span class="line">alert(id);</span><br><span class="line">&#125;;</span><br><span class="line">        element &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>把 element 设为 null,可以借出对 dom 对象的引用，回收其占用的内存</p>
<h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>任何在函数中定义的变量，都可以叫做<code>私有变量</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(num1, num2)&#123;</span><br><span class="line">        var sum &#x3D; num1 + num2;</span><br><span class="line">        return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把有权访问私有变量和私有函数的公有方法称为<code>特权方法</code></p>
<ol>
<li>在构造函数中定义特权方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function MyObject()&#123;</span><br><span class="line">    var privateVariable &#x3D; 10;</span><br><span class="line">    function privateFunction()&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    this.publicMethod &#x3D; function ()&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        return privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用私有和特权成员，隐藏那些不应该被直接修改的数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.getName &#x3D; function()&#123;</span><br><span class="line">        return name;</span><br><span class="line">&#125;;</span><br><span class="line">    this.setName &#x3D; function (value) &#123;</span><br><span class="line">        name &#x3D; value;</span><br><span class="line">&#125;; &#125;</span><br><span class="line">var person &#x3D; new Person(&quot;Nicholas&quot;);</span><br><span class="line">alert(person.getName());   &#x2F;&#x2F;&quot;Nicholas&quot;</span><br><span class="line">person.setName(&quot;Greg&quot;);</span><br><span class="line">alert(person.getName());   &#x2F;&#x2F;&quot;Greg&quot;</span><br></pre></td></tr></table></figure>

<p>缺点：构造函数会给每个实例创建相同的方法，浪费</p>
<h3 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">        var name &#x3D; &quot;&quot;;</span><br><span class="line">        Person &#x3D; function(value)&#123;</span><br><span class="line">            name &#x3D; value;</span><br><span class="line">        &#125;;</span><br><span class="line">        Person.prototype.getName &#x3D; function()&#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;;</span><br><span class="line">        Person.prototype.setName &#x3D; function (value)&#123;</span><br><span class="line">            name &#x3D; value;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">var person1 &#x3D; new Person(&quot;Nicholas&quot;);</span><br><span class="line">alert(person1.getName()); &#x2F;&#x2F;&quot;Nicholas&quot;</span><br><span class="line">person1.setName(&quot;Greg&quot;);</span><br><span class="line">alert(person1.getName()); &#x2F;&#x2F;&quot;Greg&quot;</span><br><span class="line">var person2 &#x3D; new Person(&quot;Michael&quot;);</span><br><span class="line">alert(person1.getName()); &#x2F;&#x2F;&quot;Michael&quot;</span><br><span class="line">alert(person2.getName()); &#x2F;&#x2F;&quot;Michael&quot;</span><br></pre></td></tr></table></figure>

<p>定义全局构造函数，但每个实例没有自己的私有变量</p>
<h3 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h3><p>模块模式通过为单例添加私有变量和特权方法来使其增强</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var singleton &#x3D; function()&#123;</span><br><span class="line">    var privateVariable &#x3D; 10;</span><br><span class="line">    function privateFunction()&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        publicProperty: true,</span><br><span class="line">        publicMethod : function()&#123;</span><br><span class="line">            privateVariable++;</span><br><span class="line">            return privateFunction();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript高级笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>BOM</title>
    <url>/my-notes/2019/06/14/js%E9%AB%98%E7%BA%A7/8.BOM/</url>
    <content><![CDATA[<h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><p>即使 js 访问浏览器的接口，也是 ESCMScript 的全局 Global 对象</p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var age &#x3D; 29;</span><br><span class="line">function sayAge()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br><span class="line">alert(window.age); &#x2F;&#x2F;29</span><br><span class="line">sayAge(); &#x2F;&#x2F;29</span><br><span class="line"> window.sayAge(); &#x2F;&#x2F;29</span><br></pre></td></tr></table></figure>

<p>使用 var 添加的全局属性的 configurable 默认为 false, 所有不能<code>delete window.age</code>（无效）</p>
<h3 id="弹出窗口"><a href="#弹出窗口" class="headerlink" title="弹出窗口"></a>弹出窗口</h3><p>检测弹出窗是否被屏蔽</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var blocked &#x3D; false;</span><br><span class="line">try &#123;</span><br><span class="line">        var wroxWin &#x3D; window.open(&quot;http:&#x2F;&#x2F;www.wrox.com&quot;, &quot;_blank&quot;);</span><br><span class="line">        if (wroxWin &#x3D;&#x3D; null)&#123;</span><br><span class="line">            blocked &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (ex)&#123;</span><br><span class="line">    blocked &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">if (blocked)&#123;</span><br><span class="line">    alert(&quot;The popup was blocked!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h2><h3 id="检测插件"><a href="#检测插件" class="headerlink" title="检测插件"></a>检测插件</h3><p><code>navigator.plugins</code></p>
<ul>
<li>name</li>
<li>description</li>
<li>filename</li>
<li>length 插件所处理的 MIME 类型数量</li>
</ul>
]]></content>
      <tags>
        <tag>javascript高级笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>初始流程</title>
    <url>/my-notes/2020/09/07/react/1.%E5%88%9D%E5%A7%8B%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>本次阅读会无视<em>DEV</em>等没有运行到的分支条件</p>
<p>react 的渲染主要由 react-dom 完成，首先从 ReactDOM.render 开始</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactDOM = &#123;</span><br><span class="line">  ...</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">element, container, callback</span>) </span>&#123;</span><br><span class="line">    ... <span class="comment">// 一些验证参数合法的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> legacyRenderSubtreeIntoContainer(<span class="literal">null</span>, element, container, <span class="literal">false</span>, callback);</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后看<code>legacyRenderSubtreeIntoContainer</code></p>
<p>参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    parentComponent: ?React$Component&lt;any, any&gt;, <span class="comment">// 父组件</span></span><br><span class="line">    children: ReactNodeList, <span class="comment">// 已经被处理的react node</span></span><br><span class="line">    container: DOMContainer, <span class="comment">// 挂载dom元素</span></span><br><span class="line">    forceHydrate: boolean,</span><br><span class="line">    callback: ?<span class="built_in">Function</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次进来，root 不存在</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> root: _ReactSyncRoot = (container._reactRootContainer: any);</span><br><span class="line">    <span class="keyword">let</span> fiberRoot;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="comment">// Initial mount</span></span><br><span class="line">        root = container._reactRootContainer = legacyCreateRootFromDOMContainer(</span><br><span class="line">            container,</span><br><span class="line">            forceHydrate,</span><br><span class="line">        );</span><br><span class="line">        fiberRoot = root._internalRoot; <span class="comment">// FiberNode</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> originalCallback = callback;</span><br><span class="line">            callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> instance = getPublicRootInstance(fiberRoot);</span><br><span class="line">                originalCallback.call(instance);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Initial mount should not be batched.</span></span><br><span class="line">        unbatchedUpdates(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">return</span> getPublicRootInstance(fiberRoot);</span><br></pre></td></tr></table></figure>

<p><code>legacyCreateRootFromDOMContainer</code>的作用是删除 container 中已经存在的子节点，然后返回<code>new ReactSyncRoot(container, LegacyRoot, shouldHydrate)</code> // dom, 0, false</p>
<p>之后是创建 fiber,见<code>fiber.md</code>,然后开始第一次的 mount</p>
<p><code>unbatchedUpdates</code>里主要是改变执行状态，然后就执行回调函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非批量修改， 第一次渲染会执行</span></span><br><span class="line">executionContext = NoContext; <span class="comment">// 初始为0（二进制）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">unbatchedUpdates</span>&lt;<span class="title">A</span>, <span class="title">R</span>&gt;(<span class="params">fn: (a: A) =&gt; R, a: A</span>): <span class="title">R</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> prevExecutionContext = executionContext; <span class="comment">// 记住状态</span></span><br><span class="line">    executionContext &amp;= ~BatchedContext; <span class="comment">// 删除BatchedContext状态</span></span><br><span class="line">    executionContext |= LegacyUnbatchedContext; <span class="comment">// 添加LegacyUnbatchedContext状态</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fn(a);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        executionContext = prevExecutionContext; <span class="comment">// 归还状态</span></span><br><span class="line">        <span class="keyword">if</span> (executionContext === NoContext) &#123;</span><br><span class="line">            <span class="comment">// Flush the immediate callbacks that were scheduled during this batch</span></span><br><span class="line">            flushSyncCallbackQueue(); <span class="comment">// 刷新同步回调队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算时间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    element: ReactNodeList, <span class="regexp">//</span> children</span></span></span><br><span class="line"><span class="function"><span class="params">    container: OpaqueRoot, <span class="regexp">//</span> fiber</span></span></span><br><span class="line"><span class="function"><span class="params">    parentComponent: ?React$Component&lt;any, any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    callback: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ExpirationTime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> current = container.current; <span class="comment">// FiberNode</span></span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    <span class="comment">// 在10ms内获取到的是同一数值</span></span><br><span class="line">    <span class="keyword">const</span> currentTime = requestCurrentTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> suspenseConfig = requestCurrentSuspenseConfig(); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> expirationTime = computeExpirationForFiber(currentTime, current, suspenseConfig);</span><br><span class="line">    <span class="keyword">return</span> updateContainerAtExpirationTime(</span><br><span class="line">        element,</span><br><span class="line">        container,</span><br><span class="line">        parentComponent,</span><br><span class="line">        expirationTime,</span><br><span class="line">        suspenseConfig,</span><br><span class="line">        callback,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化 container.context，这里暂时不细看，第一次得到的是{}</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateContainerAtExpirationTime</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    element: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">    container: OpaqueRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">    parentComponent: ?React$Component&lt;any, any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">    suspenseConfig: null | SuspenseConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">    callback: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> current = container.current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> context = getContextForSubtree(parentComponent); <span class="comment">// 第一次是 &#123;&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (container.context === <span class="literal">null</span>) &#123;</span><br><span class="line">        container.context = context;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        container.pendingContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> scheduleRootUpdate(current, element, expirationTime, suspenseConfig, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="scheduleRootUpdate"><a href="#scheduleRootUpdate" class="headerlink" title="scheduleRootUpdate"></a>scheduleRootUpdate</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleRootUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">  suspenseConfig: null | SuspenseConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> update = createUpdate(expirationTime, suspenseConfig); <span class="comment">// 返回一个update对象</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Caution: React DevTools currently depends on this property</span></span><br><span class="line">  <span class="comment">// being called &quot;element&quot;.</span></span><br><span class="line">  update.payload = &#123;element&#125;; <span class="comment">// element是react组件 &#123;type:xxxx...&#125;</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  enqueueUpdate(current, update); <span class="comment">// 主要是fiber(current).updateQueue数据变动（初始化）,先不细看</span></span><br><span class="line">  scheduleWork(current, expirationTime); <span class="comment">// 完成了到DidMount的生命周期</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> expirationTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是<code>scheduleWork</code>即<code>scheduleUpdateOnFiber</code></p>
<p>见 schedule.md</p>
<h2 id="renderRoot"><a href="#renderRoot" class="headerlink" title="renderRoot"></a>renderRoot</h2><p>构建 fiber 树和 dom 树，互相对应为参数，能互相找到，并执行了渲染前的生命周期</p>
<p>见 renderRoot.md</p>
<p>最后</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> commitRoot.bind(<span class="literal">null</span>, root);</span><br></pre></td></tr></table></figure>

<h2 id="commitRoot"><a href="#commitRoot" class="headerlink" title="commitRoot"></a>commitRoot</h2><p>见 commitRoot.md</p>
]]></content>
      <tags>
        <tag>react源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>completeWork</title>
    <url>/my-notes/2020/09/11/react/context/</url>
    <content><![CDATA[<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="createContext"><a href="#createContext" class="headerlink" title="createContext"></a>createContext</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createContext</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    defaultValue: T,</span></span></span><br><span class="line"><span class="function"><span class="params">    calculateChangedBits: ?(a: T, b: T) =&gt; number,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ReactContext</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (calculateChangedBits === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        calculateChangedBits = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">            warningWithoutStack(</span><br><span class="line">                calculateChangedBits === <span class="literal">null</span> || <span class="keyword">typeof</span> calculateChangedBits === <span class="string">&#x27;function&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;createContext: Expected the optional second argument to be a &#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;function. Instead received: %s&#x27;</span>,</span><br><span class="line">                calculateChangedBits,</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> context: ReactContext&lt;T&gt; = &#123;</span><br><span class="line">        $$typeof: REACT_CONTEXT_TYPE,</span><br><span class="line">        _calculateChangedBits: calculateChangedBits,</span><br><span class="line">        <span class="comment">// As a workaround to support multiple concurrent renderers, we categorize</span></span><br><span class="line">        <span class="comment">// some renderers as primary and others as secondary. We only expect</span></span><br><span class="line">        <span class="comment">// there to be two concurrent renderers at most: React Native (primary) and</span></span><br><span class="line">        <span class="comment">// Fabric (secondary); React DOM (primary) and React ART (secondary).</span></span><br><span class="line">        <span class="comment">// Secondary renderers store their context values on separate fields.</span></span><br><span class="line">        _currentValue: defaultValue,</span><br><span class="line">        _currentValue2: defaultValue,</span><br><span class="line">        <span class="comment">// Used to track how many concurrent renderers this context currently</span></span><br><span class="line">        <span class="comment">// supports within in a single renderer. Such as parallel server rendering.</span></span><br><span class="line">        _threadCount: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// These are circular</span></span><br><span class="line">        Provider: (<span class="literal">null</span>: any),</span><br><span class="line">        Consumer: (<span class="literal">null</span>: any),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    context.Provider = &#123;</span><br><span class="line">        $$typeof: REACT_PROVIDER_TYPE,</span><br><span class="line">        _context: context,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> hasWarnedAboutUsingNestedContextConsumers = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> hasWarnedAboutUsingConsumerProvider = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context.Consumer = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跟新数据"><a href="#跟新数据" class="headerlink" title="跟新数据"></a>跟新数据</h2><h3 id="updateContextProvider"><a href="#updateContextProvider" class="headerlink" title="updateContextProvider"></a>updateContextProvider</h3><p>处理 fiber 时</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// case ContextProvider:</span></span><br><span class="line"><span class="comment">//      return updateContextProvider(current, workInProgress, renderExpirationTime);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateContextProvider</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    renderExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> providerType: ReactProviderType&lt;any&gt; = workInProgress.type;</span><br><span class="line">    <span class="keyword">const</span> context: ReactContext&lt;any&gt; = providerType._context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newProps = workInProgress.pendingProps;</span><br><span class="line">    <span class="keyword">const</span> oldProps = workInProgress.memoizedProps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newValue = newProps.value;</span><br><span class="line"></span><br><span class="line">    pushProvider(workInProgress, newValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldProps !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> oldValue = oldProps.value;</span><br><span class="line">        <span class="keyword">const</span> changedBits = calculateChangedBits(context, newValue, oldValue);</span><br><span class="line">        <span class="keyword">if</span> (changedBits === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// No change. Bailout early if children are the same.</span></span><br><span class="line">            <span class="keyword">if</span> (oldProps.children === newProps.children &amp;&amp; !hasLegacyContextChanged()) &#123;</span><br><span class="line">                <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The context value changed. Search for matching consumers and schedule</span></span><br><span class="line">            <span class="comment">// them to update.</span></span><br><span class="line">            propagateContextChange(workInProgress, context, changedBits, renderExpirationTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newChildren = newProps.children;</span><br><span class="line">    reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);</span><br><span class="line">    <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pushProvider"><a href="#pushProvider" class="headerlink" title="pushProvider"></a>pushProvider</h3><p>context._currentValue = nextValue;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushProvider</span>&lt;<span class="title">T</span>&gt;(<span class="params">providerFiber: Fiber, nextValue: T</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context: ReactContext&lt;T&gt; = providerFiber.type._context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isPrimaryRenderer) &#123;</span><br><span class="line">        push(valueCursor, context._currentValue, providerFiber);</span><br><span class="line"></span><br><span class="line">        context._currentValue = nextValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        push(valueCursor, context._currentValue2, providerFiber);</span><br><span class="line"></span><br><span class="line">        context._currentValue2 = nextValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="propagateContextChange"><a href="#propagateContextChange" class="headerlink" title="propagateContextChange"></a>propagateContextChange</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">propagateContextChange</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    context: ReactContext&lt;mixed&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    changedBits: number,</span></span></span><br><span class="line"><span class="function"><span class="params">    renderExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fiber = workInProgress.child;</span><br><span class="line">    <span class="keyword">if</span> (fiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Set the return pointer of the child to the work-in-progress fiber.</span></span><br><span class="line">        fiber.return = workInProgress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextFiber;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Visit this fiber.</span></span><br><span class="line">        <span class="keyword">const</span> list = fiber.contextDependencies;</span><br><span class="line">        <span class="keyword">if</span> (list !== <span class="literal">null</span>) &#123;</span><br><span class="line">            nextFiber = fiber.child;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> dependency = list.first;</span><br><span class="line">            <span class="keyword">while</span> (dependency !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Check if the context matches.</span></span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    dependency.context === context &amp;&amp;</span><br><span class="line">                    (dependency.observedBits &amp; changedBits) !== <span class="number">0</span></span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// Match! Schedule an update on this fiber.</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (fiber.tag === ClassComponent) &#123;</span><br><span class="line">                        <span class="comment">// Schedule a force update on the work-in-progress.</span></span><br><span class="line">                        <span class="keyword">const</span> update = createUpdate(renderExpirationTime, <span class="literal">null</span>);</span><br><span class="line">                        update.tag = ForceUpdate;</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> Because we don&#x27;t have a work-in-progress, this will add the</span></span><br><span class="line">                        <span class="comment">// update to the current fiber, too, which means it will persist even if</span></span><br><span class="line">                        <span class="comment">// this render is thrown away. Since it&#x27;s a race condition, not sure it&#x27;s</span></span><br><span class="line">                        <span class="comment">// worth fixing.</span></span><br><span class="line">                        enqueueUpdate(fiber, update);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (fiber.expirationTime &lt; renderExpirationTime) &#123;</span><br><span class="line">                        fiber.expirationTime = renderExpirationTime;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">let</span> alternate = fiber.alternate;</span><br><span class="line">                    <span class="keyword">if</span> (alternate !== <span class="literal">null</span> &amp;&amp; alternate.expirationTime &lt; renderExpirationTime) &#123;</span><br><span class="line">                        alternate.expirationTime = renderExpirationTime;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    scheduleWorkOnParentPath(fiber.return, renderExpirationTime);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Mark the expiration time on the list, too.</span></span><br><span class="line">                    <span class="keyword">if</span> (list.expirationTime &lt; renderExpirationTime) &#123;</span><br><span class="line">                        list.expirationTime = renderExpirationTime;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Since we already found a match, we can stop traversing the</span></span><br><span class="line">                    <span class="comment">// dependency list.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dependency = dependency.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === ContextProvider) &#123;</span><br><span class="line">            <span class="comment">// Don&#x27;t scan deeper if this is a matching provider</span></span><br><span class="line">            nextFiber = fiber.type === workInProgress.type ? <span class="literal">null</span> : fiber.child;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enableSuspenseServerRenderer &amp;&amp; fiber.tag === DehydratedSuspenseComponent) &#123;</span><br><span class="line">            <span class="comment">// If a dehydrated suspense component is in this subtree, we don&#x27;t know</span></span><br><span class="line">            <span class="comment">// if it will have any context consumers in it. The best we can do is</span></span><br><span class="line">            <span class="comment">// mark it as having updates on its children.</span></span><br><span class="line">            <span class="keyword">if</span> (fiber.expirationTime &lt; renderExpirationTime) &#123;</span><br><span class="line">                fiber.expirationTime = renderExpirationTime;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> alternate = fiber.alternate;</span><br><span class="line">            <span class="keyword">if</span> (alternate !== <span class="literal">null</span> &amp;&amp; alternate.expirationTime &lt; renderExpirationTime) &#123;</span><br><span class="line">                alternate.expirationTime = renderExpirationTime;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// This is intentionally passing this fiber as the parent</span></span><br><span class="line">            <span class="comment">// because we want to schedule this fiber as having work</span></span><br><span class="line">            <span class="comment">// on its children. We&#x27;ll use the childExpirationTime on</span></span><br><span class="line">            <span class="comment">// this fiber to indicate that a context has changed.</span></span><br><span class="line">            scheduleWorkOnParentPath(fiber, renderExpirationTime);</span><br><span class="line">            nextFiber = fiber.sibling;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Traverse down.</span></span><br><span class="line">            nextFiber = fiber.child;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Set the return pointer of the child to the work-in-progress fiber.</span></span><br><span class="line">            nextFiber.return = fiber;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No child. Traverse to next sibling.</span></span><br><span class="line">            nextFiber = fiber;</span><br><span class="line">            <span class="keyword">while</span> (nextFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nextFiber === workInProgress) &#123;</span><br><span class="line">                    <span class="comment">// We&#x27;re back to the root of this subtree. Exit.</span></span><br><span class="line">                    nextFiber = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">let</span> sibling = nextFiber.sibling;</span><br><span class="line">                <span class="keyword">if</span> (sibling !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Set the return pointer of the sibling to the work-in-progress fiber.</span></span><br><span class="line">                    sibling.return = nextFiber.return;</span><br><span class="line">                    nextFiber = sibling;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// No more siblings. Traverse up.</span></span><br><span class="line">                nextFiber = nextFiber.return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fiber = nextFiber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p>在 function 组件中</p>
<h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useContext</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Context: ReactContext&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    unstable_observedBits: number | boolean | void,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">    <span class="keyword">return</span> dispatcher.useContext(Context, unstable_observedBits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>useContext 是只读的，用于获取 context 数据</p>
<p>在 class 组件中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> contextType === <span class="string">&#x27;object&#x27;</span> &amp;&amp; contextType !== <span class="literal">null</span>) &#123;</span><br><span class="line">    context = readContext((contextType: any));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ctor即class定义</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> ctor(props, context);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">props, context, updater</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.props = props;</span><br><span class="line">    <span class="built_in">this</span>.context = context;</span><br><span class="line">    <span class="comment">// If a component has string refs, we will assign a different object later.</span></span><br><span class="line">    <span class="built_in">this</span>.refs = emptyObject;</span><br><span class="line">    <span class="comment">// We initialize the default updater but the real one gets injected by the</span></span><br><span class="line">    <span class="comment">// renderer.</span></span><br><span class="line">    <span class="built_in">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="readContext"><a href="#readContext" class="headerlink" title="readContext"></a>readContext</h3><p>读取 <code>context._currentValue</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">readContext</span>&lt;<span class="title">T</span>&gt;(<span class="params">context: ReactContext&lt;T&gt;, observedBits: void | number | boolean</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastContextWithAllBitsObserved === context) &#123;</span><br><span class="line">        <span class="comment">// Nothing to do. We already observe everything in this context.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (observedBits === <span class="literal">false</span> || observedBits === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Do not observe any updates.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> resolvedObservedBits; <span class="comment">// Avoid deopting on observable arguments or heterogeneous types.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> observedBits !== <span class="string">&#x27;number&#x27;</span> || observedBits === MAX_SIGNED_31_BIT_INT) &#123;</span><br><span class="line">            <span class="comment">// Observe all updates.</span></span><br><span class="line">            lastContextWithAllBitsObserved = ((context: any): ReactContext&lt;mixed&gt;);</span><br><span class="line">            resolvedObservedBits = MAX_SIGNED_31_BIT_INT;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolvedObservedBits = observedBits;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> contextItem = &#123;</span><br><span class="line">            context: ((context: any): ReactContext&lt;mixed&gt;),</span><br><span class="line">            observedBits: resolvedObservedBits,</span><br><span class="line">            next: <span class="literal">null</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lastContextDependency === <span class="literal">null</span>) &#123;</span><br><span class="line">            invariant(</span><br><span class="line">                currentlyRenderingFiber !== <span class="literal">null</span>,</span><br><span class="line">                <span class="string">&#x27;Context can only be read while React is rendering. &#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;In classes, you can read it in the render method or getDerivedStateFromProps. &#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;In function components, you can read it directly in the function body, but not &#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;inside Hooks like useReducer() or useMemo().&#x27;</span>,</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This is the first dependency for this component. Create a new list.</span></span><br><span class="line">            lastContextDependency = contextItem;</span><br><span class="line">            currentlyRenderingFiber.contextDependencies = &#123;</span><br><span class="line">                first: contextItem,</span><br><span class="line">                expirationTime: NoWork,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Append a new context item.</span></span><br><span class="line">            lastContextDependency = lastContextDependency.next = contextItem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isPrimaryRenderer ? context._currentValue : context._currentValue2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Context-Consumer"><a href="#Context-Consumer" class="headerlink" title="Context.Consumer"></a>Context.Consumer</h3><p>还是执行 readContext 获取，然后 child(value)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateContextConsumer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    renderExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context: ReactContext&lt;any&gt; = workInProgress.type;</span><br><span class="line">    <span class="comment">// The logic below for Context differs depending on PROD or DEV mode. In</span></span><br><span class="line">    <span class="comment">// DEV mode, we create a separate object for Context.Consumer that acts</span></span><br><span class="line">    <span class="comment">// like a proxy to Context. This proxy object adds unnecessary code in PROD</span></span><br><span class="line">    <span class="comment">// so we use the old behaviour (Context.Consumer references Context) to</span></span><br><span class="line">    <span class="comment">// reduce size and overhead. The separate object references context via</span></span><br><span class="line">    <span class="comment">// a property called &quot;_context&quot;, which also gives us the ability to check</span></span><br><span class="line">    <span class="comment">// in DEV mode if this property exists or not and warn if it does not.</span></span><br><span class="line">    <span class="keyword">const</span> newProps = workInProgress.pendingProps;</span><br><span class="line">    <span class="keyword">const</span> render = newProps.children;</span><br><span class="line"></span><br><span class="line">    prepareToReadContext(workInProgress, renderExpirationTime);</span><br><span class="line">    <span class="keyword">const</span> newValue = readContext(context, newProps.unstable_observedBits);</span><br><span class="line">    <span class="keyword">let</span> newChildren;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        ReactCurrentOwner.current = workInProgress;</span><br><span class="line">        setCurrentPhase(<span class="string">&#x27;render&#x27;</span>);</span><br><span class="line">        newChildren = render(newValue);</span><br><span class="line">        setCurrentPhase(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newChildren = render(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// React DevTools reads this flag.</span></span><br><span class="line">    workInProgress.effectTag |= PerformedWork;</span><br><span class="line">    reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);</span><br><span class="line">    <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>createElement(dom)</title>
    <url>/my-notes/2020/09/10/react/createElement(dom)/</url>
    <content><![CDATA[<h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    type: string,</span></span></span><br><span class="line"><span class="function"><span class="params">    props: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">    rootContainerElement: Element | Document,</span></span></span><br><span class="line"><span class="function"><span class="params">    parentNamespace: string,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> isCustomComponentTag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We create tags in the namespace of their parent container, except HTML</span></span><br><span class="line">    <span class="comment">// tags get no namespace.</span></span><br><span class="line">    <span class="comment">// 所属节点(应该就是父节点)</span></span><br><span class="line">    <span class="keyword">const</span> ownerDocument: Document = getOwnerDocumentFromRootContainer(rootContainerElement);</span><br><span class="line">    <span class="keyword">let</span> domElement: Element;</span><br><span class="line">    <span class="keyword">let</span> namespaceURI = parentNamespace;</span><br><span class="line">    <span class="keyword">if</span> (namespaceURI === HTML_NAMESPACE) &#123;</span><br><span class="line">        <span class="comment">// svg/math/html</span></span><br><span class="line">        namespaceURI = getIntrinsicNamespace(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// html</span></span><br><span class="line">    <span class="keyword">if</span> (namespaceURI === HTML_NAMESPACE) &#123;</span><br><span class="line">        <span class="comment">// script 标签</span></span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">&#x27;script&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// Create the script via .innerHTML so its &quot;parser-inserted&quot; flag is</span></span><br><span class="line">            <span class="comment">// set to true and it does not execute</span></span><br><span class="line">            <span class="keyword">const</span> div = ownerDocument.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">            div.innerHTML = <span class="string">&#x27;&lt;script&gt;&lt;&#x27;</span> + <span class="string">&#x27;/script&gt;&#x27;</span>; <span class="comment">// eslint-disable-line</span></span><br><span class="line">            <span class="comment">// This is guaranteed to yield a script element.</span></span><br><span class="line">            <span class="keyword">const</span> firstChild = ((div.firstChild: any): HTMLScriptElement);</span><br><span class="line">            domElement = div.removeChild(firstChild);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> props.is === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// $FlowIssue `createElement` should be updated for Web Components</span></span><br><span class="line">            domElement = ownerDocument.createElement(type, &#123;<span class="attr">is</span>: props.is&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.</span></span><br><span class="line">            <span class="comment">// See discussion in https://github.com/facebook/react/pull/6896</span></span><br><span class="line">            <span class="comment">// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240</span></span><br><span class="line">            domElement = ownerDocument.createElement(type);</span><br><span class="line">            <span class="comment">// Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`</span></span><br><span class="line">            <span class="comment">// attributes on `select`s needs to be added before `option`s are inserted.</span></span><br><span class="line">            <span class="comment">// This prevents:</span></span><br><span class="line">            <span class="comment">// - a bug where the `select` does not scroll to the correct option because singular</span></span><br><span class="line">            <span class="comment">//  `select` elements automatically pick the first item #13222</span></span><br><span class="line">            <span class="comment">// - a bug where the `select` set the first item as selected despite the `size` attribute #14239</span></span><br><span class="line">            <span class="comment">// See https://github.com/facebook/react/issues/13222</span></span><br><span class="line">            <span class="comment">// and https://github.com/facebook/react/issues/14239</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// select标签</span></span><br><span class="line">            <span class="keyword">if</span> (type === <span class="string">&#x27;select&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> node = ((domElement: any): HTMLSelectElement);</span><br><span class="line">                <span class="keyword">if</span> (props.multiple) &#123;</span><br><span class="line">                    node.multiple = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (props.size) &#123;</span><br><span class="line">                    <span class="comment">// Setting a size greater than 1 causes a select to behave like `multiple=true`, where</span></span><br><span class="line">                    <span class="comment">// it is possible that no option is selected.</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// This is only necessary when a select in &quot;single selection mode&quot;.</span></span><br><span class="line">                    node.size = props.size;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        domElement = ownerDocument.createElementNS(namespaceURI, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> domElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>createElement(react element)</title>
    <url>/my-notes/2020/09/10/react/createElement(react%20element)/</url>
    <content><![CDATA[<h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create and return a new ReactElement of the given type.</span></span><br><span class="line"><span class="comment"> * See https://reactjs.org/docs/react-api.html#createelement</span></span><br><span class="line"><span class="comment"> * type: 标签类型，如div,p等</span></span><br><span class="line"><span class="comment"> * config[object]: 属性，如className,onClick等，必带__self和__source</span></span><br><span class="line"><span class="comment"> * children:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, config, children</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> propName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reserved names are extracted</span></span><br><span class="line">    <span class="keyword">const</span> props = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> key = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> ref = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> source = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasValidRef(config)) &#123;</span><br><span class="line">            ref = config.ref;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasValidKey(config)) &#123;</span><br><span class="line">            key = <span class="string">&#x27;&#x27;</span> + config.key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        self = config.__self === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__self;</span><br><span class="line">        source = config.__source === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__source;</span><br><span class="line">        <span class="comment">// Remaining properties are added to a new props object</span></span><br><span class="line">        <span class="comment">// 解析props</span></span><br><span class="line">        <span class="keyword">for</span> (propName <span class="keyword">in</span> config) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) &#123;</span><br><span class="line">                props[propName] = config[propName];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Children can be more than one argument, and those are transferred onto</span></span><br><span class="line">    <span class="comment">// the newly allocated props object.</span></span><br><span class="line">    <span class="comment">// 解析children</span></span><br><span class="line">    <span class="keyword">const</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">        props.children = children;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> childArray = <span class="built_in">Array</span>(childrenLength);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123;</span><br><span class="line">            childArray[i] = <span class="built_in">arguments</span>[i + <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        props.children = childArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Resolve default props</span></span><br><span class="line">    <span class="keyword">if</span> (type &amp;&amp; type.defaultProps) &#123;</span><br><span class="line">        <span class="keyword">const</span> defaultProps = type.defaultProps;</span><br><span class="line">        <span class="keyword">for</span> (propName <span class="keyword">in</span> defaultProps) &#123;</span><br><span class="line">            <span class="keyword">if</span> (props[propName] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                props[propName] = defaultProps[propName];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key || ref) &#123;</span><br><span class="line">            <span class="keyword">const</span> displayName =</span><br><span class="line">                <span class="keyword">typeof</span> type === <span class="string">&#x27;function&#x27;</span> ? type.displayName || type.name || <span class="string">&#x27;Unknown&#x27;</span> : type;</span><br><span class="line">            <span class="keyword">if</span> (key) &#123;</span><br><span class="line">                defineKeyPropWarningGetter(props, displayName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ref) &#123;</span><br><span class="line">                defineRefPropWarningGetter(props, displayName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ReactElement"><a href="#ReactElement" class="headerlink" title="ReactElement"></a>ReactElement</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory method to create a new React element. This no longer adheres to</span></span><br><span class="line"><span class="comment"> * the class pattern, so do not use new to call it. Also, no instanceof check</span></span><br><span class="line"><span class="comment"> * will work. Instead test $$typeof field against Symbol.for(&#x27;react.element&#x27;) to check</span></span><br><span class="line"><span class="comment"> * if something is a React Element.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">type</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">props</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">key</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string|object&#125;</span> <span class="variable">ref</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">owner</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>self A *temporary* helper to detect places where `this` is</span></span><br><span class="line"><span class="comment"> * different from the `owner` when React.createElement is called, so that we</span></span><br><span class="line"><span class="comment"> * can warn. We want to get rid of owner and replace string `ref`s with arrow</span></span><br><span class="line"><span class="comment"> * functions, and as long as `this` and owner are the same, there will be no</span></span><br><span class="line"><span class="comment"> * change in behavior.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>source An annotation object (added by a transpiler or otherwise)</span></span><br><span class="line"><span class="comment"> * indicating filename, line number, and/or other information.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@internal</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> ReactElement = <span class="function"><span class="keyword">function</span> (<span class="params">type, key, ref, self, source, owner, props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> element = &#123;</span><br><span class="line">        <span class="comment">// This tag allows us to uniquely identify this as a React Element</span></span><br><span class="line">        $$typeof: REACT_ELEMENT_TYPE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Built-in properties that belong on the element</span></span><br><span class="line">        type: type,</span><br><span class="line">        key: key,</span><br><span class="line">        ref: ref,</span><br><span class="line">        props: props,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Record the component responsible for creating this element.</span></span><br><span class="line">        _owner: owner,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>fiber</title>
    <url>/my-notes/2020/09/08/react/fiber/</url>
    <content><![CDATA[<p>从 <code>ReactSyncRoot</code>开始</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dom, 0, false</span></span><br><span class="line"><span class="keyword">const</span> root = createContainer(container, tag, hydrate); <span class="comment">// FiberRootNode</span></span><br><span class="line"><span class="built_in">this</span>._internalRoot = root;</span><br></pre></td></tr></table></figure>

<p><code>createContainer</code>在<code>react-reconciler/inline.dom</code>,引用的<code>./src/ReactFiberReconciler</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    containerInfo: Container,</span></span></span><br><span class="line"><span class="function"><span class="params">    tag: RootTag,</span></span></span><br><span class="line"><span class="function"><span class="params">    hydrate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">OpaqueRoot</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建fiberroot</span></span><br><span class="line">    <span class="keyword">return</span> createFiberRoot(containerInfo, tag, hydrate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createFiberRoot</span>(<span class="params">containerInfo: any, tag: RootTag, hydrate: boolean</span>): <span class="title">FiberRoot</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建fiber对象</span></span><br><span class="line">    <span class="keyword">const</span> root: FiberRoot = (<span class="keyword">new</span> FiberRootNode(containerInfo, tag, hydrate): any);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cyclic construction. This cheats the type system right now because</span></span><br><span class="line">    <span class="comment">// stateNode is any.</span></span><br><span class="line">    <span class="keyword">const</span> uninitializedFiber = createHostRootFiber(tag);</span><br><span class="line">    root.current = uninitializedFiber;</span><br><span class="line">    uninitializedFiber.stateNode = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建<code>FiberRoot</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在其他文件定义的常量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoWork = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> noTimeout = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面有注释</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FiberRootNode</span>(<span class="params">containerInfo, tag, hydrate</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.tag = tag;</span><br><span class="line">    <span class="built_in">this</span>.current = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.containerInfo = containerInfo;</span><br><span class="line">    <span class="built_in">this</span>.pendingChildren = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.pingCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.finishedExpirationTime = NoWork;</span><br><span class="line">    <span class="built_in">this</span>.finishedWork = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.timeoutHandle = noTimeout; <span class="comment">// -1</span></span><br><span class="line">    <span class="built_in">this</span>.context = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.pendingContext = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.hydrate = hydrate;</span><br><span class="line">    <span class="built_in">this</span>.firstBatch = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.callbackExpirationTime = NoWork;</span><br><span class="line">    <span class="built_in">this</span>.firstPendingTime = NoWork;</span><br><span class="line">    <span class="built_in">this</span>.lastPendingTime = NoWork;</span><br><span class="line">    <span class="built_in">this</span>.pingTime = NoWork;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// false 无视</span></span><br><span class="line">    <span class="keyword">if</span> (enableSchedulerTracing) &#123;</span><br><span class="line">        <span class="built_in">this</span>.interactionThreadID = unstable_getThreadID();</span><br><span class="line">        <span class="built_in">this</span>.memoizedInteractions = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="built_in">this</span>.pendingInteractionMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>BaseFiberRootProperties</code>中有相关注释</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type BaseFiberRootProperties = &#123;|</span><br><span class="line">    <span class="comment">// The type of root (legacy, batched, concurrent, etc.)</span></span><br><span class="line">    <span class="comment">// 类型0或1或2</span></span><br><span class="line">    tag: RootTag,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Any additional information from the host associated with this root.</span></span><br><span class="line">    <span class="comment">// 根节点挂载元素</span></span><br><span class="line">    containerInfo: any,</span><br><span class="line">    <span class="comment">// Used only by persistent updates.</span></span><br><span class="line">    pendingChildren: any,</span><br><span class="line">    <span class="comment">// The currently active root fiber. This is the mutable root of the tree.</span></span><br><span class="line">    current: Fiber,</span><br><span class="line"></span><br><span class="line">    pingCache: <span class="built_in">WeakMap</span>&lt;Thenable, <span class="built_in">Set</span>&lt;ExpirationTime&gt;&gt; | <span class="built_in">Map</span>&lt;Thenable, <span class="built_in">Set</span>&lt;ExpirationTime&gt;&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    finishedExpirationTime: ExpirationTime,</span><br><span class="line">    <span class="comment">// A finished work-in-progress HostRoot that&#x27;s ready to be committed.</span></span><br><span class="line">    finishedWork: Fiber | <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// Timeout handle returned by setTimeout. Used to cancel a pending timeout, if</span></span><br><span class="line">    <span class="comment">// it&#x27;s superseded by a new one.</span></span><br><span class="line">    timeoutHandle: TimeoutHandle | NoTimeout,</span><br><span class="line">    <span class="comment">// Top context object, used by renderSubtreeIntoContainer</span></span><br><span class="line">    context: <span class="built_in">Object</span> | <span class="literal">null</span>,</span><br><span class="line">    pendingContext: <span class="built_in">Object</span> | <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// Determines if we should attempt to hydrate on the initial mount</span></span><br><span class="line">    +hydrate: boolean,</span><br><span class="line">    <span class="comment">// List of top-level batches. This list indicates whether a commit should be</span></span><br><span class="line">    <span class="comment">// deferred. Also contains completion callbacks.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Lift this into the renderer</span></span><br><span class="line">    firstBatch: Batch | <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// Node returned by Scheduler.scheduleCallback</span></span><br><span class="line">    callbackNode: *,</span><br><span class="line">    <span class="comment">// Expiration of the callback associated with this root</span></span><br><span class="line">    callbackExpirationTime: ExpirationTime,</span><br><span class="line">    <span class="comment">// The earliest pending expiration time that exists in the tree</span></span><br><span class="line">    firstPendingTime: ExpirationTime,</span><br><span class="line">    <span class="comment">// The latest pending expiration time that exists in the tree</span></span><br><span class="line">    lastPendingTime: ExpirationTime,</span><br><span class="line">    <span class="comment">// The time at which a suspended component pinged the root to render again</span></span><br><span class="line">    pingTime: ExpirationTime,</span><br><span class="line">|&#125;;</span><br></pre></td></tr></table></figure>

<p>创建<code>RootFiber</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createHostRootFiber</span>(<span class="params">tag: RootTag</span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> mode;</span><br><span class="line">    <span class="keyword">if</span> (tag === ConcurrentRoot) &#123;</span><br><span class="line">        mode = ConcurrentMode | BatchedMode | StrictMode; <span class="comment">// 利用二进制特性,一个参数就能同时表示多种状态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === BatchedRoot) &#123;</span><br><span class="line">        mode = BatchedMode | StrictMode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mode = NoMode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3, null, null, 0</span></span><br><span class="line">    <span class="keyword">return</span> createFiber(HostRoot, <span class="literal">null</span>, <span class="literal">null</span>, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FiberNode</span>(<span class="params">tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Instance</span></span><br><span class="line">    <span class="built_in">this</span>.tag = tag; <span class="comment">// 标记不同的组件类型 3</span></span><br><span class="line">    <span class="built_in">this</span>.key = key; <span class="comment">// ReactElement里面的key null</span></span><br><span class="line">    <span class="built_in">this</span>.elementType = <span class="literal">null</span>; <span class="comment">// ReactElement.type，也就是我们调用`createElement`的第一个参数</span></span><br><span class="line">    <span class="built_in">this</span>.type = <span class="literal">null</span>; <span class="comment">// 异步组件resolved之后返回的内容，一般是`function`或者`class`</span></span><br><span class="line">    <span class="built_in">this</span>.stateNode = <span class="literal">null</span>; <span class="comment">// 跟当前Fiber相关本地状态（比如浏览器环境就是DOM节点）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fiber</span></span><br><span class="line">    <span class="built_in">this</span>.return = <span class="literal">null</span>; <span class="comment">// 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回</span></span><br><span class="line">    <span class="built_in">this</span>.child = <span class="literal">null</span>; <span class="comment">// 单链表树结构 指向自己的第一个子节点</span></span><br><span class="line">    <span class="built_in">this</span>.sibling = <span class="literal">null</span>; <span class="comment">// 指向自己的兄弟结构 兄弟节点的return指向同一个父节点</span></span><br><span class="line">    <span class="built_in">this</span>.index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.ref = <span class="literal">null</span>; <span class="comment">// ref属性</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.pendingProps = pendingProps; <span class="comment">// 新的变动带来的新的props</span></span><br><span class="line">    <span class="built_in">this</span>.memoizedProps = <span class="literal">null</span>; <span class="comment">// 上一次渲染完成之后的props</span></span><br><span class="line">    <span class="built_in">this</span>.updateQueue = <span class="literal">null</span>; <span class="comment">// 该Fiber对应的组件产生的Update会存放在这个队列里面</span></span><br><span class="line">    <span class="built_in">this</span>.memoizedState = <span class="literal">null</span>; <span class="comment">// 上一次渲染的时候的state</span></span><br><span class="line">    <span class="built_in">this</span>.contextDependencies = <span class="literal">null</span>; <span class="comment">// 一个列表，存放这个Fiber依赖的context</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来描述当前Fiber和他子树的`Bitfield`</span></span><br><span class="line">    <span class="comment">// 共存的模式表示这个子树是否默认是异步渲染的</span></span><br><span class="line">    <span class="comment">// Fiber被创建的时候他会继承父Fiber</span></span><br><span class="line">    <span class="comment">// 其他的标识也可以在创建的时候被设置</span></span><br><span class="line">    <span class="comment">// 但是在创建之后不应该再被修改，特别是他的子Fiber创建之前</span></span><br><span class="line">    <span class="built_in">this</span>.mode = mode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Effects</span></span><br><span class="line">    <span class="built_in">this</span>.effectTag = NoEffect; <span class="comment">// 用来记录Side Effect</span></span><br><span class="line">    <span class="built_in">this</span>.nextEffect = <span class="literal">null</span>; <span class="comment">// 单链表用来快速查找下一个side effect</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.firstEffect = <span class="literal">null</span>; <span class="comment">// 子树中第一个side effect</span></span><br><span class="line">    <span class="built_in">this</span>.lastEffect = <span class="literal">null</span>; <span class="comment">// 子树中最后一个side effect</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.expirationTime = NoWork; <span class="comment">// 代表任务在未来的哪个时间点应该被完成 不包括他的子树产生的任务</span></span><br><span class="line">    <span class="built_in">this</span>.childExpirationTime = NoWork; <span class="comment">// 快速确定子树中是否有不在等待的变化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Fiber树更新的过程中，每个Fiber都会有一个跟其对应的Fiber</span></span><br><span class="line">    <span class="comment">// 我们称他为`current &lt;==&gt; workInProgress`</span></span><br><span class="line">    <span class="comment">// 在渲染完成之后他们会交换位置</span></span><br><span class="line">    <span class="built_in">this</span>.alternate = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a constructor function, rather than a POJO constructor, still</span></span><br><span class="line"><span class="comment">// please ensure we do the following:</span></span><br><span class="line"><span class="comment">// 1) Nobody should add any instance methods on this. Instance methods can be</span></span><br><span class="line"><span class="comment">//    more difficult to predict when they get optimized and they are almost</span></span><br><span class="line"><span class="comment">//    never inlined properly in static compilers.</span></span><br><span class="line"><span class="comment">// 2) Nobody should rely on `instanceof Fiber` for type testing. We should</span></span><br><span class="line"><span class="comment">//    always know when it is a fiber.</span></span><br><span class="line"><span class="comment">// 3) We might want to experiment with using numeric keys since they are easier</span></span><br><span class="line"><span class="comment">//    to optimize in a non-JIT environment.</span></span><br><span class="line"><span class="comment">// 4) We can easily go from a constructor to a createFiber object literal if that</span></span><br><span class="line"><span class="comment">//    is faster.</span></span><br><span class="line"><span class="comment">// 5) It should be easy to port this to a C struct and keep a C implementation</span></span><br><span class="line"><span class="comment">//    compatible.</span></span><br><span class="line"><span class="keyword">const</span> createFiber = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    tag: WorkTag,</span></span></span><br><span class="line"><span class="function"><span class="params">    pendingProps: mixed,</span></span></span><br><span class="line"><span class="function"><span class="params">    key: null | string,</span></span></span><br><span class="line"><span class="function"><span class="params">    mode: TypeOfMode,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">    <span class="comment">// $FlowFixMe: the shapes are exact here but Flow doesn&#x27;t like constructors</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FiberNode(tag, pendingProps, key, mode);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>之后是两个对象的互相引用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">root.current = uninitializedFiber; <span class="comment">// root即FiberRoot</span></span><br><span class="line">uninitializedFiber.stateNode = root; <span class="comment">// uninitializedFiber即RootFiber</span></span><br></pre></td></tr></table></figure>

<p><code>FiberRoot</code>更多的是和 dom 相关的作用<br><code>RootFiber</code>更多的是一个虚拟 dom，他也有类似 dom 的树结构，每次 react 跟新，都先处理<code>RootFiber</code>，然后在作用于<code>FiberRoot</code>,最后更新 dom</p>
]]></content>
      <tags>
        <tag>react源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>function组件</title>
    <url>/my-notes/2020/09/09/react/function%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="从-beginWork-开始"><a href="#从-beginWork-开始" class="headerlink" title="从 beginWork 开始"></a>从 beginWork 开始</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent: &#123;</span><br><span class="line">        <span class="comment">// 2 function类型组件是这个tag</span></span><br><span class="line">        <span class="keyword">return</span> mountIndeterminateComponent(</span><br><span class="line">            current,</span><br><span class="line">            workInProgress,</span><br><span class="line">            workInProgress.type,</span><br><span class="line">            renderExpirationTime,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mountIndeterminateComponent"><a href="#mountIndeterminateComponent" class="headerlink" title="mountIndeterminateComponent"></a>mountIndeterminateComponent</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountIndeterminateComponent</span>(<span class="params">_current, workInProgress, Component, renderExpirationTime</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_current !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// An indeterminate component only mounts if it suspended inside a non-</span></span><br><span class="line">        <span class="comment">// concurrent tree, in an inconsistent state. We want to treat it like</span></span><br><span class="line">        <span class="comment">// a new mount, even though an empty version of it already committed.</span></span><br><span class="line">        <span class="comment">// Disconnect the alternate pointers.</span></span><br><span class="line">        _current.alternate = <span class="literal">null</span>;</span><br><span class="line">        workInProgress.alternate = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// Since this is conceptually a new fiber, schedule a Placement effect</span></span><br><span class="line">        workInProgress.effectTag |= Placement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> props = workInProgress.pendingProps;</span><br><span class="line">    <span class="keyword">const</span> unmaskedContext = getUnmaskedContext(workInProgress, Component, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> context = getMaskedContext(workInProgress, unmaskedContext);</span><br><span class="line"></span><br><span class="line">    prepareToReadContext(workInProgress, renderExpirationTime);</span><br><span class="line">    <span class="comment">// 以上都是和contetxt有关的处理</span></span><br><span class="line">    <span class="keyword">let</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = renderWithHooks(</span><br><span class="line">            <span class="comment">// 返回reactnode对象</span></span><br><span class="line">            <span class="literal">null</span>,</span><br><span class="line">            workInProgress,</span><br><span class="line">            Component,</span><br><span class="line">            props,</span><br><span class="line">            context,</span><br><span class="line">            renderExpirationTime,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// React DevTools reads this flag.</span></span><br><span class="line">    workInProgress.effectTag |= PerformedWork;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// class 或 function组件</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        <span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">        value !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> value.render === <span class="string">&#x27;function&#x27;</span> &amp;&amp;</span><br><span class="line">        value.$$typeof === <span class="literal">undefined</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// Proceed under the assumption that this is a class instance</span></span><br><span class="line">        workInProgress.tag = ClassComponent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Throw out any hooks that were used.</span></span><br><span class="line">        resetHooks();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Push context providers early to prevent context stack mismatches.</span></span><br><span class="line">        <span class="comment">// During mounting we don&#x27;t know the child context yet as the instance doesn&#x27;t exist.</span></span><br><span class="line">        <span class="comment">// We will invalidate the child context in finishClassComponent() right after rendering.</span></span><br><span class="line">        <span class="keyword">let</span> hasContext = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (isLegacyContextProvider(Component)) &#123;</span><br><span class="line">            hasContext = <span class="literal">true</span>;</span><br><span class="line">            pushLegacyContextProvider(workInProgress);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hasContext = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        workInProgress.memoizedState =</span><br><span class="line">            value.state !== <span class="literal">null</span> &amp;&amp; value.state !== <span class="literal">undefined</span> ? value.state : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> getDerivedStateFromProps = Component.getDerivedStateFromProps;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> getDerivedStateFromProps === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        adoptClassInstance(workInProgress, value);</span><br><span class="line">        mountClassInstance(workInProgress, Component, props, renderExpirationTime);</span><br><span class="line">        <span class="keyword">return</span> finishClassComponent(</span><br><span class="line">            <span class="literal">null</span>,</span><br><span class="line">            workInProgress,</span><br><span class="line">            Component,</span><br><span class="line">            <span class="literal">true</span>,</span><br><span class="line">            hasContext,</span><br><span class="line">            renderExpirationTime,</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Proceed under the assumption that this is a function component</span></span><br><span class="line">        workInProgress.tag = FunctionComponent;</span><br><span class="line">        reconcileChildren(<span class="literal">null</span>, workInProgress, value, renderExpirationTime);</span><br><span class="line">        <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="renderWithHooks"><a href="#renderWithHooks" class="headerlink" title="renderWithHooks"></a>renderWithHooks</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderWithHooks</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    Component: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    props: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    refOrContext: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextRenderExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    renderExpirationTime = nextRenderExpirationTime;</span><br><span class="line">    currentlyRenderingFiber = workInProgress;</span><br><span class="line">    nextCurrentHook = current !== <span class="literal">null</span> ? current.memoizedState : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The following should have already been reset</span></span><br><span class="line">    <span class="comment">// currentHook = null;</span></span><br><span class="line">    <span class="comment">// workInProgressHook = null;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// remainingExpirationTime = NoWork;</span></span><br><span class="line">    <span class="comment">// componentUpdateQueue = null;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// didScheduleRenderPhaseUpdate = false;</span></span><br><span class="line">    <span class="comment">// renderPhaseUpdates = null;</span></span><br><span class="line">    <span class="comment">// numberOfReRenders = 0;</span></span><br><span class="line">    <span class="comment">// sideEffectTag = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO Warn if no hooks are used at all during mount, then some are used during update.</span></span><br><span class="line">    <span class="comment">// Currently we will identify the update render as a mount because nextCurrentHook === null.</span></span><br><span class="line">    <span class="comment">// This is tricky because it&#x27;s valid for certain types of components (e.g. React.lazy)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using nextCurrentHook to differentiate between mount/update only works if at least one stateful hook is used.</span></span><br><span class="line">    <span class="comment">// Non-stateful hooks (e.g. context) don&#x27;t get added to memoizedState,</span></span><br><span class="line">    <span class="comment">// so nextCurrentHook would be null during updates and mounts.</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ReactCurrentDispatcher.current =</span><br><span class="line">            nextCurrentHook === <span class="literal">null</span> ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行函数，得到children</span></span><br><span class="line">    <span class="keyword">let</span> children = Component(props, refOrContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (didScheduleRenderPhaseUpdate) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            didScheduleRenderPhaseUpdate = <span class="literal">false</span>;</span><br><span class="line">            numberOfReRenders += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start over from the beginning of the list</span></span><br><span class="line">            nextCurrentHook = current !== <span class="literal">null</span> ? current.memoizedState : <span class="literal">null</span>;</span><br><span class="line">            nextWorkInProgressHook = firstWorkInProgressHook;</span><br><span class="line"></span><br><span class="line">            currentHook = <span class="literal">null</span>;</span><br><span class="line">            workInProgressHook = <span class="literal">null</span>;</span><br><span class="line">            componentUpdateQueue = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">                <span class="comment">// Also validate hook order for cascading updates.</span></span><br><span class="line">                hookTypesUpdateIndexDev = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ReactCurrentDispatcher.current = __DEV__</span><br><span class="line">                ? HooksDispatcherOnUpdateInDEV</span><br><span class="line">                : HooksDispatcherOnUpdate;</span><br><span class="line"></span><br><span class="line">            children = Component(props, refOrContext);</span><br><span class="line">        &#125; <span class="keyword">while</span> (didScheduleRenderPhaseUpdate);</span><br><span class="line"></span><br><span class="line">        renderPhaseUpdates = <span class="literal">null</span>;</span><br><span class="line">        numberOfReRenders = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We can assume the previous dispatcher is always this one, since we set it</span></span><br><span class="line">    <span class="comment">// at the beginning of the render phase and there&#x27;s no re-entrancy.</span></span><br><span class="line">    ReactCurrentDispatcher.current = ContextOnlyDispatcher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> renderedWork: Fiber = (currentlyRenderingFiber: any);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放了所有用到的hooks，能用next找到下一个</span></span><br><span class="line">    renderedWork.memoizedState = firstWorkInProgressHook;</span><br><span class="line">    renderedWork.expirationTime = remainingExpirationTime;</span><br><span class="line">    renderedWork.updateQueue = (componentUpdateQueue: any);</span><br><span class="line">    renderedWork.effectTag |= sideEffectTag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This check uses currentHook so that it works the same in DEV and prod bundles.</span></span><br><span class="line">    <span class="comment">// hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.</span></span><br><span class="line">    <span class="keyword">const</span> didRenderTooFewHooks = currentHook !== <span class="literal">null</span> &amp;&amp; currentHook.next !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    renderExpirationTime = NoWork;</span><br><span class="line">    currentlyRenderingFiber = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    currentHook = <span class="literal">null</span>;</span><br><span class="line">    nextCurrentHook = <span class="literal">null</span>;</span><br><span class="line">    firstWorkInProgressHook = <span class="literal">null</span>;</span><br><span class="line">    workInProgressHook = <span class="literal">null</span>;</span><br><span class="line">    nextWorkInProgressHook = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    remainingExpirationTime = NoWork;</span><br><span class="line">    componentUpdateQueue = <span class="literal">null</span>;</span><br><span class="line">    sideEffectTag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These were reset above</span></span><br><span class="line">    <span class="comment">// didScheduleRenderPhaseUpdate = false;</span></span><br><span class="line">    <span class="comment">// renderPhaseUpdates = null;</span></span><br><span class="line">    <span class="comment">// numberOfReRenders = 0;</span></span><br><span class="line"></span><br><span class="line">    invariant(</span><br><span class="line">        !didRenderTooFewHooks,</span><br><span class="line">        <span class="string">&#x27;Rendered fewer hooks than expected. This may be caused by an accidental &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;early return statement.&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>reconcileChildFibers</title>
    <url>/my-notes/2020/09/09/react/reconcileChildFibers/</url>
    <content><![CDATA[<p>根据实例构建 fiber</p>
<h3 id="reconcileChildFibers"><a href="#reconcileChildFibers" class="headerlink" title="reconcileChildFibers"></a>reconcileChildFibers</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildFibers</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChild: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function is not recursive.</span></span><br><span class="line">    <span class="comment">// If the top level item is an array, we treat it as a set of children,</span></span><br><span class="line">    <span class="comment">// not as a fragment. Nested arrays on the other hand will be treated as</span></span><br><span class="line">    <span class="comment">// fragment nodes. Recursion happens at the normal flow.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle top level unkeyed fragments as if they were arrays.</span></span><br><span class="line">    <span class="comment">// This leads to an ambiguity between &lt;&gt;&#123;[...]&#125;&lt;/&gt; and &lt;&gt;...&lt;/&gt;.</span></span><br><span class="line">    <span class="comment">// We treat the ambiguous cases above the same.</span></span><br><span class="line">    <span class="keyword">const</span> isUnkeyedTopLevelFragment = <span class="comment">// 是否fragment</span></span><br><span class="line">        <span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">        newChild !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        newChild.type === REACT_FRAGMENT_TYPE &amp;&amp;</span><br><span class="line">        newChild.key === <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isUnkeyedTopLevelFragment) &#123;</span><br><span class="line">        newChild = newChild.props.children; <span class="comment">// 如果是fragment取他的子节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle object types</span></span><br><span class="line">    <span class="comment">// newChild可能是一个children</span></span><br><span class="line">    <span class="keyword">const</span> isObject = <span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (</span><br><span class="line">            newChild.$$typeof <span class="comment">// 子节点是单一的</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">                <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">                    reconcileSingleElement(</span><br><span class="line">                        returnFiber,</span><br><span class="line">                        currentFirstChild,</span><br><span class="line">                        newChild,</span><br><span class="line">                        expirationTime,</span><br><span class="line">                    ),</span><br><span class="line">                );</span><br><span class="line">            <span class="keyword">case</span> REACT_PORTAL_TYPE:</span><br><span class="line">                <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">                    reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime),</span><br><span class="line">                );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> newChild === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">            reconcileSingleTextNode(returnFiber, currentFirstChild, <span class="string">&#x27;&#x27;</span> + newChild, expirationTime),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isArray(newChild)) &#123;</span><br><span class="line">        <span class="comment">// newChild是数组，多个子节点</span></span><br><span class="line">        <span class="keyword">return</span> reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getIteratorFn(newChild)) &#123;</span><br><span class="line">        <span class="keyword">return</span> reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">        throwOnInvalidObjectType(returnFiber, newChild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; !isUnkeyedTopLevelFragment) &#123;</span><br><span class="line">        <span class="comment">// If the new child is undefined, and the return fiber is a composite</span></span><br><span class="line">        <span class="comment">// component, throw an error. If Fiber return types are disabled,</span></span><br><span class="line">        <span class="comment">// we already threw above.</span></span><br><span class="line">        <span class="keyword">switch</span> (returnFiber.tag) &#123;</span><br><span class="line">            <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Intentionally fall through to the next case, which handles both</span></span><br><span class="line">            <span class="comment">// functions and classes</span></span><br><span class="line">            <span class="comment">// eslint-disable-next-lined no-fallthrough</span></span><br><span class="line">            <span class="keyword">case</span> FunctionComponent: &#123;</span><br><span class="line">                <span class="keyword">const</span> Component = returnFiber.type;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remaining cases are all treated as empty.</span></span><br><span class="line">    <span class="keyword">return</span> deleteRemainingChildren(returnFiber, currentFirstChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="reconcileChildrenArray"><a href="#reconcileChildrenArray" class="headerlink" title="reconcileChildrenArray"></a>reconcileChildrenArray</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildrenArray</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChildren: Array&lt;*&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This algorithm can&#x27;t optimize by searching from both ends since we</span></span><br><span class="line">    <span class="comment">// don&#x27;t have backpointers on fibers. I&#x27;m trying to see how far we can get</span></span><br><span class="line">    <span class="comment">// with that model. If it ends up not being worth the tradeoffs, we can</span></span><br><span class="line">    <span class="comment">// add it later.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Even with a two ended optimization, we&#x27;d want to optimize for the case</span></span><br><span class="line">    <span class="comment">// where there are few changes and brute force the comparison instead of</span></span><br><span class="line">    <span class="comment">// going for the Map. It&#x27;d like to explore hitting that path first in</span></span><br><span class="line">    <span class="comment">// forward-only mode and only go for the Map once we notice that we need</span></span><br><span class="line">    <span class="comment">// lots of look ahead. This doesn&#x27;t handle reversal as well as two ended</span></span><br><span class="line">    <span class="comment">// search but that&#x27;s unusual. Besides, for the two ended optimization to</span></span><br><span class="line">    <span class="comment">// work on Iterables, we&#x27;d need to copy the whole set.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// In this first iteration, we&#x27;ll just live with hitting the bad case</span></span><br><span class="line">    <span class="comment">// (adding everything to a Map) in for every insert/move.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If you change this code, also update reconcileChildrenIterator() which</span></span><br><span class="line">    <span class="comment">// uses the same algorithm.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> resultingFirstChild: Fiber | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> previousNewFiber: Fiber | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> oldFiber = currentFirstChild;</span><br><span class="line">    <span class="keyword">let</span> lastPlacedIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> newIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> nextOldFiber = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// debugger</span></span><br><span class="line">    <span class="comment">// 第一轮遍历条件：存在原先的子节点且未遍历完需要更新的子节点</span></span><br><span class="line">    <span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldFiber.index &gt; newIdx) &#123;</span><br><span class="line">            nextOldFiber = oldFiber;</span><br><span class="line">            oldFiber = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextOldFiber = oldFiber.sibling;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> newFiber = updateSlot(</span><br><span class="line">            <span class="comment">// 老的和新的没对应上返回null</span></span><br><span class="line">            returnFiber,</span><br><span class="line">            oldFiber,</span><br><span class="line">            newChildren[newIdx],</span><br><span class="line">            expirationTime,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 走出循环</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> This breaks on empty slots like null children. That&#x27;s</span></span><br><span class="line">            <span class="comment">// unfortunate because it triggers the slow path all the time. We need</span></span><br><span class="line">            <span class="comment">// a better way to communicate whether this was a miss or null,</span></span><br><span class="line">            <span class="comment">// boolean, undefined, etc.</span></span><br><span class="line">            <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">                oldFiber = nextOldFiber;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldFiber &amp;&amp; newFiber.alternate === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 没有复用，删除老的</span></span><br><span class="line">                <span class="comment">// We matched the slot, but we didn&#x27;t reuse the existing fiber, so we</span></span><br><span class="line">                <span class="comment">// need to delete the existing child.</span></span><br><span class="line">                deleteChild(returnFiber, oldFiber);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">        <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Move out of the loop. This only happens for the first run.</span></span><br><span class="line">            resultingFirstChild = newFiber;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Defer siblings if we&#x27;re not at the right index for this slot.</span></span><br><span class="line">            <span class="comment">// I.e. if we had null values before, then we want to defer this</span></span><br><span class="line">            <span class="comment">// for each null value. However, we also don&#x27;t want to call updateSlot</span></span><br><span class="line">            <span class="comment">// with the previous one.</span></span><br><span class="line">            previousNewFiber.sibling = newFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        previousNewFiber = newFiber;</span><br><span class="line">        oldFiber = nextOldFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newIdx === newChildren.length) &#123;</span><br><span class="line">        <span class="comment">// 新节点已被遍历完全，删除剩下的节点（如果有），然后退出</span></span><br><span class="line">        <span class="comment">// We&#x27;ve reached the end of the new children. We can delete the rest.</span></span><br><span class="line">        deleteRemainingChildren(returnFiber, oldFiber);</span><br><span class="line">        <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有oldFiber，全部插入</span></span><br><span class="line">        <span class="comment">// If we don&#x27;t have any more existing children we can choose a fast path</span></span><br><span class="line">        <span class="comment">// since the rest will all be insertions.</span></span><br><span class="line">        <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">            <span class="keyword">const</span> newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime); <span class="comment">// 更具element创建fiber</span></span><br><span class="line">            <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">            <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Move out of the loop. This only happens for the first run.</span></span><br><span class="line">                resultingFirstChild = newFiber;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                previousNewFiber.sibling = newFiber; <span class="comment">// 建立兄弟节点，单向sibling</span></span><br><span class="line">            &#125;</span><br><span class="line">            previousNewFiber = newFiber; <span class="comment">// 记录上一个</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add all children to a key map for quick lookups.</span></span><br><span class="line">    <span class="comment">// 把老的fiber以key或index转为map 1 =&gt; one fiber ...</span></span><br><span class="line">    <span class="keyword">const</span> existingChildren = mapRemainingChildren(returnFiber, oldFiber);</span><br><span class="line">    <span class="comment">// Keep scanning and use the map to restore deleted items as moves.</span></span><br><span class="line">    <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">        <span class="keyword">const</span> newFiber = updateFromMap(</span><br><span class="line">            existingChildren,</span><br><span class="line">            returnFiber,</span><br><span class="line">            newIdx,</span><br><span class="line">            newChildren[newIdx],</span><br><span class="line">            expirationTime,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (newFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">                <span class="keyword">if</span> (newFiber.alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// The new fiber is a work in progress, but if there exists a</span></span><br><span class="line">                    <span class="comment">// current, that means that we reused the fiber. We need to delete</span></span><br><span class="line">                    <span class="comment">// it from the child list so that we don&#x27;t add it to the deletion</span></span><br><span class="line">                    <span class="comment">// list.</span></span><br><span class="line">                    existingChildren.delete(newFiber.key === <span class="literal">null</span> ? newIdx : newFiber.key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">            <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">                resultingFirstChild = newFiber;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 设置兄弟节点</span></span><br><span class="line">                previousNewFiber.sibling = newFiber;</span><br><span class="line">            &#125;</span><br><span class="line">            previousNewFiber = newFiber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">        <span class="comment">// Any existing children that weren&#x27;t consumed above were deleted. We need</span></span><br><span class="line">        <span class="comment">// to add them to the deletion list.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除在新fiber李没有的老fiber， 给effectTag添加删除标记</span></span><br><span class="line">        existingChildren.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> deleteChild(returnFiber, child));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>一些对象定义</title>
    <url>/my-notes/2020/09/08/react/%E5%90%84%E7%A7%8D%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type Update&lt;State&gt; = &#123;</span><br><span class="line">    <span class="comment">// 过期时间</span></span><br><span class="line">    expirationTime: ExpirationTime,</span><br><span class="line"></span><br><span class="line">    suspenseConfig: <span class="literal">null</span> | SuspenseConfig,</span><br><span class="line"></span><br><span class="line">    tag: <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// react 组件对象 element:&#123;$$typeof: Symbol(react.element),...&#125;</span></span><br><span class="line">    payload: any,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应回调</span></span><br><span class="line">    callback: (<span class="function">() =&gt;</span> mixed) | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个update</span></span><br><span class="line">    next: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">    nextEffect: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="UpdateQueue"><a href="#UpdateQueue" class="headerlink" title="UpdateQueue"></a>UpdateQueue</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type UpdateQueue&lt;State&gt; = &#123;</span><br><span class="line">    <span class="comment">// 当前state</span></span><br><span class="line">    baseState: State,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个update</span></span><br><span class="line">    firstUpdate: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 最后一个update</span></span><br><span class="line">    lastUpdate: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    firstCapturedUpdate: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">    lastCapturedUpdate: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// side effect</span></span><br><span class="line">    firstEffect: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">    lastEffect: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    firstCapturedEffect: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">    lastCapturedEffect: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="update-状态"><a href="#update-状态" class="headerlink" title="update 状态"></a>update 状态</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0更新 1替换 2强制更新 3捕获性的更新</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UpdateState = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ReplaceState = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ForceUpdate = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CaptureUpdate = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>常量</title>
    <url>/my-notes/2020/09/07/react/%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<h2 id="RootTag"><a href="#RootTag" class="headerlink" title="RootTag"></a>RootTag</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type RootTag = <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> LegacyRoot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> BatchedRoot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ConcurrentRoot = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h2 id="TypeOfMode"><a href="#TypeOfMode" class="headerlink" title="TypeOfMode"></a>TypeOfMode</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type TypeOfMode = number;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoMode = <span class="number">0b0000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> StrictMode = <span class="number">0b0001</span>;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Remove BatchedMode and ConcurrentMode by reading from the root</span></span><br><span class="line"><span class="comment">// tag instead</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> BatchedMode = <span class="number">0b0010</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ConcurrentMode = <span class="number">0b0100</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ProfileMode = <span class="number">0b1000</span>;</span><br></pre></td></tr></table></figure>

<h2 id="WorkTag"><a href="#WorkTag" class="headerlink" title="WorkTag"></a>WorkTag</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type WorkTag =</span><br><span class="line">    | <span class="number">0</span></span><br><span class="line">    | <span class="number">1</span></span><br><span class="line">    | <span class="number">2</span></span><br><span class="line">    | <span class="number">3</span></span><br><span class="line">    | <span class="number">4</span></span><br><span class="line">    | <span class="number">5</span></span><br><span class="line">    | <span class="number">6</span></span><br><span class="line">    | <span class="number">7</span></span><br><span class="line">    | <span class="number">8</span></span><br><span class="line">    | <span class="number">9</span></span><br><span class="line">    | <span class="number">10</span></span><br><span class="line">    | <span class="number">11</span></span><br><span class="line">    | <span class="number">12</span></span><br><span class="line">    | <span class="number">13</span></span><br><span class="line">    | <span class="number">14</span></span><br><span class="line">    | <span class="number">15</span></span><br><span class="line">    | <span class="number">16</span></span><br><span class="line">    | <span class="number">17</span></span><br><span class="line">    | <span class="number">18</span></span><br><span class="line">    | <span class="number">19</span></span><br><span class="line">    | <span class="number">20</span></span><br><span class="line">    | <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> FunctionComponent = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ClassComponent = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IndeterminateComponent = <span class="number">2</span>; <span class="comment">// Before we know whether it is function or class</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> HostRoot = <span class="number">3</span>; <span class="comment">// Root of a host tree. Could be nested inside another node.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> HostPortal = <span class="number">4</span>; <span class="comment">// A subtree. Could be an entry point to a different renderer.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> HostComponent = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> HostText = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Fragment = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Mode = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ContextConsumer = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ContextProvider = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ForwardRef = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Profiler = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SuspenseComponent = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MemoComponent = <span class="number">14</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SimpleMemoComponent = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> LazyComponent = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IncompleteClassComponent = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DehydratedSuspenseComponent = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventComponent = <span class="number">19</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventTarget = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SuspenseListComponent = <span class="number">21</span>;</span><br></pre></td></tr></table></figure>

<h2 id="ExecutionContext"><a href="#ExecutionContext" class="headerlink" title="ExecutionContext"></a>ExecutionContext</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type ExecutionContext = number;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NoContext = <span class="number">0b000000</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">const</span> BatchedContext = <span class="number">0b000001</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">const</span> EventContext = <span class="number">0b000010</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">const</span> DiscreteEventContext = <span class="number">0b000100</span>; <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">const</span> LegacyUnbatchedContext = <span class="number">0b001000</span>; <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">const</span> RenderContext = <span class="number">0b010000</span>; <span class="comment">// 16</span></span><br><span class="line"><span class="keyword">const</span> CommitContext = <span class="number">0b100000</span>; <span class="comment">// 32</span></span><br></pre></td></tr></table></figure>

<h2 id="ExpirationTime"><a href="#ExpirationTime" class="headerlink" title="ExpirationTime"></a>ExpirationTime</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type ExpirationTime = number;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoWork = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Never = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Sync = MAX_SIGNED_31_BIT_INT; <span class="comment">// Math.pow(2, 30) - 1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Batched = Sync - <span class="number">1</span>; <span class="comment">// Math.pow(2, 30) - 2</span></span><br></pre></td></tr></table></figure>

<h2 id="ReactPriorityLevel"><a href="#ReactPriorityLevel" class="headerlink" title="ReactPriorityLevel"></a>ReactPriorityLevel</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> opaque type ReactPriorityLevel = <span class="number">99</span> | <span class="number">98</span> | <span class="number">97</span> | <span class="number">96</span> | <span class="number">95</span> | <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Except for NoPriority, these correspond to Scheduler priorities. We use</span></span><br><span class="line"><span class="comment">// ascending numbers so we can compare them like numbers. They start at 90 to</span></span><br><span class="line"><span class="comment">// avoid clashing with Scheduler&#x27;s priorities.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ImmediatePriority: ReactPriorityLevel = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UserBlockingPriority: ReactPriorityLevel = <span class="number">98</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NormalPriority: ReactPriorityLevel = <span class="number">97</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> LowPriority: ReactPriorityLevel = <span class="number">96</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IdlePriority: ReactPriorityLevel = <span class="number">95</span>;</span><br><span class="line"><span class="comment">// NoPriority is the absence of priority. Also React-only.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoPriority: ReactPriorityLevel = <span class="number">90</span>;</span><br></pre></td></tr></table></figure>

<h2 id="SideEffectTag"><a href="#SideEffectTag" class="headerlink" title="SideEffectTag"></a>SideEffectTag</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type SideEffectTag = number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don&#x27;t change these two values. They&#x27;re used by React Dev Tools.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoEffect = <span class="comment">/*              */</span> <span class="number">0b000000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> PerformedWork = <span class="comment">/*         */</span> <span class="number">0b000000000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// You can change the rest (and add more).</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Placement = <span class="comment">/*             */</span> <span class="number">0b000000000010</span>; <span class="comment">// 替换</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Update = <span class="comment">/*                */</span> <span class="number">0b000000000100</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> PlacementAndUpdate = <span class="comment">/*    */</span> <span class="number">0b000000000110</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Deletion = <span class="comment">/*              */</span> <span class="number">0b000000001000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ContentReset = <span class="comment">/*          */</span> <span class="number">0b000000010000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Callback = <span class="comment">/*              */</span> <span class="number">0b000000100000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DidCapture = <span class="comment">/*            */</span> <span class="number">0b000001000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Ref = <span class="comment">/*                   */</span> <span class="number">0b000010000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Snapshot = <span class="comment">/*              */</span> <span class="number">0b000100000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Passive = <span class="comment">/*               */</span> <span class="number">0b001000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Passive &amp; Update &amp; Callback &amp; Ref &amp; Snapshot</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> LifecycleEffectMask = <span class="comment">/*   */</span> <span class="number">0b001110100100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Union of all host effects</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> HostEffectMask = <span class="comment">/*        */</span> <span class="number">0b001111111111</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Incomplete = <span class="comment">/*            */</span> <span class="number">0b010000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ShouldCapture = <span class="comment">/*         */</span> <span class="number">0b100000000000</span>;</span><br></pre></td></tr></table></figure>

<h2 id="supportsMutation"><a href="#supportsMutation" class="headerlink" title="supportsMutation"></a>supportsMutation</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在浏览器环境中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> supportsMutation = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h2 id="HookEffectTag"><a href="#HookEffectTag" class="headerlink" title="HookEffectTag"></a>HookEffectTag</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type HookEffectTag = number;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoEffect = <span class="comment">/*             */</span> <span class="number">0b00000000</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UnmountSnapshot = <span class="comment">/*      */</span> <span class="number">0b00000010</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UnmountMutation = <span class="comment">/*      */</span> <span class="number">0b00000100</span>; <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MountMutation = <span class="comment">/*        */</span> <span class="number">0b00001000</span>; <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UnmountLayout = <span class="comment">/*        */</span> <span class="number">0b00010000</span>; <span class="comment">// 16</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MountLayout = <span class="comment">/*          */</span> <span class="number">0b00100000</span>; <span class="comment">// 32</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MountPassive = <span class="comment">/*         */</span> <span class="number">0b01000000</span>; <span class="comment">// 64</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UnmountPassive = <span class="comment">/*       */</span> <span class="number">0b10000000</span>; <span class="comment">// 128</span></span><br></pre></td></tr></table></figure>

<h2 id="HTMLNodeType"><a href="#HTMLNodeType" class="headerlink" title="HTMLNodeType"></a>HTMLNodeType</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ELEMENT_NODE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TEXT_NODE = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> COMMENT_NODE = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DOCUMENT_NODE = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DOCUMENT_FRAGMENT_NODE = <span class="number">11</span>;</span><br></pre></td></tr></table></figure>

<h2 id="优先级相关"><a href="#优先级相关" class="headerlink" title="优先级相关"></a>优先级相关</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Use symbols?</span></span><br><span class="line"><span class="keyword">var</span> ImmediatePriority = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> UserBlockingPriority = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> NormalPriority = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> LowPriority = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> IdlePriority = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Max 31 bit integer. The max integer size in V8 for 32-bit systems.</span></span><br><span class="line"><span class="comment">// Math.pow(2, 30) - 1</span></span><br><span class="line"><span class="comment">// 0b111111111111111111111111111111</span></span><br><span class="line"><span class="keyword">var</span> maxSigned31BitInt = <span class="number">1073741823</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Times out immediately</span></span><br><span class="line"><span class="keyword">var</span> IMMEDIATE_PRIORITY_TIMEOUT = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// Eventually times out</span></span><br><span class="line"><span class="keyword">var</span> USER_BLOCKING_PRIORITY = <span class="number">250</span>;</span><br><span class="line"><span class="keyword">var</span> NORMAL_PRIORITY_TIMEOUT = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">var</span> LOW_PRIORITY_TIMEOUT = <span class="number">10000</span>;</span><br><span class="line"><span class="comment">// Never times out</span></span><br><span class="line"><span class="keyword">var</span> IDLE_PRIORITY = maxSigned31BitInt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>Provider</title>
    <url>/my-notes/2020/09/14/react-redux/Provider/</url>
    <content><![CDATA[<h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>Provider 接收 3 个参数，context 也可以自定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Provider</span>(<span class="params">&#123;store, context, children&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> contextValue = useMemo(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> subscription = <span class="keyword">new</span> Subscription(store); <span class="comment">// 初始化订阅</span></span><br><span class="line">        subscription.onStateChange = subscription.notifyNestedSubs; <span class="comment">// this.listeners.notify();</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            store,</span><br><span class="line">            subscription,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;, [store]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回store数据</span></span><br><span class="line">    <span class="keyword">const</span> previousState = useMemo(<span class="function">() =&gt;</span> store.getState(), [store]);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;subscription&#125; = contextValue;</span><br><span class="line">        subscription.trySubscribe(); <span class="comment">// 尝试订阅，订阅函数初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (previousState !== store.getState()) &#123;</span><br><span class="line">            subscription.notifyNestedSubs(); <span class="comment">// 遍历执行listener，第一次是空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            subscription.tryUnsubscribe(); <span class="comment">// 解绑</span></span><br><span class="line">            subscription.onStateChange = <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;, [contextValue, previousState]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Context = context || ReactReduxContext; <span class="comment">// 默认的React.createContext</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以react context的方式传递value, Context相关可看react context.md</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;contextValue&#125;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react-redux</tag>
      </tags>
  </entry>
  <entry>
    <title>selectorFactory</title>
    <url>/my-notes/2020/09/14/react-redux/Subscription/</url>
    <content><![CDATA[<p>redux 订阅管理</p>
<p>redux 默认 batch 来源</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;unstable_batchedUpdates&#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line">setBatch(unstable_batchedUpdates);</span><br></pre></td></tr></table></figure>

<p>batchedUpdates, 涉及到 react 跟新机制，在执行 listeners 后，执行同步队列，统一跟新</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">batchedUpdates</span>&lt;<span class="title">A</span>, <span class="title">R</span>&gt;(<span class="params">fn: (A) =&gt; R, a: A</span>): <span class="title">R</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> prevExecutionContext = executionContext;</span><br><span class="line">    executionContext |= BatchedContext;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fn(a);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        executionContext = prevExecutionContext;</span><br><span class="line">        <span class="keyword">if</span> (executionContext === NoContext) &#123;</span><br><span class="line">            <span class="comment">// Flush the immediate callbacks that were scheduled during this batch</span></span><br><span class="line">            flushSyncCallbackQueue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// encapsulates the subscription logic for connecting a component to the redux store, as</span></span><br><span class="line"><span class="comment">// well as nesting subscriptions of descendant components, so that we can ensure the</span></span><br><span class="line"><span class="comment">// ancestor components re-render before descendants</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CLEARED = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> nullListeners = &#123;notify() &#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createListenerCollection</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> batch = getBatch();</span><br><span class="line">    <span class="comment">// the current/next pattern is copied from redux&#x27;s createStore code.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> refactor+expose that code to be reusable here?</span></span><br><span class="line">    <span class="keyword">let</span> current = [];</span><br><span class="line">    <span class="keyword">let</span> next = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        clear() &#123;</span><br><span class="line">            next = CLEARED;</span><br><span class="line">            current = CLEARED;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        notify() &#123;</span><br><span class="line">            <span class="keyword">const</span> listeners = (current = next);</span><br><span class="line">            batch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">                    listeners[i]();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        get() &#123;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        subscribe(listener) &#123;</span><br><span class="line">            <span class="keyword">let</span> isSubscribed = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (next === current) next = current.slice();</span><br><span class="line">            next.push(listener);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!isSubscribed || current === CLEARED) <span class="keyword">return</span>;</span><br><span class="line">                isSubscribed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (next === current) next = current.slice();</span><br><span class="line">                next.splice(next.indexOf(listener), <span class="number">1</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscription</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(store, parentSub) &#123;</span><br><span class="line">        <span class="comment">// store详细见createStore.md</span></span><br><span class="line">        <span class="built_in">this</span>.store = store;</span><br><span class="line">        <span class="built_in">this</span>.parentSub = parentSub;</span><br><span class="line">        <span class="built_in">this</span>.unsubscribe = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.listeners = nullListeners;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.handleChangeWrapper = <span class="built_in">this</span>.handleChangeWrapper.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addNestedSub(listener) &#123;</span><br><span class="line">        <span class="built_in">this</span>.trySubscribe();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.listeners.subscribe(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notifyNestedSubs() &#123;</span><br><span class="line">        <span class="built_in">this</span>.listeners.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChangeWrapper() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.onStateChange) &#123;</span><br><span class="line">            <span class="comment">// onStateChange = notifyNestedSubs</span></span><br><span class="line">            <span class="built_in">this</span>.onStateChange();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isSubscribed() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Boolean</span>(<span class="built_in">this</span>.unsubscribe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trySubscribe() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.unsubscribe) &#123;</span><br><span class="line">            <span class="built_in">this</span>.unsubscribe = <span class="built_in">this</span>.parentSub</span><br><span class="line">                ? <span class="built_in">this</span>.parentSub.addNestedSub(<span class="built_in">this</span>.handleChangeWrapper)</span><br><span class="line">                : <span class="built_in">this</span>.store.subscribe(<span class="built_in">this</span>.handleChangeWrapper); <span class="comment">//  createStore的subscribe，返回一个函数unsubscribe</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.listeners = createListenerCollection();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryUnsubscribe() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.unsubscribe) &#123;</span><br><span class="line">            <span class="built_in">this</span>.unsubscribe();</span><br><span class="line">            <span class="built_in">this</span>.unsubscribe = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.listeners.clear();</span><br><span class="line">            <span class="built_in">this</span>.listeners = nullListeners;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react-redux</tag>
      </tags>
  </entry>
  <entry>
    <title>bindActionCreators</title>
    <url>/my-notes/2020/09/14/react-redux/bindActionCreators/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本质 dispatch(&#123;type: &#x27;ADD&#x27;, value: &#x27;...&#x27;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindActionCreator</span>(<span class="params">actionCreator, dispatch</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dispatch(actionCreator.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Turns an object whose values are action creators, into an object with the</span></span><br><span class="line"><span class="comment"> * same keys, but with every function wrapped into a `dispatch` call so they</span></span><br><span class="line"><span class="comment"> * may be invoked directly. This is just a convenience method, as you can call</span></span><br><span class="line"><span class="comment"> * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For convenience, you can also pass a single function as the first argument,</span></span><br><span class="line"><span class="comment"> * and get a function in return.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function|Object&#125;</span> </span>actionCreators An object whose values are action</span></span><br><span class="line"><span class="comment"> * creator functions. One handy way to obtain it is to use ES6 `import * as`</span></span><br><span class="line"><span class="comment"> * syntax. You may also pass a single function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>dispatch The `dispatch` function available on your Redux</span></span><br><span class="line"><span class="comment"> * store.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Function|Object&#125;</span> </span>The object mimicking the original object, but with</span></span><br><span class="line"><span class="comment"> * every action creator wrapped into the `dispatch` call. If you passed a</span></span><br><span class="line"><span class="comment"> * function as `actionCreators`, the return value will also be a single</span></span><br><span class="line"><span class="comment"> * function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">bindActionCreators</span>(<span class="params">actionCreators, dispatch</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreators === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bindActionCreator(actionCreators, dispatch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreators !== <span class="string">&#x27;object&#x27;</span> || actionCreators === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">            <span class="string">`bindActionCreators expected an object or a function, instead received <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">                actionCreators === <span class="literal">null</span> ? <span class="string">&#x27;null&#x27;</span> : <span class="keyword">typeof</span> actionCreators</span></span></span><br><span class="line"><span class="string"><span class="subst">            &#125;</span>. `</span> +</span><br><span class="line">                <span class="string">`Did you write &quot;import ActionCreators from&quot; instead of &quot;import * as ActionCreators from&quot;?`</span>,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(actionCreators);</span><br><span class="line">    <span class="keyword">const</span> boundActionCreators = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = keys[i];</span><br><span class="line">        <span class="keyword">const</span> actionCreator = actionCreators[key];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreator === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> boundActionCreators;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react-redux</tag>
      </tags>
  </entry>
  <entry>
    <title>connect</title>
    <url>/my-notes/2020/09/14/react-redux/connect/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  connect is a facade over connectAdvanced. It turns its args into a compatible</span></span><br><span class="line"><span class="comment">  selectorFactory, which has the signature:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (dispatch, options) =&gt; (nextState, nextOwnProps) =&gt; nextFinalProps</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  connect passes its args to connectAdvanced as options, which will in turn pass them to</span></span><br><span class="line"><span class="comment">  selectorFactory each time a Connect component instance is instantiated or hot reloaded.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  selectorFactory returns a final props selector from its mapStateToProps,</span></span><br><span class="line"><span class="comment">  mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,</span></span><br><span class="line"><span class="comment">  mergePropsFactories, and pure args.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  The resulting final props selector is called by the Connect component instance whenever</span></span><br><span class="line"><span class="comment">  it receives new props or store state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">match</span>(<span class="params">arg, factories, name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 依次执行函数，直到有一个返回结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = factories.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = factories[i](arg);</span><br><span class="line">        <span class="keyword">if</span> (result) <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, options</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">            <span class="string">`Invalid value of type <span class="subst">$&#123;<span class="keyword">typeof</span> arg&#125;</span> for <span class="subst">$&#123;name&#125;</span> argument when connecting component <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">                options.wrappedComponentName</span></span></span><br><span class="line"><span class="string"><span class="subst">            &#125;</span>.`</span>,</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strictEqual</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a === b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// createConnect with default args builds the &#x27;official&#x27; connect behavior. Calling it with</span></span><br><span class="line"><span class="comment">// different options opens up some testing and extensibility scenarios</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createConnect</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    connectHOC = connectAdvanced,</span></span></span><br><span class="line"><span class="function"><span class="params">    mapStateToPropsFactories = defaultMapStateToPropsFactories,</span></span></span><br><span class="line"><span class="function"><span class="params">    mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories,</span></span></span><br><span class="line"><span class="function"><span class="params">    mergePropsFactories = defaultMergePropsFactories,</span></span></span><br><span class="line"><span class="function"><span class="params">    selectorFactory = defaultSelectorFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 用户传递的参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        mapStateToProps,</span></span></span><br><span class="line"><span class="function"><span class="params">        mapDispatchToProps,</span></span></span><br><span class="line"><span class="function"><span class="params">        mergeProps,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="regexp">//</span> 比较方法</span></span></span><br><span class="line"><span class="function"><span class="params">        &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            pure = true,</span></span></span><br><span class="line"><span class="function"><span class="params">            areStatesEqual = strictEqual,</span></span></span><br><span class="line"><span class="function"><span class="params">            areOwnPropsEqual = shallowEqual,</span></span></span><br><span class="line"><span class="function"><span class="params">            areStatePropsEqual = shallowEqual,</span></span></span><br><span class="line"><span class="function"><span class="params">            areMergedPropsEqual = shallowEqual,</span></span></span><br><span class="line"><span class="function"><span class="params">            ...extraOptions</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 返回一个函数</span></span><br><span class="line">        <span class="keyword">const</span> initMapStateToProps = match(</span><br><span class="line">            <span class="comment">// mapStateToProps作为参数放到mapStateToPropsFactories[]执行，第三个是报错用</span></span><br><span class="line">            mapStateToProps,</span><br><span class="line">            mapStateToPropsFactories,</span><br><span class="line">            <span class="string">&#x27;mapStateToProps&#x27;</span>,</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 返回一个函数</span></span><br><span class="line">        <span class="keyword">const</span> initMapDispatchToProps = match(</span><br><span class="line">            mapDispatchToProps,</span><br><span class="line">            mapDispatchToPropsFactories,</span><br><span class="line">            <span class="string">&#x27;mapDispatchToProps&#x27;</span>,</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 返回一个函数</span></span><br><span class="line">        <span class="keyword">const</span> initMergeProps = match(mergeProps, mergePropsFactories, <span class="string">&#x27;mergeProps&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 见connectAdvanced.md</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> connectHOC(selectorFactory, &#123;</span><br><span class="line">            <span class="comment">// used in error messages</span></span><br><span class="line">            <span class="comment">// 用于错误消息</span></span><br><span class="line">            methodName: <span class="string">&#x27;connect&#x27;</span>,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// used to compute Connect&#x27;s displayName from the wrapped component&#x27;s displayName.</span></span><br><span class="line">            getDisplayName: <span class="function">(<span class="params">name</span>) =&gt;</span> <span class="string">`Connect(<span class="subst">$&#123;name&#125;</span>)`</span>,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if mapStateToProps is falsy, the Connect component doesn&#x27;t subscribe to store state changes</span></span><br><span class="line">            shouldHandleStateChanges: <span class="built_in">Boolean</span>(mapStateToProps),</span><br><span class="line"></span><br><span class="line">            <span class="comment">// passed through to selectorFactory</span></span><br><span class="line">            initMapStateToProps,</span><br><span class="line">            initMapDispatchToProps,</span><br><span class="line">            initMergeProps,</span><br><span class="line">            pure,</span><br><span class="line">            areStatesEqual,</span><br><span class="line">            areOwnPropsEqual,</span><br><span class="line">            areStatePropsEqual,</span><br><span class="line">            areMergedPropsEqual,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// any extra options args can override defaults of connect or connectAdvanced</span></span><br><span class="line">            ...extraOptions,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createConnect();</span><br></pre></td></tr></table></figure>

<p>直接执行了<code>createConnect</code>,参数都取默认的</p>
<h3 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps"></a>mapStateToProps</h3><p>判断用户的传递参数，对不同传递参数返回对应的结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当函数的时候</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">whenMapStateToPropsIsFunction</span>(<span class="params">mapStateToProps</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> mapStateToProps === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">        ? wrapMapToPropsFunc(mapStateToProps, <span class="string">&#x27;mapStateToProps&#x27;</span>)</span><br><span class="line">        : <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当不传的时候</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">whenMapStateToPropsIsMissing</span>(<span class="params">mapStateToProps</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !mapStateToProps ? wrapMapToPropsConstant(<span class="function">() =&gt;</span> (&#123;&#125;)) : <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];</span><br></pre></td></tr></table></figure>

<h3 id="wrapMapToProps"><a href="#wrapMapToProps" class="headerlink" title="wrapMapToProps"></a>wrapMapToProps</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">wrapMapToPropsConstant</span>(<span class="params">getConstant</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">initConstantSelector</span>(<span class="params">dispatch, options</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> constant = getConstant(dispatch, options);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">constantSelector</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> constant;</span><br><span class="line">        &#125;</span><br><span class="line">        constantSelector.dependsOnOwnProps = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> constantSelector;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args</span></span><br><span class="line"><span class="comment">// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine</span></span><br><span class="line"><span class="comment">// whether mapToProps needs to be invoked when props have changed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A length of one signals that mapToProps does not depend on props from the parent component.</span></span><br><span class="line"><span class="comment">// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and</span></span><br><span class="line"><span class="comment">// therefore not reporting its length accurately..</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getDependsOnOwnProps</span>(<span class="params">mapToProps</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapToProps.dependsOnOwnProps !== <span class="literal">null</span> &amp;&amp; mapToProps.dependsOnOwnProps !== <span class="literal">undefined</span></span><br><span class="line">        ? <span class="built_in">Boolean</span>(mapToProps.dependsOnOwnProps)</span><br><span class="line">        : mapToProps.length !== <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,</span></span><br><span class="line"><span class="comment">// this function wraps mapToProps in a proxy function which does several things:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  * Detects whether the mapToProps function being called depends on props, which</span></span><br><span class="line"><span class="comment">//    is used by selectorFactory to decide if it should reinvoke on props changes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  * On first call, handles mapToProps if returns another function, and treats that</span></span><br><span class="line"><span class="comment">//    new function as the true mapToProps for subsequent calls.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  * On first call, verifies the first result is a plain object, in order to warn</span></span><br><span class="line"><span class="comment">//    the developer that their mapToProps function is not returning a valid result.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">wrapMapToPropsFunc</span>(<span class="params">mapToProps, methodName</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// mapToProps是用户在connect传进来的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">initProxySelector</span>(<span class="params">dispatch, &#123;displayName&#125;</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> proxy = <span class="function"><span class="keyword">function</span> <span class="title">mapToPropsProxy</span>(<span class="params">stateOrDispatch, ownProps</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// state或dispatch</span></span><br><span class="line">            <span class="keyword">return</span> proxy.dependsOnOwnProps</span><br><span class="line">                ? proxy.mapToProps(stateOrDispatch, ownProps)</span><br><span class="line">                : proxy.mapToProps(stateOrDispatch);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// allow detectFactoryAndVerify to get ownProps</span></span><br><span class="line">        proxy.dependsOnOwnProps = <span class="literal">true</span>; <span class="comment">// 是否依赖组件传进来的参数</span></span><br><span class="line"></span><br><span class="line">        proxy.mapToProps = <span class="function"><span class="keyword">function</span> <span class="title">detectFactoryAndVerify</span>(<span class="params">stateOrDispatch, ownProps</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 这里的 mapToProps 是用户传递的 conncet 的参数</span></span><br><span class="line">            proxy.mapToProps = mapToProps;</span><br><span class="line">            proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps); <span class="comment">// mapToProps的参数数量 !== 1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里执行第二遍proxy, 此时的mapToProps已经是用户传进来的mapToProps了，所以这里的返回对象是用户的返回</span></span><br><span class="line">            <span class="keyword">let</span> props = proxy(stateOrDispatch, ownProps);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果用户返回函数，就执行他</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> props === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                proxy.mapToProps = props;</span><br><span class="line">                proxy.dependsOnOwnProps = getDependsOnOwnProps(props);</span><br><span class="line">                props = proxy(stateOrDispatch, ownProps);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>)</span><br><span class="line">                verifyPlainObject(props, displayName, methodName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最后返回的用户返回的对象或者用户返回的函数的执行结果</span></span><br><span class="line">            <span class="keyword">return</span> props;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps"></a>mapDispatchToProps</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;bindActionCreators&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;wrapMapToPropsConstant, wrapMapToPropsFunc&#125; <span class="keyword">from</span> <span class="string">&#x27;./wrapMapToProps&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传了函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">whenMapDispatchToPropsIsFunction</span>(<span class="params">mapDispatchToProps</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> mapDispatchToProps === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">        ? wrapMapToPropsFunc(mapDispatchToProps, <span class="string">&#x27;mapDispatchToProps&#x27;</span>)</span><br><span class="line">        : <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没穿</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">whenMapDispatchToPropsIsMissing</span>(<span class="params">mapDispatchToProps</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !mapDispatchToProps ? wrapMapToPropsConstant(<span class="function">(<span class="params">dispatch</span>) =&gt;</span> (&#123;dispatch&#125;)) : <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传了对象</span></span><br><span class="line"><span class="comment">// 这里mapDispatchToProps即action合集</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">whenMapDispatchToPropsIsObject</span>(<span class="params">mapDispatchToProps</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapDispatchToProps &amp;&amp; <span class="keyword">typeof</span> mapDispatchToProps === <span class="string">&#x27;object&#x27;</span></span><br><span class="line">        ? wrapMapToPropsConstant(<span class="function">(<span class="params">dispatch</span>) =&gt;</span> bindActionCreators(mapDispatchToProps, dispatch))</span><br><span class="line">        : <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">    whenMapDispatchToPropsIsFunction,</span><br><span class="line">    whenMapDispatchToPropsIsMissing,</span><br><span class="line">    whenMapDispatchToPropsIsObject,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h3 id="mergeProps"><a href="#mergeProps" class="headerlink" title="mergeProps"></a>mergeProps</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defaultMergeProps</span>(<span class="params">stateProps, dispatchProps, ownProps</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;...ownProps, ...stateProps, ...dispatchProps&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">wrapMergePropsFunc</span>(<span class="params">mergeProps</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">initMergePropsProxy</span>(<span class="params">dispatch, &#123;displayName, pure, areMergedPropsEqual&#125;</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> hasRunOnce = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> mergedProps;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">mergePropsProxy</span>(<span class="params">stateProps, dispatchProps, ownProps</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hasRunOnce) &#123;</span><br><span class="line">                <span class="comment">// 后续</span></span><br><span class="line">                <span class="comment">// pure下才去比较</span></span><br><span class="line">                <span class="keyword">if</span> (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps))</span><br><span class="line">                    <span class="comment">// 浅层比较新旧</span></span><br><span class="line">                    mergedProps = nextMergedProps;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 第一次</span></span><br><span class="line">                hasRunOnce = <span class="literal">true</span>;</span><br><span class="line">                mergedProps = nextMergedProps;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>)</span><br><span class="line">                    verifyPlainObject(mergedProps, displayName, <span class="string">&#x27;mergeProps&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> mergedProps;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传了函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">whenMergePropsIsFunction</span>(<span class="params">mergeProps</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> mergeProps === <span class="string">&#x27;function&#x27;</span> ? wrapMergePropsFunc(mergeProps) : <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没传直接合并3个参数&#123;...,...,...&#125;</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">whenMergePropsIsOmitted</span>(<span class="params">mergeProps</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !mergeProps ? <span class="function">() =&gt;</span> defaultMergeProps : <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [whenMergePropsIsFunction, whenMergePropsIsOmitted];</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react-redux</tag>
      </tags>
  </entry>
  <entry>
    <title>时间</title>
    <url>/my-notes/2020/09/08/react/%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">requestCurrentTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// executionContext是否是RenderContext 或 CommitContext</span></span><br><span class="line">    <span class="keyword">if</span> ((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) &#123;</span><br><span class="line">        <span class="comment">// We&#x27;re inside React, so it&#x27;s fine to read the actual time.</span></span><br><span class="line">        <span class="keyword">return</span> msToExpirationTime(now());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We&#x27;re not inside React, so we may be in the middle of a browser event.</span></span><br><span class="line">    <span class="keyword">if</span> (currentEventTime !== NoWork) &#123;</span><br><span class="line">        <span class="comment">// Use the same start time for all updates until we enter React again.</span></span><br><span class="line">        <span class="keyword">return</span> currentEventTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// This is the first update since React yielded. Compute a new start time.</span></span><br><span class="line">    <span class="comment">// react执行的第一次更新，计算一个新的时间</span></span><br><span class="line">    <span class="comment">// now = 当前performance.now() - 文件加载时的performance.now()的时间差，就是文件加载时到执行这里的时间差</span></span><br><span class="line">    currentEventTime = msToExpirationTime(now());</span><br><span class="line">    <span class="keyword">return</span> currentEventTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>createStore</title>
    <url>/my-notes/2020/09/14/react-redux/createStore/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a Redux store that holds the state tree.</span></span><br><span class="line"><span class="comment"> * The only way to change the data in the store is to call `dispatch()` on it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There should only be a single store in your app. To specify how different</span></span><br><span class="line"><span class="comment"> * parts of the state tree respond to actions, you may combine several reducers</span></span><br><span class="line"><span class="comment"> * into a single reducer function by using `combineReducers`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>reducer A function that returns the next state tree, given</span></span><br><span class="line"><span class="comment"> * the current state tree and the action to handle.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span> </span>[preloadedState] The initial state. You may optionally specify it</span></span><br><span class="line"><span class="comment"> * to hydrate the state from the server in universal apps, or to restore a</span></span><br><span class="line"><span class="comment"> * previously serialized user session.</span></span><br><span class="line"><span class="comment"> * If you use `combineReducers` to produce the root reducer function, this must be</span></span><br><span class="line"><span class="comment"> * an object with the same shape as `combineReducers` keys.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>[enhancer] The store enhancer. You may optionally specify it</span></span><br><span class="line"><span class="comment"> * to enhance the store with third-party capabilities such as middleware,</span></span><br><span class="line"><span class="comment"> * time travel, persistence, etc. The only store enhancer that ships with Redux</span></span><br><span class="line"><span class="comment"> * is `applyMiddleware()`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Store&#125;</span> </span>A Redux store that lets you read the state, dispatch actions</span></span><br><span class="line"><span class="comment"> * and subscribe to changes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 类型不对，报错</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        (<span class="keyword">typeof</span> preloadedState === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">&#x27;function&#x27;</span>) ||</span><br><span class="line">        (<span class="keyword">typeof</span> enhancer === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">3</span>] === <span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">            <span class="string">&#x27;It looks like you are passing several store enhancers to &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;createStore(). This is not supported. Instead, compose them &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;together to a single function&#x27;</span>,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以不传preloadedState反而传enhancer（单独省略第二个参数）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadedState === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        enhancer = preloadedState;</span><br><span class="line">        preloadedState = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Expected the enhancer to be a function.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> reducer !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Expected the reducer to be a function.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> currentReducer = reducer;</span><br><span class="line">    <span class="keyword">let</span> currentState = preloadedState;</span><br><span class="line">    <span class="keyword">let</span> currentListeners = [];</span><br><span class="line">    <span class="keyword">let</span> nextListeners = currentListeners;</span><br><span class="line">    <span class="keyword">let</span> isDispatching = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相同就取一个备份</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ensureCanMutateNextListeners</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nextListeners === currentListeners) &#123;</span><br><span class="line">            nextListeners = currentListeners.slice();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads the state tree managed by the store.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns <span class="type">&#123;any&#125;</span> </span>The current state tree of your application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">                <span class="string">&#x27;You may not call store.getState() while the reducer is executing. &#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;The reducer has already received the state as an argument. &#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;Pass it down from the top reducer instead of reading it from the store.&#x27;</span>,</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds a change listener. It will be called any time an action is dispatched,</span></span><br><span class="line"><span class="comment">     * and some part of the state tree may potentially have changed. You may then</span></span><br><span class="line"><span class="comment">     * call `getState()` to read the current state tree inside the callback.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * You may call `dispatch()` from a change listener, with the following</span></span><br><span class="line"><span class="comment">     * caveats:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. The subscriptions are snapshotted just before every `dispatch()` call.</span></span><br><span class="line"><span class="comment">     * If you subscribe or unsubscribe while the listeners are being invoked, this</span></span><br><span class="line"><span class="comment">     * will not have any effect on the `dispatch()` that is currently in progress.</span></span><br><span class="line"><span class="comment">     * However, the next `dispatch()` call, whether nested or not, will use a more</span></span><br><span class="line"><span class="comment">     * recent snapshot of the subscription list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. The listener should not expect to see all state changes, as the state</span></span><br><span class="line"><span class="comment">     * might have been updated multiple times during a nested `dispatch()` before</span></span><br><span class="line"><span class="comment">     * the listener is called. It is, however, guaranteed that all subscribers</span></span><br><span class="line"><span class="comment">     * registered before the `dispatch()` started will be called with the latest</span></span><br><span class="line"><span class="comment">     * state by the time it exits.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>listener A callback to be invoked on every dispatch.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns <span class="type">&#123;Function&#125;</span> </span>A function to remove this change listener.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Expected the listener to be a function.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">                <span class="string">&#x27;You may not call store.subscribe() while the reducer is executing. &#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;If you would like to be notified after the store has been updated, subscribe from a &#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;component and invoke store.getState() in the callback to access the latest state. &#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;See https://redux.js.org/api-reference/store#subscribe(listener) for more details.&#x27;</span>,</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> isSubscribed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        ensureCanMutateNextListeners();</span><br><span class="line">        <span class="comment">// 添加监听函数</span></span><br><span class="line">        nextListeners.push(listener);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isSubscribed) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">                    <span class="string">&#x27;You may not unsubscribe from a store listener while the reducer is executing. &#x27;</span> +</span><br><span class="line">                        <span class="string">&#x27;See https://redux.js.org/api-reference/store#subscribe(listener) for more details.&#x27;</span>,</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            isSubscribed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            ensureCanMutateNextListeners();</span><br><span class="line">            <span class="keyword">const</span> index = nextListeners.indexOf(listener);</span><br><span class="line">            nextListeners.splice(index, <span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dispatches an action. It is the only way to trigger a state change.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The `reducer` function, used to create the store, will be called with the</span></span><br><span class="line"><span class="comment">     * current state tree and the given `action`. Its return value will</span></span><br><span class="line"><span class="comment">     * be considered the **next** state of the tree, and the change listeners</span></span><br><span class="line"><span class="comment">     * will be notified.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The base implementation only supports plain object actions. If you want to</span></span><br><span class="line"><span class="comment">     * dispatch a Promise, an Observable, a thunk, or something else, you need to</span></span><br><span class="line"><span class="comment">     * wrap your store creating function into the corresponding middleware. For</span></span><br><span class="line"><span class="comment">     * example, see the documentation for the `redux-thunk` package. Even the</span></span><br><span class="line"><span class="comment">     * middleware will eventually dispatch plain object actions using this method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>action A plain object representing “what changed”. It is</span></span><br><span class="line"><span class="comment">     * a good idea to keep actions serializable so you can record and replay user</span></span><br><span class="line"><span class="comment">     * sessions, or use the time travelling `redux-devtools`. An action must have</span></span><br><span class="line"><span class="comment">     * a `type` property which may not be `undefined`. It is a good idea to use</span></span><br><span class="line"><span class="comment">     * string constants for action types.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns <span class="type">&#123;Object&#125;</span> </span>For convenience, the same action object you dispatched.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that, if you use a custom middleware, it may wrap `dispatch()` to</span></span><br><span class="line"><span class="comment">     * return something else (for example, a Promise you can await).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">                <span class="string">&#x27;Actions must be plain objects. &#x27;</span> + <span class="string">&#x27;Use custom middleware for async actions.&#x27;</span>,</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> action.type === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">                <span class="string">&#x27;Actions may not have an undefined &quot;type&quot; property. &#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;Have you misspelled a constant?&#x27;</span>,</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Reducers may not dispatch actions.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isDispatching = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 用户自定义reducer方法</span></span><br><span class="line">            <span class="comment">// 初始化时action是react定义的一个变量，理论上是返回case default的数据,在这里就是preloadedState参数的值</span></span><br><span class="line">            <span class="comment">// 手动调用时就取用户期望的case</span></span><br><span class="line">            currentState = currentReducer(currentState, action);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            isDispatching = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化时就是空[]</span></span><br><span class="line">        <span class="keyword">const</span> listeners = (currentListeners = nextListeners);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> listener = listeners[i];</span><br><span class="line">            listener();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> action;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces the reducer currently used by the store to calculate the state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * You might need this if your app implements code splitting and you want to</span></span><br><span class="line"><span class="comment">     * load some of the reducers dynamically. You might also need this if you</span></span><br><span class="line"><span class="comment">     * implement a hot reloading mechanism for Redux.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>nextReducer The reducer for the store to use instead.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">replaceReducer</span>(<span class="params">nextReducer</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> nextReducer !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Expected the nextReducer to be a function.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currentReducer = nextReducer;</span><br><span class="line">        dispatch(&#123;<span class="attr">type</span>: ActionTypes.REPLACE&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Interoperability point for observable/reactive libraries.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns <span class="type">&#123;observable&#125;</span> </span>A minimal observable of state changes.</span></span><br><span class="line"><span class="comment">     * For more information, see the observable proposal:</span></span><br><span class="line"><span class="comment">     * https://github.com/tc39/proposal-observable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">observable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> outerSubscribe = subscribe;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * The minimal observable subscription method.</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>observer Any object that can be used as an observer.</span></span><br><span class="line"><span class="comment">             * The observer object should have a `next` method.</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@returns <span class="type">&#123;subscription&#125;</span> </span>An object with an `unsubscribe` method that can</span></span><br><span class="line"><span class="comment">             * be used to unsubscribe the observable from the store, and prevent further</span></span><br><span class="line"><span class="comment">             * emission of values from the observable.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            subscribe(observer) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> observer !== <span class="string">&#x27;object&#x27;</span> || observer === <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Expected the observer to be an object.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">observeState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (observer.next) &#123;</span><br><span class="line">                        observer.next(getState());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                observeState();</span><br><span class="line">                <span class="keyword">const</span> unsubscribe = outerSubscribe(observeState);</span><br><span class="line">                <span class="keyword">return</span> &#123;unsubscribe&#125;;</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            [$$observable]() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When a store is created, an &quot;INIT&quot; action is dispatched so that every</span></span><br><span class="line">    <span class="comment">// reducer returns their initial state. This effectively populates</span></span><br><span class="line">    <span class="comment">// the initial state tree.</span></span><br><span class="line">    <span class="comment">// 填充初始数据</span></span><br><span class="line">    dispatch(&#123;<span class="attr">type</span>: ActionTypes.INIT&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        dispatch,</span><br><span class="line">        subscribe,</span><br><span class="line">        getState,</span><br><span class="line">        replaceReducer,</span><br><span class="line">        [$$observable]: observable,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react-redux</tag>
      </tags>
  </entry>
  <entry>
    <title>selectorFactory</title>
    <url>/my-notes/2020/09/14/react-redux/selectorFactory/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> verifySubselectors <span class="keyword">from</span> <span class="string">&#x27;./verifySubselectors&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">impureFinalPropsSelectorFactory</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    mapStateToProps,</span></span></span><br><span class="line"><span class="function"><span class="params">    mapDispatchToProps,</span></span></span><br><span class="line"><span class="function"><span class="params">    mergeProps,</span></span></span><br><span class="line"><span class="function"><span class="params">    dispatch,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">impureFinalPropsSelector</span>(<span class="params">state, ownProps</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mergeProps(</span><br><span class="line">            mapStateToProps(state, ownProps),</span><br><span class="line">            mapDispatchToProps(dispatch, ownProps),</span><br><span class="line">            ownProps,</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pureFinalPropsSelectorFactory</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    mapStateToProps,</span></span></span><br><span class="line"><span class="function"><span class="params">    mapDispatchToProps,</span></span></span><br><span class="line"><span class="function"><span class="params">    mergeProps,</span></span></span><br><span class="line"><span class="function"><span class="params">    dispatch,</span></span></span><br><span class="line"><span class="function"><span class="params">    &#123;areStatesEqual, areOwnPropsEqual, areStatePropsEqual&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> hasRunAtLeastOnce = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> state;</span><br><span class="line">    <span class="keyword">let</span> ownProps;</span><br><span class="line">    <span class="keyword">let</span> stateProps;</span><br><span class="line">    <span class="keyword">let</span> dispatchProps;</span><br><span class="line">    <span class="keyword">let</span> mergedProps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数分别是当前store数据，父组件传递的props</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleFirstCall</span>(<span class="params">firstState, firstOwnProps</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 返回最终合并后的参数</span></span><br><span class="line">        state = firstState;</span><br><span class="line">        ownProps = firstOwnProps;</span><br><span class="line">        <span class="comment">// 这里执行的 connect.md proxy，最终也是用户的 renturn 结果</span></span><br><span class="line">        stateProps = mapStateToProps(state, ownProps);</span><br><span class="line">        dispatchProps = mapDispatchToProps(dispatch, ownProps);</span><br><span class="line">        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);</span><br><span class="line">        hasRunAtLeastOnce = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> mergedProps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleNewPropsAndNewState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 两个都不同</span></span><br><span class="line">        stateProps = mapStateToProps(state, ownProps);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mapDispatchToProps.dependsOnOwnProps)</span><br><span class="line">            dispatchProps = mapDispatchToProps(dispatch, ownProps);</span><br><span class="line"></span><br><span class="line">        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);</span><br><span class="line">        <span class="keyword">return</span> mergedProps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleNewProps</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// props不同看用户是否有用到第二个参数props,用到了就重新计算</span></span><br><span class="line">        <span class="keyword">if</span> (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mapDispatchToProps.dependsOnOwnProps)</span><br><span class="line">            dispatchProps = mapDispatchToProps(dispatch, ownProps);</span><br><span class="line"></span><br><span class="line">        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);</span><br><span class="line">        <span class="keyword">return</span> mergedProps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleNewState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 仅store变了</span></span><br><span class="line">        <span class="keyword">const</span> nextStateProps = mapStateToProps(state, ownProps);</span><br><span class="line">        <span class="keyword">const</span> statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps); <span class="comment">// 浅层比较新旧</span></span><br><span class="line">        stateProps = nextStateProps;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mergedProps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleSubsequentCalls</span>(<span class="params">nextState, nextOwnProps</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps); <span class="comment">// props浅比较</span></span><br><span class="line">        <span class="keyword">const</span> stateChanged = !areStatesEqual(nextState, state); <span class="comment">// store的值是全等比较</span></span><br><span class="line">        state = nextState;</span><br><span class="line">        ownProps = nextOwnProps;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (propsChanged &amp;&amp; stateChanged) <span class="keyword">return</span> handleNewPropsAndNewState();</span><br><span class="line">        <span class="keyword">if</span> (propsChanged) <span class="keyword">return</span> handleNewProps();</span><br><span class="line">        <span class="keyword">if</span> (stateChanged) <span class="keyword">return</span> handleNewState();</span><br><span class="line">        <span class="keyword">return</span> mergedProps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个参数分别是sotre.getState()和connect包裹组件的props</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">pureFinalPropsSelector</span>(<span class="params">nextState, nextOwnProps</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasRunAtLeastOnce <span class="comment">// 默认false</span></span><br><span class="line">            ? handleSubsequentCalls(nextState, nextOwnProps) <span class="comment">// 后续</span></span><br><span class="line">            : handleFirstCall(nextState, nextOwnProps); <span class="comment">// 首次</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Add more comments</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If pure is true, the selector returned by selectorFactory will memoize its results,</span></span><br><span class="line"><span class="comment">// allowing connectAdvanced&#x27;s shouldComponentUpdate to return false if final</span></span><br><span class="line"><span class="comment">// props have not changed. If false, the selector will always return a new</span></span><br><span class="line"><span class="comment">// object and shouldComponentUpdate will always return true.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">finalPropsSelectorFactory</span>(<span class="params"> <span class="regexp">//</span> 即selectorFactory</span></span></span><br><span class="line"><span class="function"><span class="params">    dispatch,</span></span></span><br><span class="line"><span class="function"><span class="params">    &#123;initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里执行的 wrapMapToProps 的 initProxySelector</span></span><br><span class="line">    <span class="comment">// 见 connect.md wrapMapToPropsFunc</span></span><br><span class="line">    <span class="keyword">const</span> mapStateToProps = initMapStateToProps(dispatch, options);</span><br><span class="line">    <span class="keyword">const</span> mapDispatchToProps = initMapDispatchToProps(dispatch, options);</span><br><span class="line">    <span class="keyword">const</span> mergeProps = initMergeProps(dispatch, options);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">        verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, options.displayName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> selectorFactory = options.pure <span class="comment">// pure才会去比较，不然全部都执行</span></span><br><span class="line">        ? pureFinalPropsSelectorFactory</span><br><span class="line">        : impureFinalPropsSelectorFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的还是一个函数</span></span><br><span class="line">    <span class="keyword">return</span> selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react-redux</tag>
      </tags>
  </entry>
  <entry>
    <title>流程</title>
    <url>/my-notes/2020/09/14/react-redux/%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>从 createStore 开始</p>
<p>见 <code>createStore.md</code>,返回了一个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    subscribe,</span><br><span class="line">    getState,</span><br><span class="line">    replaceReducer,</span><br><span class="line">    [$$observable]: observable,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用 Provider 传递 store</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">&lt;/Provider&gt;</span><br></pre></td></tr></table></figure>

<p>看 <code>Provider.md</code></p>
<h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><p>用 connect 高阶组件获取数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> TodoActionCreators <span class="keyword">from</span> <span class="string">&#x27;../context/action&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(state, props);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        todos: state,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// const mapDispatchToProps = (</span></span><br><span class="line"><span class="comment">//   dispatch,</span></span><br><span class="line"><span class="comment">// ) =&gt; bindActionCreators(TodoActionCreators, dispatch)</span></span><br><span class="line">@connect(mapStateToProps, TodoActionCreators)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">AAA</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>见 connect.md</p>
<h2 id="跟新"><a href="#跟新" class="headerlink" title="跟新"></a>跟新</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;ADD&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;...&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>就是<code>store.dispatch</code>,然后触发<code>onStateChange</code>方法，在<code>batchedUpdates</code>中跟新了数据，在<code>connect</code>中，contextValue 的改变触发了<code>checkForUpdates</code>里的<code>forceComponentUpdateDispatch</code>重新渲染</p>
<p>这里在不 debugger 代码的情况下还不是很清楚，感觉一下子会触发了好几种不同的方式去跟新页面</p>
]]></content>
      <tags>
        <tag>react-redux</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码阅读笔记（1）(从入口文件开始)</title>
    <url>/my-notes/2018/01/22/vue/1/</url>
    <content><![CDATA[<p>// 这是 vue 2.2.6 的源码阅读笔记</p>
<p><a href="https://github.com/liutao/vue2.0-source/blob/master/%E4%BB%8E%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8BVue%E6%BA%90%E7%A0%81.md">参考了的文章</a><br>以文章提供的思路自己过一遍代码</p>
<h2 id="先过一遍流程（文件加载顺序）"><a href="#先过一遍流程（文件加载顺序）" class="headerlink" title="先过一遍流程（文件加载顺序）"></a>先过一遍流程（文件加载顺序）</h2><p>按 npm run dev 的命令找来，文件执行顺序应该是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;src&#x2F;entries&#x2F;web-runtime-with-compiler.js   &#x2F;&#x2F; $mount二次加工</span><br><span class="line">--&gt; &#x2F;src&#x2F;entries&#x2F;web-runtime.js    &#x2F;&#x2F; 定义了Vue.config的一些方法、$mount、__patch__</span><br><span class="line">--&gt; &#x2F;src&#x2F;core&#x2F;index.js</span><br><span class="line">--&gt; &#x2F;src&#x2F;core&#x2F;instance&#x2F;index.js</span><br></pre></td></tr></table></figure>

<h3 id="src-core-index-js"><a href="#src-core-index-js" class="headerlink" title="/src/core/index.js"></a>/src/core/index.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;.&#x2F;instance&#x2F;index&#39;</span><br><span class="line">import &#123; initGlobalAPI &#125; from &#39;.&#x2F;global-api&#x2F;index&#39;</span><br><span class="line">import &#123; isServerRendering &#125; from &#39;core&#x2F;util&#x2F;env&#39;</span><br><span class="line"></span><br><span class="line">initGlobalAPI(Vue)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 环境判断 服务器or浏览器</span><br><span class="line">Object.defineProperty(Vue.prototype, &#39;$isServer&#39;, &#123;</span><br><span class="line">  get: isServerRendering</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.version &#x3D; &#39;__VERSION__&#39;</span><br><span class="line"></span><br><span class="line">export default Vue</span><br></pre></td></tr></table></figure>

<h3 id="src-core-instance-index-js"><a href="#src-core-instance-index-js" class="headerlink" title="/src/core/instance/index.js"></a>/src/core/instance/index.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;src&#x2F;core&#x2F;index.js</span><br><span class="line">--&gt; &#x2F;src&#x2F;core&#x2F;instance&#x2F;index.js</span><br></pre></td></tr></table></figure>

<p>这里是 vue 真正定义的地方</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Vue (options) &#123; &#x2F;&#x2F; vue定义的地方</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp;</span><br><span class="line">    !(this instanceof Vue)) &#123; &#x2F;&#x2F; 是不是new Vue()</span><br><span class="line">    warn(&#39;Vue is a constructor and should be called with the &#96;new&#96; keyword&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  this._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下面是给vue.prototype添加方法</span><br><span class="line">initMixin(Vue) &#x2F;&#x2F; _init</span><br><span class="line">stateMixin(Vue) &#x2F;&#x2F; $data、$props、 $set、$delete、$watch</span><br><span class="line">eventsMixin(Vue) &#x2F;&#x2F; $on、 $once、 $off、 $emit</span><br><span class="line">lifecycleMixin(Vue) &#x2F;&#x2F; _update、 $forceUpdate、 $destroy</span><br><span class="line">renderMixin(Vue) &#x2F;&#x2F; $nextTick、 _render、 一些绑在了prototype的内部方法</span><br></pre></td></tr></table></figure>

<h3 id="src-core-global-api-index-js"><a href="#src-core-global-api-index-js" class="headerlink" title="/src/core/global-api/index.js"></a>/src/core/global-api/index.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;src&#x2F;core&#x2F;index.js</span><br><span class="line">--&gt; &#x2F;src&#x2F;core&#x2F;global-api&#x2F;index.js</span><br></pre></td></tr></table></figure>

<p>这里添加了一些？vue 全局方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.defineProperty(Vue, &#39;config&#39;, configDef)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; exposed util methods.</span><br><span class="line">&#x2F;&#x2F; NOTE: these are not considered part of the public API - avoid relying on</span><br><span class="line">&#x2F;&#x2F; them unless you are aware of the risk.</span><br><span class="line">&#x2F;&#x2F; util方法虽然暴露出来了，但你最好不要使用(依赖)它，除非你知道他将会带来的风险（ps:我目前不知道）</span><br><span class="line">Vue.util &#x3D; &#123;</span><br><span class="line">  warn,</span><br><span class="line">  extend,</span><br><span class="line">  mergeOptions,</span><br><span class="line">  defineReactive</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.set &#x3D; set</span><br><span class="line">Vue.delete &#x3D; del</span><br><span class="line">Vue.nextTick &#x3D; nextTick</span><br><span class="line">Vue.options &#x3D; Object.create(null)</span><br><span class="line">config._assetTypes.forEach(type &#x3D;&gt; &#123;</span><br><span class="line">  Vue.options[type + &#39;s&#39;] &#x3D; Object.create(null)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; this is used to identify the &quot;base&quot; constructor to extend all plain-object</span><br><span class="line">&#x2F;&#x2F; components with in Weex&#39;s multi-instance scenarios. 为weex多实例方案？(这个应该是为weex服务的)</span><br><span class="line">Vue.options._base &#x3D; Vue</span><br><span class="line"></span><br><span class="line">initUse(Vue) &#x2F;&#x2F; Vue.use</span><br><span class="line">initMixin(Vue) &#x2F;&#x2F; Vue.mixin</span><br><span class="line">initExtend(Vue) &#x2F;&#x2F; Vue.extend</span><br><span class="line">initAssetRegisters(Vue) &#x2F;&#x2F; Vue[&#39;component&#39;]、Vue[&#39;directive&#39;]、Vue[&#39;filter&#39;]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码阅读笔记（3）(Vue的双向数据绑定)</title>
    <url>/my-notes/2018/01/23/vue/3/</url>
    <content><![CDATA[<p><a href="https://github.com/liutao/vue2.0-source/blob/master/%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.md">参考了的文章</a><br>以文章提供的思路自己过一遍代码</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>在 vue 的 created 生命周期之前，vue 对 data 进行了监听</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function initState (vm: Component) &#123;</span><br><span class="line">  vm._watchers &#x3D; []</span><br><span class="line">  const opts &#x3D; vm.$options</span><br><span class="line">  if (opts.props) initProps(vm, opts.props)</span><br><span class="line">  if (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  if (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    observe(vm._data &#x3D; &#123;&#125;, true &#x2F;* asRootData *&#x2F;)</span><br><span class="line">  &#125;</span><br><span class="line">  if (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  if (opts.watch) initWatch(vm, opts.watch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 initData 最后<br>调用 observe(data, true /_ asRootData _/)</p>
<p>src/core/observer/index.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Attempt to create an observer instance for a value,</span><br><span class="line"> * returns the new observer if successfully observed,</span><br><span class="line"> * or the existing observer if the value already has one.</span><br><span class="line"> * 给数据创建一个监听器实例</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function observe (value: any, asRootData: ?boolean): Observer | void &#123;</span><br><span class="line">  if (!isObject(value)) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  let ob: Observer | void</span><br><span class="line">  if (hasOwn(value, &#39;__ob__&#39;) &amp;&amp; value.__ob__ instanceof Observer) &#123;</span><br><span class="line">    ob &#x3D; value.__ob__</span><br><span class="line">  &#125; else if (</span><br><span class="line">    observerState.shouldConvert &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    Object.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    ob &#x3D; new Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  if (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++</span><br><span class="line">  &#125;</span><br><span class="line">  return ob</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">constructor (value: any) &#123;</span><br><span class="line">    this.value &#x3D; value</span><br><span class="line">    this.dep &#x3D; new Dep()</span><br><span class="line">    this.vmCount &#x3D; 0</span><br><span class="line">    def(value, &#39;__ob__&#39;, this)</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">      const augment &#x3D; hasProto</span><br><span class="line">        ? protoAugment</span><br><span class="line">        : copyAugment</span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line">      this.observeArray(value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  walk (obj: Object) &#123;</span><br><span class="line">    const keys &#x3D; Object.keys(obj)</span><br><span class="line">    for (let i &#x3D; 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i], obj[keys[i]])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line"> * Define a reactive property on an Object.</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function defineReactive (</span><br><span class="line">  obj: Object,</span><br><span class="line">  key: string,</span><br><span class="line">  val: any,</span><br><span class="line">  customSetter?: Function</span><br><span class="line">) &#123;</span><br><span class="line">  const dep &#x3D; new Dep()</span><br><span class="line"></span><br><span class="line">  const property &#x3D; Object.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  if (property &amp;&amp; property.configurable &#x3D;&#x3D;&#x3D; false) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; cater for pre-defined getter&#x2F;setters</span><br><span class="line">  const getter &#x3D; property &amp;&amp; property.get</span><br><span class="line">  const setter &#x3D; property &amp;&amp; property.set</span><br><span class="line"></span><br><span class="line">  let childOb &#x3D; observe(val)</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get: function reactiveGetter () &#123;</span><br><span class="line">      const value &#x3D; getter ? getter.call(obj) : val</span><br><span class="line">      if (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        if (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">        &#125;</span><br><span class="line">        if (Array.isArray(value)) &#123;</span><br><span class="line">          dependArray(value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function reactiveSetter (newVal) &#123;</span><br><span class="line">      const value &#x3D; getter ? getter.call(obj) : val</span><br><span class="line">      &#x2F;* eslint-disable no-self-compare *&#x2F;</span><br><span class="line">      if (newVal &#x3D;&#x3D;&#x3D; value || (newVal !&#x3D;&#x3D; newVal &amp;&amp; value !&#x3D;&#x3D; value)) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;* eslint-enable no-self-compare *&#x2F;</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      if (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        val &#x3D; newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb &#x3D; observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一步步看下来，最终在 defineReactive 函数里发现了对数据进行了 Object.defineProperty 操作。</p>
<p>之后在给 message 赋值的时候，触发了 get 函数<br>到这里，就需要先看一下 Dep 了，因为在这里使用到了 Dep.target</p>
<p>在代码执行到这里之前，及 Watcher.prototype.get 的时候，他调用了 pushTarget(this);（这里的 this 就是 Watcher）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function pushTarget (_target) &#123;</span><br><span class="line">  if (Dep.target) &#123; targetStack.push(Dep.target); &#125;</span><br><span class="line">  Dep.target &#x3D; _target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里把 Watcher 赋值给了 Dep.target，然后在 get 的时候把这个 Watcher 添加到了 Dep 的 subs 数组里面去了，当然在添加之前经过了判断，每个 Watcher 都对应有一个 id 的，不会重复添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addDep (dep: Dep) &#123;</span><br><span class="line">    const id &#x3D; dep.id</span><br><span class="line">    if (!this.newDepIds.has(id)) &#123;</span><br><span class="line">      this.newDepIds.add(id)</span><br><span class="line">      this.newDeps.push(dep)</span><br><span class="line">      if (!this.depIds.has(id)) &#123;</span><br><span class="line">        dep.addSub(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后在 set 的时候，会调用这个 subs 数组，Wacther 的 update 方法, 这里面一层层跟着运行，会发现他最后还是使用了下面的的更新方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">updateComponent &#x3D; function () &#123;</span><br><span class="line">  vm._update(vm._render(), hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个就是页面的跟新方法，只不过他其实是放在了一个异步方法里面执行，这里就暂不多做研究了，可以根据参考文章了解。</p>
<p>这里要说明一下，vue(应该)是一个组件(components)就只对应一个用来跟新页面的 Watcher，这个 Watcher 是 vue 自动创建的，所以按照这里的案例，会发现他的 subs 里面其实只有一个 Watcher,只要数据改变了，就会触发这个组件下的 vdom 重新更新，但是他依靠了 diff 算法，才实现的重用和部分更新。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>vue 双向绑定，分为 3 个部分<code>observe</code>, <code>watcher</code>, <code>dep</code></p>
<p>observe 用来监听数据，vue 会用递归的方式利用<code>object.defineProperty</code>对数据里面的所有值进行监听，对于数组，则会重写部分方法来实现监听。然后在 get 里面把一个 Watcher 放到 dep，set 的时候出发这个 watcher 列表</p>
<p>watcher 就是跟新函数，调用其中的一些方法，能更新页面</p>
<p>dep 是链接 observe 和 watcher 的桥梁，主要用来存放 watcher 列表</p>
]]></content>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>attr</title>
    <url>/my-notes/2018/06/07/vue/attr/</url>
    <content><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>在 parseHTML 首次处理(剩下的属性都在这个方法里进行了第一次处理)<br>代码在 vue/src/compiler/parser/index.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parseHTML(template, &#123;</span><br><span class="line">    ...</span><br><span class="line">    start(tag, attrs, unary) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 对element的其他属性做处理</span><br><span class="line">        processAttrs(element);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="processAttrs"><a href="#processAttrs" class="headerlink" title="processAttrs"></a>processAttrs</h2><p>代码在 vue/src/compiler/parser/index.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function processAttrs (el) &#123;</span><br><span class="line">  const list &#x3D; el.attrsList</span><br><span class="line">  let i, l, name, rawName, value, modifiers, isProp</span><br><span class="line">  for (i &#x3D; 0, l &#x3D; list.length; i &lt; l; i++) &#123;</span><br><span class="line">    name &#x3D; rawName &#x3D; list[i].name</span><br><span class="line">    value &#x3D; list[i].value</span><br><span class="line">    &#x2F;&#x2F; dirRE &#x2F;^v-|^@|^:&#x2F;</span><br><span class="line">    if (dirRE.test(name)) &#123;</span><br><span class="line">      &#x2F;&#x2F; mark element as dynamic</span><br><span class="line">      el.hasBindings &#x3D; true</span><br><span class="line">      &#x2F;&#x2F; modifiers</span><br><span class="line">      modifiers &#x3D; parseModifiers(name)</span><br><span class="line">      if (modifiers) &#123;</span><br><span class="line">        name &#x3D; name.replace(modifierRE, &#39;&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">      if (bindRE.test(name)) &#123; &#x2F;&#x2F; v-bind</span><br><span class="line">        name &#x3D; name.replace(bindRE, &#39;&#39;)</span><br><span class="line">        value &#x3D; parseFilters(value)</span><br><span class="line">        isProp &#x3D; false</span><br><span class="line">        if (modifiers) &#123;</span><br><span class="line">          if (modifiers.prop) &#123;</span><br><span class="line">            isProp &#x3D; true</span><br><span class="line">            name &#x3D; camelize(name)</span><br><span class="line">            if (name &#x3D;&#x3D;&#x3D; &#39;innerHtml&#39;) name &#x3D; &#39;innerHTML&#39;</span><br><span class="line">          &#125;</span><br><span class="line">          if (modifiers.camel) &#123;</span><br><span class="line">            name &#x3D; camelize(name)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) &#123;</span><br><span class="line">          addProp(el, name, value)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          addAttr(el, name, value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (onRE.test(name)) &#123; &#x2F;&#x2F; v-on</span><br><span class="line">        name &#x3D; name.replace(onRE, &#39;&#39;)</span><br><span class="line">        addHandler(el, name, value, modifiers)</span><br><span class="line">      &#125; else &#123; &#x2F;&#x2F; normal directives</span><br><span class="line">        name &#x3D; name.replace(dirRE, &#39;&#39;)</span><br><span class="line">        &#x2F;&#x2F; parse arg</span><br><span class="line">        const argMatch &#x3D; name.match(argRE)</span><br><span class="line">        const arg &#x3D; argMatch &amp;&amp; argMatch[1]</span><br><span class="line">        if (arg) &#123;</span><br><span class="line">          name &#x3D; name.slice(0, -(arg.length + 1))</span><br><span class="line">        &#125;</span><br><span class="line">        addDirective(el, name, rawName, value, arg, modifiers)</span><br><span class="line">        if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; name &#x3D;&#x3D;&#x3D; &#39;model&#39;) &#123;</span><br><span class="line">          checkForAliasModel(el, value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; literal attribute 普通属性</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">        const expression &#x3D; parseText(value, delimiters)</span><br><span class="line">        if (expression) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            &#96;$&#123;name&#125;&#x3D;&quot;$&#123;value&#125;&quot;: &#96; +</span><br><span class="line">            &#39;Interpolation inside attributes has been removed. &#39; +</span><br><span class="line">            &#39;Use v-bind or the colon shorthand instead. For example, &#39; +</span><br><span class="line">            &#39;instead of &lt;div id&#x3D;&quot;&#123;&#123; val &#125;&#125;&quot;&gt;, use &lt;div :id&#x3D;&quot;val&quot;&gt;.&#39;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      addAttr(el, name, JSON.stringify(value))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码阅读笔记 (class,style)</title>
    <url>/my-notes/2018/06/07/vue/class/</url>
    <content><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>在 parseHTML 首次处理 class,style<br>代码在 vue/src/compiler/parser/index.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parseHTML(template, &#123;</span><br><span class="line">    ...</span><br><span class="line">    start(tag, attrs, unary) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        for (let i &#x3D; 0; i &lt; transforms.length; i++) &#123;</span><br><span class="line">          transforms[i](element, options)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>transforms 里面包含了两个函数</p>
<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>src/platforms/web/compiler/modules/class.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function transformNode (el: ASTElement, options: CompilerOptions) &#123;</span><br><span class="line">  const warn &#x3D; options.warn || baseWarn</span><br><span class="line">  const staticClass &#x3D; getAndRemoveAttr(el, &#39;class&#39;) &#x2F;&#x2F; 获取class</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; staticClass) &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断class&#x3D;&quot;&#123;&#123;value&#125;&#125;&quot;这种情况</span><br><span class="line">    const expression &#x3D; parseText(staticClass, options.delimiters)</span><br><span class="line">    if (expression) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        &#96;class&#x3D;&quot;$&#123;staticClass&#125;&quot;: &#96; +</span><br><span class="line">        &#39;Interpolation inside attributes has been removed. &#39; +</span><br><span class="line">        &#39;Use v-bind or the colon shorthand instead. For example, &#39; +</span><br><span class="line">        &#39;instead of &lt;div class&#x3D;&quot;&#123;&#123; val &#125;&#125;&quot;&gt;, use &lt;div :class&#x3D;&quot;val&quot;&gt;.&#39;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 如果是静态class</span><br><span class="line">  if (staticClass) &#123;</span><br><span class="line">    el.staticClass &#x3D; JSON.stringify(staticClass)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 判断:class这种情况</span><br><span class="line">  const classBinding &#x3D; getBindingAttr(el, &#39;class&#39;, false &#x2F;* getStatic *&#x2F;)</span><br><span class="line">  if (classBinding) &#123;</span><br><span class="line">    el.classBinding &#x3D; classBinding</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;compiler&#x2F;helpers.js</span><br><span class="line">export function getBindingAttr (</span><br><span class="line">  el: ASTElement,</span><br><span class="line">  name: string,</span><br><span class="line">  getStatic?: boolean</span><br><span class="line">): ?string &#123;</span><br><span class="line">  const dynamicValue &#x3D;</span><br><span class="line">    getAndRemoveAttr(el, &#39;:&#39; + name) ||</span><br><span class="line">    getAndRemoveAttr(el, &#39;v-bind:&#39; + name)</span><br><span class="line">  if (dynamicValue !&#x3D; null) &#123;</span><br><span class="line">    return parseFilters(dynamicValue)</span><br><span class="line">  &#125; else if (getStatic !&#x3D;&#x3D; false) &#123;</span><br><span class="line">    const staticValue &#x3D; getAndRemoveAttr(el, name)</span><br><span class="line">    if (staticValue !&#x3D; null) &#123;</span><br><span class="line">      return JSON.stringify(staticValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; src&#x2F;compiler&#x2F;parser&#x2F;filter-parser.js</span><br><span class="line">export function parseFilters (exp: string): string &#123;</span><br><span class="line">  let inSingle &#x3D; false</span><br><span class="line">  let inDouble &#x3D; false</span><br><span class="line">  let inTemplateString &#x3D; false</span><br><span class="line">  let inRegex &#x3D; false</span><br><span class="line">  let curly &#x3D; 0</span><br><span class="line">  let square &#x3D; 0</span><br><span class="line">  let paren &#x3D; 0</span><br><span class="line">  let lastFilterIndex &#x3D; 0</span><br><span class="line">  let c, prev, i, expression, filters</span><br><span class="line"></span><br><span class="line">  for (i &#x3D; 0; i &lt; exp.length; i++) &#123;</span><br><span class="line">    prev &#x3D; c</span><br><span class="line">    c &#x3D; exp.charCodeAt(i)</span><br><span class="line">    if (inSingle) &#123;</span><br><span class="line">      &#x2F;&#x2F; 0x27 &#39;      0x5C \</span><br><span class="line">      if (c &#x3D;&#x3D;&#x3D; 0x27 &amp;&amp; prev !&#x3D;&#x3D; 0x5C) inSingle &#x3D; false</span><br><span class="line">    &#125; else if (inDouble) &#123;</span><br><span class="line">      &#x2F;&#x2F; 0x22 &quot;</span><br><span class="line">      if (c &#x3D;&#x3D;&#x3D; 0x22 &amp;&amp; prev !&#x3D;&#x3D; 0x5C) inDouble &#x3D; false</span><br><span class="line">    &#125; else if (inTemplateString) &#123;</span><br><span class="line">      &#x2F;&#x2F; 0x60 &#96;</span><br><span class="line">      if (c &#x3D;&#x3D;&#x3D; 0x60 &amp;&amp; prev !&#x3D;&#x3D; 0x5C) inTemplateString &#x3D; false</span><br><span class="line">    &#125; else if (inRegex) &#123;</span><br><span class="line">      &#x2F;&#x2F; 0x2f &#x2F;</span><br><span class="line">      if (c &#x3D;&#x3D;&#x3D; 0x2f &amp;&amp; prev !&#x3D;&#x3D; 0x5C) inRegex &#x3D; false</span><br><span class="line">    &#125; else if (</span><br><span class="line">      c &#x3D;&#x3D;&#x3D; 0x7C &amp;&amp; &#x2F;&#x2F; pipe  0x7C |</span><br><span class="line">      exp.charCodeAt(i + 1) !&#x3D;&#x3D; 0x7C &amp;&amp;</span><br><span class="line">      exp.charCodeAt(i - 1) !&#x3D;&#x3D; 0x7C &amp;&amp;</span><br><span class="line">      !curly &amp;&amp; !square &amp;&amp; !paren</span><br><span class="line">    ) &#123;</span><br><span class="line">      if (expression &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">        &#x2F;&#x2F; first filter, end of expression</span><br><span class="line">        lastFilterIndex &#x3D; i + 1</span><br><span class="line">        expression &#x3D; exp.slice(0, i).trim()</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        pushFilter()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      switch (c) &#123;</span><br><span class="line">        case 0x22: inDouble &#x3D; true; break         &#x2F;&#x2F; &quot;</span><br><span class="line">        case 0x27: inSingle &#x3D; true; break         &#x2F;&#x2F; &#39;</span><br><span class="line">        case 0x60: inTemplateString &#x3D; true; break &#x2F;&#x2F; &#96;</span><br><span class="line">        case 0x28: paren++; break                 &#x2F;&#x2F; (</span><br><span class="line">        case 0x29: paren--; break                 &#x2F;&#x2F; )</span><br><span class="line">        case 0x5B: square++; break                &#x2F;&#x2F; [</span><br><span class="line">        case 0x5D: square--; break                &#x2F;&#x2F; ]</span><br><span class="line">        case 0x7B: curly++; break                 &#x2F;&#x2F; &#123;</span><br><span class="line">        case 0x7D: curly--; break                 &#x2F;&#x2F; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (c &#x3D;&#x3D;&#x3D; 0x2f) &#123; &#x2F;&#x2F; &#x2F;</span><br><span class="line">        let j &#x3D; i - 1</span><br><span class="line">        let p</span><br><span class="line">        &#x2F;&#x2F; find first non-whitespace prev char</span><br><span class="line">        for (; j &gt;&#x3D; 0; j--) &#123;</span><br><span class="line">          p &#x3D; exp.charAt(j)</span><br><span class="line">          if (p !&#x3D;&#x3D; &#39; &#39;) break</span><br><span class="line">        &#125;</span><br><span class="line">        if (!p || !validDivisionCharRE.test(p)) &#123;</span><br><span class="line">          inRegex &#x3D; true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (expression &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">    expression &#x3D; exp.slice(0, i).trim()</span><br><span class="line">  &#125; else if (lastFilterIndex !&#x3D;&#x3D; 0) &#123;</span><br><span class="line">    pushFilter()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pushFilter () &#123;</span><br><span class="line">    (filters || (filters &#x3D; [])).push(exp.slice(lastFilterIndex, i).trim())</span><br><span class="line">    lastFilterIndex &#x3D; i + 1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (filters) &#123;</span><br><span class="line">    for (i &#x3D; 0; i &lt; filters.length; i++) &#123;</span><br><span class="line">      expression &#x3D; wrapFilter(expression, filters[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return expression</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="style"><a href="#style" class="headerlink" title="style"></a>style</h2><p>src/platforms/web/compiler/modules/style.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function transformNode (el: ASTElement, options: CompilerOptions) &#123;</span><br><span class="line">  const warn &#x3D; options.warn || baseWarn</span><br><span class="line">  const staticStyle &#x3D; getAndRemoveAttr(el, &#39;style&#39;) &#x2F;&#x2F; style</span><br><span class="line">  if (staticStyle) &#123;</span><br><span class="line">    &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      &#x2F;&#x2F; style&#x3D;&quot;&#123;&#123; val &#125;&#125;&quot; 情况</span><br><span class="line">      const expression &#x3D; parseText(staticStyle, options.delimiters)</span><br><span class="line">      if (expression) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#96;style&#x3D;&quot;$&#123;staticStyle&#125;&quot;: &#96; +</span><br><span class="line">          &#39;Interpolation inside attributes has been removed. &#39; +</span><br><span class="line">          &#39;Use v-bind or the colon shorthand instead. For example, &#39; +</span><br><span class="line">          &#39;instead of &lt;div style&#x3D;&quot;&#123;&#123; val &#125;&#125;&quot;&gt;, use &lt;div :style&#x3D;&quot;val&quot;&gt;.&#39;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    el.staticStyle &#x3D; JSON.stringify(parseStyleText(staticStyle))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const styleBinding &#x3D; getBindingAttr(el, &#39;style&#39;, false &#x2F;* getStatic *&#x2F;)</span><br><span class="line">  if (styleBinding) &#123;</span><br><span class="line">    el.styleBinding &#x3D; styleBinding</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>说明</title>
    <url>/my-notes/2018/01/22/vue/readme/</url>
    <content><![CDATA[<p>vue2.2.6 的源码阅读笔记</p>
<p>利用官方 vue 项目，配合 debugger 和 npm dev 命令，学习 vue 源码</p>
]]></content>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码阅读笔记 (v-if)</title>
    <url>/my-notes/2018/06/07/vue/v-if/</url>
    <content><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>在 parseHTML 首次处理 v-if<br>代码在 vue/src/compiler/parser/index.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parseHTML(template, &#123;</span><br><span class="line">    ...</span><br><span class="line">    start(tag, attrs, unary) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        processIf(element);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="processIf"><a href="#processIf" class="headerlink" title="processIf"></a>processIf</h2><p>代码在 vue/src/compiler/parser/index.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function processIf (el) &#123;</span><br><span class="line">  const exp &#x3D; getAndRemoveAttr(el, &#39;v-if&#39;)</span><br><span class="line">  if (exp) &#123;</span><br><span class="line">    el.if &#x3D; exp</span><br><span class="line">    addIfCondition(el, &#123;</span><br><span class="line">      exp: exp,</span><br><span class="line">      block: el</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (getAndRemoveAttr(el, &#39;v-else&#39;) !&#x3D; null) &#123;</span><br><span class="line">      el.else &#x3D; true</span><br><span class="line">    &#125;</span><br><span class="line">    const elseif &#x3D; getAndRemoveAttr(el, &#39;v-else-if&#39;)</span><br><span class="line">    if (elseif) &#123;</span><br><span class="line">      el.elseif &#x3D; elseif</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function addIfCondition (el, condition) &#123;</span><br><span class="line">  if (!el.ifConditions) &#123;</span><br><span class="line">    el.ifConditions &#x3D; []</span><br><span class="line">  &#125;</span><br><span class="line">  el.ifConditions.push(condition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>element 多几个属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element &#x3D; &#123;</span><br><span class="line">  ...</span><br><span class="line">  if:&quot;i % 2 &#x3D;&#x3D;&#x3D; 0&quot;,</span><br><span class="line">  ifConditions: [&#123;</span><br><span class="line">    block: el, &#x2F;&#x2F; 所在元素，就是element</span><br><span class="line">    exp: &quot;i % 2 &#x3D;&#x3D;&#x3D; 0&quot;</span><br><span class="line">  &#125;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未完待续</p>
]]></content>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码阅读笔记 (v-for)</title>
    <url>/my-notes/2018/06/07/vue/v-for/</url>
    <content><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>在 parseHTML 首次处理 v-for<br>代码在 vue/src/compiler/parser/index.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parseHTML(template, &#123;</span><br><span class="line">    ...</span><br><span class="line">    start(tag, attrs, unary) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        processFor(element);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="processFor"><a href="#processFor" class="headerlink" title="processFor"></a>processFor</h2><p>代码在 vue/src/compiler/parser/index.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function processFor (el) &#123;</span><br><span class="line">  let exp</span><br><span class="line">  if ((exp &#x3D; getAndRemoveAttr(el, &#39;v-for&#39;))) &#123;</span><br><span class="line">    &#x2F;&#x2F; forAliasRE &#x2F;(.*?)\s+(?:in|of)\s+(.*)&#x2F; 匹配 * in或者of *</span><br><span class="line">    const inMatch &#x3D; exp.match(forAliasRE)</span><br><span class="line">    if (!inMatch) &#123;</span><br><span class="line">      process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; warn(</span><br><span class="line">        &#96;Invalid v-for expression: $&#123;exp&#125;&#96;</span><br><span class="line">      )</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    el.for &#x3D; inMatch[2].trim() &#x2F;&#x2F; i in 9里面的 9</span><br><span class="line">    const alias &#x3D; inMatch[1].trim() &#x2F;&#x2F; i in 9里面的 i</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; forIteratorRE &#x2F;\((\&#123;[^&#125;]*\&#125;|[^,]*),([^,]*)(?:,([^,]*))?\)&#x2F;</span><br><span class="line">    const iteratorMatch &#x3D; alias.match(forIteratorRE)</span><br><span class="line">    if (iteratorMatch) &#123;</span><br><span class="line">      el.alias &#x3D; iteratorMatch[1].trim() &#x2F;&#x2F; i</span><br><span class="line">      el.iterator1 &#x3D; iteratorMatch[2].trim() &#x2F;&#x2F; 第二个参数</span><br><span class="line">      if (iteratorMatch[3]) &#123;</span><br><span class="line">        el.iterator2 &#x3D; iteratorMatch[3].trim() &#x2F;&#x2F; 对象遍历可带第三个参数</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      el.alias &#x3D; alias</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>element 多几个属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element &#x3D; &#123;</span><br><span class="line">  ...</span><br><span class="line">  alias:&quot;i&quot;,</span><br><span class="line">  for:&quot;9&quot;,</span><br><span class="line">  iterator1:&quot;index&quot; &#x2F;&#x2F; 可能有</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="processKey"><a href="#processKey" class="headerlink" title="processKey"></a>processKey</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function processKey (el) &#123;</span><br><span class="line">  const exp &#x3D; getBindingAttr(el, &#39;key&#39;)</span><br><span class="line">  if (exp) &#123;</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; el.tag &#x3D;&#x3D;&#x3D; &#39;template&#39;) &#123;</span><br><span class="line">      &#x2F;&#x2F; template不能加key</span><br><span class="line">      warn(&#96;&lt;template&gt; cannot be keyed. Place the key on real elements instead.&#96;)</span><br><span class="line">    &#125;</span><br><span class="line">    el.key &#x3D; exp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">element &#x3D; &#123;</span><br><span class="line">  ...</span><br><span class="line">  key:&quot;i&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未完待续</p>
]]></content>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/my-notes/2019/07/10/%E7%AE%97%E6%B3%95/01.%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function less (a, b) &#123;</span><br><span class="line">    return a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function exch (arr, i ,j) &#123;</span><br><span class="line">    const cah &#x3D; arr[i];</span><br><span class="line">    arr[i] &#x3D; arr[j];</span><br><span class="line">    arr[j] &#x3D; cah;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isSorted (arr) &#123;</span><br><span class="line">    for (let i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (less(arr[i], arr[i - 1])) return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function shuffle(array) &#123;</span><br><span class="line">  var _array &#x3D; array.concat();</span><br><span class="line"></span><br><span class="line">  for (var i &#x3D; _array.length; i--; ) &#123;</span><br><span class="line">    var j &#x3D; Math.floor(Math.random() * (i + 1));</span><br><span class="line">    var temp &#x3D; _array[i];</span><br><span class="line">    _array[i] &#x3D; _array[j];</span><br><span class="line">    _array[j] &#x3D; temp;</span><br><span class="line">  &#125;</span><br><span class="line">  return _array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function time(fn, name) &#123;</span><br><span class="line">    var d1 &#x3D; new Date();</span><br><span class="line">    fn();</span><br><span class="line">    var d2 &#x3D; new Date();</span><br><span class="line">    console.log(name, parseInt(d2 - d1) &#x2F; 1000);&#x2F;&#x2F;两个时间相差的秒数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初级排序算法"><a href="#初级排序算法" class="headerlink" title="初级排序算法"></a>初级排序算法</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>找到数组中最小的数，和第一个交换。以此类推</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sort1(arr) &#123;</span><br><span class="line">    const len &#x3D; arr.length;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">        let min &#x3D; i;</span><br><span class="line">        for (let j &#x3D; i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            if (less(arr[j], arr[min])) &#123;</span><br><span class="line">                min &#x3D; j;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(arr, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间固定</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>第 n 个数依次和前面的交换，直到大于前面的数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sort2(arr) &#123;</span><br><span class="line">    for (let j &#x3D; 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">        let key &#x3D; arr[j];</span><br><span class="line">        let i &#x3D; j - 1;</span><br><span class="line">        while(i &gt;&#x3D; 0 &amp;&amp; arr[i] &gt; key) &#123;</span><br><span class="line">            arr[i + 1] &#x3D; arr[i];</span><br><span class="line">            i &#x3D; i - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i + 1] &#x3D; key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入排序对于部分有序的数组十分高效，也很适合小规模数组。时间上期望二分之选择排序</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sort3(arr) &#123; &#x2F;&#x2F; 将a[]按升序排列</span><br><span class="line">    const N &#x3D; arr.length;</span><br><span class="line">    let h &#x3D; 1;</span><br><span class="line">    while (h &lt; N&#x2F;3) h &#x3D; 3*h + 1; &#x2F;&#x2F; 1, 4, 13, 40, 121, 364, 1093, ...</span><br><span class="line">    while (h &gt;&#x3D; 1) &#123; &#x2F;&#x2F; 将数组变为h有序</span><br><span class="line">        for (let i &#x3D; h; i &lt; N; i++)&#123;</span><br><span class="line">            for (int j &#x3D; i; j &gt;&#x3D; h &amp;&amp; less(a[j], a[j-h]); j -&#x3D; h) &#123;</span><br><span class="line">                exch(a, j, j-h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    h &#x3D; h&#x2F;3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5000 数据以上明显比上面的快</p>
]]></content>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>一些笔记</title>
    <url>/my-notes/2017/06/02/%E9%9A%8F%E8%AE%B0/1/</url>
    <content><![CDATA[<h2 id="《你不知道的javascript》-中-笔记"><a href="#《你不知道的javascript》-中-笔记" class="headerlink" title="《你不知道的javascript》(中) 笔记"></a>《你不知道的javascript》(中) 笔记</h2><ol>
<li><p>undefined 和 undeclared是两码事</p>
</li>
<li><p>通过typeof来检查变量是否存在, 还能够适应不同环境(不局限于浏览器)</p>
</li>
<li><p>数字用指数格式显示用toExponential()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; 5E10;</span><br><span class="line">a;                  &#x2F;* 50000000000 *&#x2F;</span><br><span class="line">a.toExponential();  &#x2F;* &quot;5e+10&quot; *&#x2F;</span><br><span class="line">var b &#x3D; a * a;</span><br><span class="line">b;                  &#x2F;* 2.5e+21 *&#x2F;</span><br><span class="line">var c &#x3D; 1 &#x2F; a;</span><br><span class="line">c;                  &#x2F;* 2e-11 *&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li><p>toPrecision(..) 方法用来指定有效数位的显示位数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; 42.59;</span><br><span class="line"></span><br><span class="line">a.toPrecision( 1 );  &#x2F;&#x2F; &quot;4e+1&quot;</span><br><span class="line">a.toPrecision( 2 );  &#x2F;&#x2F; &quot;43&quot;</span><br><span class="line">a.toPrecision( 3 );  &#x2F;&#x2F; &quot;42.6&quot;</span><br><span class="line">a.toPrecision( 4 );  &#x2F;&#x2F; &quot;42.59&quot;</span><br><span class="line">a.toPrecision( 5 );  &#x2F;&#x2F; &quot;42.590&quot;</span><br><span class="line">a.toPrecision( 6 );  &#x2F;&#x2F; &quot;42.5900&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>es6中, 可以使用 Number.EPSILON 来比较两个数字是否相等(在指定的误差范围内), 这个值(误差精度)通常是 2^-52 (2.220446049250313e-16)<br>从 ES6 开始，该值定义在 Number.EPSILON 中，我们可以直接拿来用，也可以为 ES6 之前<br>的版本写 polyfill:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!Number.EPSILON) &#123;</span><br><span class="line">  Number.EPSILON &#x3D; Math.pow(2,-52);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function numbersCloseEnoughToEqual(n1,n2) &#123;</span><br><span class="line">   return Math.abs( n1 - n2 ) &lt; Number.EPSILON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a &#x3D; 0.1 + 0.2;</span><br><span class="line">var b &#x3D; 0.3;</span><br><span class="line">numbersCloseEnoughToEqual( a, b );</span><br><span class="line">numbersCloseEnoughToEqual( 0.0000001, 0.0000002 );  &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
</li>
<li><p>按惯例我们用void 0来获得undefined, void 运算符在其他地方也能派上用场，比如不让表达式返回任何结果(即使其有副作用)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function doSomething() &#123;</span><br><span class="line">  &#x2F;&#x2F; 注:APP.ready 由程序自己定义 </span><br><span class="line">  if (!APP.ready) &#123;</span><br><span class="line">     &#x2F;&#x2F; 稍后再试</span><br><span class="line">     return void setTimeout( doSomething,100 );</span><br><span class="line">  &#125;</span><br><span class="line">  var result;</span><br><span class="line">  &#x2F;&#x2F; 其他</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br><span class="line">  &#x2F;&#x2F; 现在可以了吗?</span><br><span class="line">if (doSomething()) &#123;</span><br><span class="line">  &#x2F;&#x2F; 立即执行下一个任务 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将原型作为默认值<br>Function.prototype 是一个空函数，RegExp.prototype 是一个“空”的正则表达式(无任何匹配)，而 Array.prototype 是一个空数组。对未赋值的变量来说，它们是很好的默认值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isThisCool(vals,fn,rx) &#123;</span><br><span class="line">  vals &#x3D; vals || Array.prototype;</span><br><span class="line">  fn &#x3D; fn || Function.prototype;</span><br><span class="line">  rx &#x3D; rx || RegExp.prototype;</span><br><span class="line">  return rx.test(vals.map( fn ).join( &quot;&quot; )); </span><br><span class="line">&#125;</span><br><span class="line">isThisCool();       &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>这种方法的一个好处是 .prototypes 已被创建并且仅创建一次。相反，如果将 []、<br>function(){} 和 /(?:)/ 作为默认值，则每次调用 isThisCool(..) 时它们都会被创建一次 (具体创建与否取决于 JavaScript 引擎，稍后它们可能会被垃圾回收)，这样无疑会造成内<br>存和 CPU 资源的浪费。</p>
<ol start="8">
<li><p>JSON.stringify</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; &#123; </span><br><span class="line">  b: 42,</span><br><span class="line">  c: &quot;42&quot;,</span><br><span class="line">  d: [1,2,3]</span><br><span class="line">&#125;;</span><br><span class="line">JSON.stringify( a, [&quot;c&quot;,&quot;d&quot;], 3 );</span><br><span class="line">&quot;&#123;</span><br><span class="line">   &quot;c&quot;: &quot;42&quot;,</span><br><span class="line">   &quot;d&quot;: [</span><br><span class="line">      1,</span><br><span class="line">      2,</span><br><span class="line">      3</span><br><span class="line">   ]</span><br><span class="line">&#125;&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于<del>, 推荐在数据能控制在小范围的时候使用<br>一些开发人员使用 ~</del> 来截除数字值的小数部分，以为这和 Math.floor(..) 的效果一样， 实际上并非如此。<br>~~ 中的第一个 ~ 执行 ToInt32 并反转字位，然后第二个 ~ 再进行一次字位反转，即将所有字位反转回原值，最后得到的仍然是 ToInt32 的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~ (1e20)</span><br><span class="line">&#x2F;&#x2F;1661992960</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于 &lt;= 和 &gt;=<br>JavaScript 中 &lt;= 是“不大于”的意思(即 !(a &gt; b)，处理为 !(b &lt; a))。同理 a &gt;= b 处理为 b &lt;= a。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; &#123; b: 42 &#125;;</span><br><span class="line">var b &#x3D; &#123; b: 43 &#125;;</span><br><span class="line">a &lt; b;  &#x2F;&#x2F; false</span><br><span class="line">a &#x3D;&#x3D; b; &#x2F;&#x2F; false</span><br><span class="line">a &gt; b;  &#x2F;&#x2F; false</span><br><span class="line">a &lt;&#x3D; b; &#x2F;&#x2F; true</span><br><span class="line">a &gt;&#x3D; b; &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
</li>
<li><p>JavaScript 通过标签跳转能够实现 goto 的部分功能。continue 和 break 语句都可以带 一个标签，因此能够像 goto 那样进行跳转。例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 标签为foo的循环</span><br><span class="line">foo: for (var i&#x3D;0; i&lt;4; i++) &#123;</span><br><span class="line">  for (var j&#x3D;0; j&lt;4; j++) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果j和i相等，继续外层循环 </span><br><span class="line">    if (j &#x3D;&#x3D; i) &#123;</span><br><span class="line">      &#x2F;&#x2F; 跳转到foo的下一个循环</span><br><span class="line">      continue foo;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 跳过奇数结果</span><br><span class="line">    if ((j * i) % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">      &#x2F;&#x2F; 继续内层循环(没有标签的)</span><br><span class="line">      continue; </span><br><span class="line">    &#125;</span><br><span class="line">    console.log( i, j );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">      &#x2F;&#x2F; 1 0</span><br><span class="line">      &#x2F;&#x2F; 2 0</span><br><span class="line">      &#x2F;&#x2F; 2 1</span><br><span class="line">      &#x2F;&#x2F; 3 0</span><br><span class="line">      &#x2F;&#x2F; 3 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于html标签id, 会在js全局变量上创建一个与id同名的变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html</span><br><span class="line">&lt;div id&#x3D;&#39;foo&#39;&gt;&lt;&#x2F;div&gt; </span><br><span class="line"></span><br><span class="line">js</span><br><span class="line">console.log( foo ); &#x2F;&#x2F; HTML元素</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息是双向传递的——yield</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function *foo(x) &#123;</span><br><span class="line">    var y &#x3D; x * (yield &quot;Hello&quot;); &#x2F;&#x2F; &lt;-- yield一个值!</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br><span class="line">var it &#x3D; foo( 6 );</span><br><span class="line">var res &#x3D; it.next(); &#x2F;&#x2F; 第一个next()，并不传入任何东西</span><br><span class="line">res.value;  &#x2F;&#x2F; &quot;Hello&quot;</span><br><span class="line">res &#x3D; it.next( 7 ); &#x2F;&#x2F; 向等待的yield传入7</span><br><span class="line">res.value; &#x2F;&#x2F; 42</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
]]></content>
      <tags>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title>一些笔记</title>
    <url>/my-notes/2017/06/28/%E9%9A%8F%E8%AE%B0/2/</url>
    <content><![CDATA[<h2 id="一些项目经验"><a href="#一些项目经验" class="headerlink" title="一些项目经验"></a>一些项目经验</h2><ol>
<li>vue用cdn, 就不需要给其子组件(vuex, vue-router等)使用 Vue.use</li>
<li>toString.apply可以用于区分数据类型</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toString.apply([]) &#x2F;&#x2F; &#39;[object Array]&#39;</span><br><span class="line">toString.apply(&#x2F;aa&#x2F;) &#x2F;&#x2F; &quot;[object RegExp]&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>关于scroll进度条隐藏的小技巧</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">width: ? &#x2F;&#x2F; 父级宽度 + 20</span><br><span class="line">overflow-y: scroll;</span><br><span class="line">padding-right: 20px;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title>commitRoot</title>
    <url>/my-notes/2020/09/09/react/commitRoot/</url>
    <content><![CDATA[<h3 id="commitRoot"><a href="#commitRoot" class="headerlink" title="commitRoot"></a>commitRoot</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 开始渲染流程</span></span><br><span class="line">    <span class="comment">// debugger;</span></span><br><span class="line">    <span class="comment">// 优先级相关，最后还是运行commitRootImpl</span></span><br><span class="line">    runWithPriority(ImmediatePriority, commitRootImpl.bind(<span class="literal">null</span>, root)); <span class="comment">// 渲染并执行componentDidMount</span></span><br><span class="line">    <span class="comment">// If there are passive effects, schedule a callback to flush them. This goes</span></span><br><span class="line">    <span class="comment">// outside commitRootImpl so that it inherits the priority of the render.</span></span><br><span class="line">    <span class="keyword">if</span> (rootWithPendingPassiveEffects !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// debugger;</span></span><br><span class="line">        <span class="comment">// 这里是调度管理，先不看，直接进里面</span></span><br><span class="line">        <span class="keyword">const</span> priorityLevel = getCurrentPriorityLevel();</span><br><span class="line">        scheduleCallback(priorityLevel, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// hooks的useEffect在这里执行</span></span><br><span class="line">            flushPassiveEffects();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="commitRootImpl"><a href="#commitRootImpl" class="headerlink" title="commitRootImpl"></a>commitRootImpl</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRootImpl</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    flushPassiveEffects();</span><br><span class="line">    flushRenderPhaseStrictModeWarningsInDEV(); <span class="comment">// __DEV__</span></span><br><span class="line">    flushSuspensePriorityWarningInDEV(); <span class="comment">// __DEV__</span></span><br><span class="line"></span><br><span class="line">    invariant(</span><br><span class="line">        (executionContext &amp; (RenderContext | CommitContext)) === NoContext,</span><br><span class="line">        <span class="string">&#x27;Should not already be working.&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> finishedWork = root.finishedWork;</span><br><span class="line">    <span class="keyword">const</span> expirationTime = root.finishedExpirationTime;</span><br><span class="line">    <span class="keyword">if</span> (finishedWork === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    root.finishedWork = <span class="literal">null</span>;</span><br><span class="line">    root.finishedExpirationTime = NoWork;</span><br><span class="line"></span><br><span class="line">    invariant(</span><br><span class="line">        finishedWork !== root.current,</span><br><span class="line">        <span class="string">&#x27;Cannot commit the same tree as before. This error is likely caused by &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;a bug in React. Please file an issue.&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// commitRoot never returns a continuation; it always finishes synchronously.</span></span><br><span class="line">    <span class="comment">// So we can clear these now to allow a new callback to be scheduled.</span></span><br><span class="line">    root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    root.callbackExpirationTime = NoWork;</span><br><span class="line"></span><br><span class="line">    startCommitTimer(); <span class="comment">//  也算是__DEV__</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the first and last pending times on this root. The new first</span></span><br><span class="line">    <span class="comment">// pending time is whatever is left on the root fiber.</span></span><br><span class="line">    <span class="keyword">const</span> updateExpirationTimeBeforeCommit = finishedWork.expirationTime;</span><br><span class="line">    <span class="keyword">const</span> childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;</span><br><span class="line">    <span class="keyword">const</span> firstPendingTimeBeforeCommit =</span><br><span class="line">        childExpirationTimeBeforeCommit &gt; updateExpirationTimeBeforeCommit</span><br><span class="line">            ? childExpirationTimeBeforeCommit</span><br><span class="line">            : updateExpirationTimeBeforeCommit;</span><br><span class="line">    root.firstPendingTime = firstPendingTimeBeforeCommit;</span><br><span class="line">    <span class="keyword">if</span> (firstPendingTimeBeforeCommit &lt; root.lastPendingTime) &#123;</span><br><span class="line">        <span class="comment">// This usually means we&#x27;ve finished all the work, but it can also happen</span></span><br><span class="line">        <span class="comment">// when something gets downprioritized during render, like a hidden tree.</span></span><br><span class="line">        root.lastPendingTime = firstPendingTimeBeforeCommit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root === workInProgressRoot) &#123;</span><br><span class="line">        <span class="comment">// We can reset these now that they are finished.</span></span><br><span class="line">        workInProgressRoot = <span class="literal">null</span>;</span><br><span class="line">        workInProgress = <span class="literal">null</span>;</span><br><span class="line">        renderExpirationTime = NoWork;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 超时？这里复制过来就是没代码的，只有注释</span></span><br><span class="line">        <span class="comment">// This indicates that the last root we worked on is not the same one that</span></span><br><span class="line">        <span class="comment">// we&#x27;re committing now. This most commonly happens when a suspended root</span></span><br><span class="line">        <span class="comment">// times out.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the list of effects.</span></span><br><span class="line">    <span class="keyword">let</span> firstEffect;</span><br><span class="line">    <span class="keyword">if</span> (finishedWork.effectTag &gt; PerformedWork) &#123;</span><br><span class="line">        <span class="comment">// A fiber&#x27;s effect list consists only of its children, not itself. So if</span></span><br><span class="line">        <span class="comment">// the root has an effect, we need to add it to the end of the list. The</span></span><br><span class="line">        <span class="comment">// resulting list is the set that would belong to the root&#x27;s parent, if it</span></span><br><span class="line">        <span class="comment">// had one; that is, all the effects in the tree including the root.</span></span><br><span class="line">        <span class="keyword">if</span> (finishedWork.lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">            finishedWork.lastEffect.nextEffect = finishedWork;</span><br><span class="line">            firstEffect = finishedWork.firstEffect;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            firstEffect = finishedWork;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// There is no effect on the root.</span></span><br><span class="line">        firstEffect = finishedWork.firstEffect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (firstEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> prevExecutionContext = executionContext;</span><br><span class="line">        executionContext |= CommitContext;</span><br><span class="line">        <span class="keyword">let</span> prevInteractions: <span class="built_in">Set</span>&lt;Interaction&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (enableSchedulerTracing) &#123;</span><br><span class="line">            prevInteractions = __interactionsRef.current;</span><br><span class="line">            __interactionsRef.current = root.memoizedInteractions;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset this to null before calling lifecycles</span></span><br><span class="line">        ReactCurrentOwner.current = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The commit phase is broken into several sub-phases. We do a separate pass</span></span><br><span class="line">        <span class="comment">// of the effect list for each phase: all mutation effects come before all</span></span><br><span class="line">        <span class="comment">// layout effects, and so on.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// commit阶段</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// The first phase a &quot;before mutation&quot; phase. We use this phase to read the</span></span><br><span class="line">        <span class="comment">// state of the host tree right before we mutate it. This is where</span></span><br><span class="line">        <span class="comment">// getSnapshotBeforeUpdate is called.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个阶段，不知道在做什么，和snapshot有关</span></span><br><span class="line">        startCommitSnapshotEffectsTimer(); <span class="comment">// false</span></span><br><span class="line">        prepareForCommit(root.containerInfo); <span class="comment">// 准备</span></span><br><span class="line">        nextEffect = firstEffect;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    commitBeforeMutationEffects();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    invariant(nextEffect !== <span class="literal">null</span>, <span class="string">&#x27;Should be working on an effect.&#x27;</span>);</span><br><span class="line">                    captureCommitPhaseError(nextEffect, error);</span><br><span class="line">                    nextEffect = nextEffect.nextEffect;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>);</span><br><span class="line">        stopCommitSnapshotEffectsTimer(); <span class="comment">// false__DEV__</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enableProfilerTimer) &#123;</span><br><span class="line">            <span class="comment">// false</span></span><br><span class="line">            <span class="comment">// Mark the current commit time to be shared by all Profilers in this</span></span><br><span class="line">            <span class="comment">// batch. This enables them to be grouped later.</span></span><br><span class="line">            recordCommitTime();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The next phase is the mutation phase, where we mutate the host tree.</span></span><br><span class="line">        startCommitHostEffectsTimer(); <span class="comment">// false__DEV__</span></span><br><span class="line">        <span class="comment">// 第二个阶段</span></span><br><span class="line">        nextEffect = firstEffect;</span><br><span class="line">        <span class="comment">// debugger;</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    commitMutationEffects(); <span class="comment">// 渲染dom</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    invariant(nextEffect !== <span class="literal">null</span>, <span class="string">&#x27;Should be working on an effect.&#x27;</span>);</span><br><span class="line">                    captureCommitPhaseError(nextEffect, error);</span><br><span class="line">                    nextEffect = nextEffect.nextEffect;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>);</span><br><span class="line">        stopCommitHostEffectsTimer(); <span class="comment">// false</span></span><br><span class="line">        resetAfterCommit(root.containerInfo); <span class="comment">// 重置一些数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// The work-in-progress tree is now the current tree. This must come after</span></span><br><span class="line">        <span class="comment">// the mutation phase, so that the previous tree is still current during</span></span><br><span class="line">        <span class="comment">// componentWillUnmount, but before the layout phase, so that the finished</span></span><br><span class="line">        <span class="comment">// work is current during componentDidMount/Update.</span></span><br><span class="line">        root.current = finishedWork;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The next phase is the layout phase, where we call effects that read</span></span><br><span class="line">        <span class="comment">// the host tree after it&#x27;s been mutated. The idiomatic use case for this is</span></span><br><span class="line">        <span class="comment">// layout, but class component lifecycles also fire here for legacy reasons.</span></span><br><span class="line">        startCommitLifeCyclesTimer(); <span class="comment">// false</span></span><br><span class="line">        nextEffect = firstEffect;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// debugger</span></span><br><span class="line">                    <span class="comment">// 生命周期和ref</span></span><br><span class="line">                    commitLayoutEffects(root, expirationTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    invariant(nextEffect !== <span class="literal">null</span>, <span class="string">&#x27;Should be working on an effect.&#x27;</span>);</span><br><span class="line">                    captureCommitPhaseError(nextEffect, error);</span><br><span class="line">                    nextEffect = nextEffect.nextEffect;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>);</span><br><span class="line">        stopCommitLifeCyclesTimer(); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        nextEffect = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enableSchedulerTracing) &#123;</span><br><span class="line">            __interactionsRef.current = ((prevInteractions: any): <span class="built_in">Set</span>&lt;Interaction&gt;);</span><br><span class="line">        &#125;</span><br><span class="line">        executionContext = prevExecutionContext;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No effects.</span></span><br><span class="line">        root.current = finishedWork;</span><br><span class="line">        <span class="comment">// Measure these anyway so the flamegraph explicitly shows that there were</span></span><br><span class="line">        <span class="comment">// no effects.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Maybe there&#x27;s a better way to report this.</span></span><br><span class="line">        startCommitSnapshotEffectsTimer();</span><br><span class="line">        stopCommitSnapshotEffectsTimer();</span><br><span class="line">        <span class="keyword">if</span> (enableProfilerTimer) &#123;</span><br><span class="line">            recordCommitTime();</span><br><span class="line">        &#125;</span><br><span class="line">        startCommitHostEffectsTimer();</span><br><span class="line">        stopCommitHostEffectsTimer();</span><br><span class="line">        startCommitLifeCyclesTimer();</span><br><span class="line">        stopCommitLifeCyclesTimer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stopCommitTimer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> rootDidHavePassiveEffects = rootDoesHavePassiveEffects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rootDoesHavePassiveEffects) &#123;</span><br><span class="line">        <span class="comment">// This commit has passive effects. Stash a reference to them. But don&#x27;t</span></span><br><span class="line">        <span class="comment">// schedule a callback until after flushing layout work.</span></span><br><span class="line">        rootDoesHavePassiveEffects = <span class="literal">false</span>;</span><br><span class="line">        rootWithPendingPassiveEffects = root;</span><br><span class="line">        pendingPassiveEffectsExpirationTime = expirationTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if there&#x27;s remaining work on this root</span></span><br><span class="line">    <span class="keyword">const</span> remainingExpirationTime = root.firstPendingTime;</span><br><span class="line">    <span class="keyword">if</span> (remainingExpirationTime !== NoWork) &#123;</span><br><span class="line">        <span class="keyword">const</span> currentTime = requestCurrentTime();</span><br><span class="line">        <span class="keyword">const</span> priorityLevel = inferPriorityFromExpirationTime(currentTime, remainingExpirationTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enableSchedulerTracing) &#123;</span><br><span class="line">            <span class="keyword">if</span> (didDeprioritizeIdleSubtree) &#123;</span><br><span class="line">                didDeprioritizeIdleSubtree = <span class="literal">false</span>;</span><br><span class="line">                scheduleInteractions(root, Never, root.memoizedInteractions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这, DidMount已执行</span></span><br><span class="line">        <span class="comment">// debugger;</span></span><br><span class="line">        scheduleCallbackForRoot(root, priorityLevel, remainingExpirationTime);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If there&#x27;s no remaining work, we can clear the set of already failed</span></span><br><span class="line">        <span class="comment">// error boundaries.</span></span><br><span class="line">        legacyErrorBoundariesThatAlreadyFailed = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enableSchedulerTracing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!rootDidHavePassiveEffects) &#123;</span><br><span class="line">            <span class="comment">// If there are no passive effects, then we can complete the pending interactions.</span></span><br><span class="line">            <span class="comment">// Otherwise, we&#x27;ll wait until after the passive effects are flushed.</span></span><br><span class="line">            <span class="comment">// Wait to do this until after remaining work has been scheduled,</span></span><br><span class="line">            <span class="comment">// so that we don&#x27;t prematurely signal complete for interactions when there&#x27;s e.g. hidden work.</span></span><br><span class="line">            finishPendingInteractions(root, expirationTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onCommitRoot(finishedWork.stateNode, expirationTime); <span class="comment">// 里面应该是dev-tool的处理，先不看</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (remainingExpirationTime === Sync) &#123;</span><br><span class="line">        <span class="comment">// Count the number of times the root synchronously re-renders without</span></span><br><span class="line">        <span class="comment">// finishing. If there are too many, it indicates an infinite update loop.</span></span><br><span class="line">        <span class="keyword">if</span> (root === rootWithNestedUpdates) &#123;</span><br><span class="line">            nestedUpdateCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nestedUpdateCount = <span class="number">0</span>;</span><br><span class="line">            rootWithNestedUpdates = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nestedUpdateCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasUncaughtError) &#123;</span><br><span class="line">        hasUncaughtError = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">const</span> error = firstUncaughtError;</span><br><span class="line">        firstUncaughtError = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((executionContext &amp; LegacyUnbatchedContext) !== NoContext) &#123;</span><br><span class="line">        <span class="comment">// This is a legacy edge case. We just committed the initial mount of</span></span><br><span class="line">        <span class="comment">// a ReactDOM.render-ed root inside of batchedUpdates. The commit fired</span></span><br><span class="line">        <span class="comment">// synchronously, but layout updates should be deferred until the end</span></span><br><span class="line">        <span class="comment">// of the batch.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If layout work was scheduled, flush it now.</span></span><br><span class="line">    flushSyncCallbackQueue();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="prepareForCommit"><a href="#prepareForCommit" class="headerlink" title="prepareForCommit"></a>prepareForCommit</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">prepareForCommit</span>(<span class="params">containerInfo: Container</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    eventsEnabled = ReactBrowserEventEmitterIsEnabled(); <span class="comment">// 启用 _enabled</span></span><br><span class="line">    selectionInformation = getSelectionInformation(); <span class="comment">// 获取当前activeElement, 现在是body</span></span><br><span class="line">    ReactBrowserEventEmitterSetEnabled(<span class="literal">false</span>); <span class="comment">// 设为false, 对应上上 _enabled = false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="commitMutationEffects"><a href="#commitMutationEffects" class="headerlink" title="commitMutationEffects"></a>commitMutationEffects</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitMutationEffects</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Should probably move the bulk of this function to commitWork.</span></span><br><span class="line">    <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">        setCurrentDebugFiberInDEV(nextEffect); <span class="comment">// __DEV__</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> effectTag = nextEffect.effectTag; <span class="comment">// 将要执行的步骤状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (effectTag &amp; ContentReset) &#123;</span><br><span class="line">            commitResetTextContent(nextEffect);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (effectTag &amp; Ref) &#123;</span><br><span class="line">            <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">            <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">                commitDetachRef(current);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The following switch statement is only concerned about placement,</span></span><br><span class="line">        <span class="comment">// updates, and deletions. To avoid needing to add a case for every possible</span></span><br><span class="line">        <span class="comment">// bitmap value, we remove the secondary effects from the effect tag and</span></span><br><span class="line">        <span class="comment">// switch on that value.</span></span><br><span class="line">        <span class="comment">// 新增 or 更新 or 删除</span></span><br><span class="line">        <span class="keyword">let</span> primaryEffectTag = effectTag &amp; (Placement | Update | Deletion); <span class="comment">// (2 | 4 | 8)</span></span><br><span class="line">        <span class="keyword">switch</span> (primaryEffectTag) &#123;</span><br><span class="line">            <span class="keyword">case</span> Placement: &#123;</span><br><span class="line">                <span class="comment">// debugger</span></span><br><span class="line">                commitPlacement(nextEffect);</span><br><span class="line">                <span class="comment">// Clear the &quot;placement&quot; from effect tag so that we know that this is</span></span><br><span class="line">                <span class="comment">// inserted, before any life-cycles like componentDidMount gets called.</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> findDOMNode doesn&#x27;t rely on this any more but isMounted does</span></span><br><span class="line">                <span class="comment">// and isMounted is deprecated anyway so we should be able to kill this.</span></span><br><span class="line">                nextEffect.effectTag &amp;= ~Placement;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> PlacementAndUpdate: &#123;</span><br><span class="line">                <span class="comment">// 6</span></span><br><span class="line">                <span class="comment">// Placement</span></span><br><span class="line">                commitPlacement(nextEffect); <span class="comment">// 插入dom</span></span><br><span class="line">                <span class="comment">// Clear the &quot;placement&quot; from effect tag so that we know that this is</span></span><br><span class="line">                <span class="comment">// inserted, before any life-cycles like componentDidMount gets called.</span></span><br><span class="line">                nextEffect.effectTag &amp;= ~Placement;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Update</span></span><br><span class="line">                <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">                commitWork(current, nextEffect);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> Update: &#123;</span><br><span class="line">                <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">                commitWork(current, nextEffect);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> Deletion: &#123;</span><br><span class="line">                commitDeletion(nextEffect);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Only record a mutation effect if primaryEffectTag is non-zero.</span></span><br><span class="line">        recordEffect(); <span class="comment">// __DEV__</span></span><br><span class="line"></span><br><span class="line">        resetCurrentDebugFiberInDEV(); <span class="comment">// __DEV__</span></span><br><span class="line">        nextEffect = nextEffect.nextEffect;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="commitWork"><a href="#commitWork" class="headerlink" title="commitWork"></a>commitWork</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">current: Fiber | null, finishedWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">        <span class="keyword">case</span> ForwardRef:</span><br><span class="line">        <span class="keyword">case</span> MemoComponent:</span><br><span class="line">        <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">            <span class="comment">// Note: We currently never use MountMutation, but useLayout uses</span></span><br><span class="line">            <span class="comment">// UnmountMutation.</span></span><br><span class="line">            commitHookEffectList(UnmountMutation, MountMutation, finishedWork);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> HostComponent: &#123;</span><br><span class="line">            <span class="keyword">const</span> instance: Instance = finishedWork.stateNode;</span><br><span class="line">            <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Commit the work prepared earlier.</span></span><br><span class="line">                <span class="keyword">const</span> newProps = finishedWork.memoizedProps;</span><br><span class="line">                <span class="comment">// For hydration we reuse the update path but we treat the oldProps</span></span><br><span class="line">                <span class="comment">// as the newProps. The updatePayload will contain the real change in</span></span><br><span class="line">                <span class="comment">// this case.</span></span><br><span class="line">                <span class="keyword">const</span> oldProps = current !== <span class="literal">null</span> ? current.memoizedProps : newProps;</span><br><span class="line">                <span class="keyword">const</span> type = finishedWork.type;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Type the updateQueue to be specific to host components.</span></span><br><span class="line">                <span class="keyword">const</span> updatePayload: <span class="literal">null</span> | UpdatePayload = (finishedWork.updateQueue: any);</span><br><span class="line">                finishedWork.updateQueue = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 更新</span></span><br><span class="line">                <span class="keyword">if</span> (updatePayload !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> HostText: &#123;</span><br><span class="line">            invariant(</span><br><span class="line">                finishedWork.stateNode !== <span class="literal">null</span>,</span><br><span class="line">                <span class="string">&#x27;This should have a text node initialized. This error is likely &#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;caused by a bug in React. Please file an issue.&#x27;</span>,</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">const</span> textInstance: TextInstance = finishedWork.stateNode;</span><br><span class="line">            <span class="keyword">const</span> newText: string = finishedWork.memoizedProps;</span><br><span class="line">            <span class="comment">// For hydration we reuse the update path but we treat the oldProps</span></span><br><span class="line">            <span class="comment">// as the newProps. The updatePayload will contain the real change in</span></span><br><span class="line">            <span class="comment">// this case.</span></span><br><span class="line">            <span class="keyword">const</span> oldText: string = current !== <span class="literal">null</span> ? current.memoizedProps : newText;</span><br><span class="line">            commitTextUpdate(textInstance, oldText, newText);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> EventTarget: &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> HostRoot: &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Profiler: &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SuspenseComponent: &#123;</span><br><span class="line">            commitSuspenseComponent(finishedWork);</span><br><span class="line">            attachSuspenseRetryListeners(finishedWork);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SuspenseListComponent: &#123;</span><br><span class="line">            attachSuspenseRetryListeners(finishedWork);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> IncompleteClassComponent: &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> EventComponent: &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            invariant(</span><br><span class="line">                <span class="literal">false</span>,</span><br><span class="line">                <span class="string">&#x27;This unit of work tag should not have side-effects. This error is &#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;likely caused by a bug in React. Please file an issue.&#x27;</span>,</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="commitHookEffectList"><a href="#commitHookEffectList" class="headerlink" title="commitHookEffectList"></a>commitHookEffectList</h3><p>见 <code>hooks.md</code> -&gt; <code>useeffect</code>-&gt; <code>commitHookEffectList</code></p>
<h3 id="commitPlacement"><a href="#commitPlacement" class="headerlink" title="commitPlacement"></a>commitPlacement</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitPlacement</span>(<span class="params">finishedWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!supportsMutation) &#123;</span><br><span class="line">        <span class="comment">// supportsMutation固定true</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively insert all host nodes into the parent.</span></span><br><span class="line">    <span class="comment">// 递归获得父节点fiber</span></span><br><span class="line">    <span class="keyword">const</span> parentFiber = getHostParentFiber(finishedWork);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: these two variables *must* always be updated together.</span></span><br><span class="line">    <span class="keyword">let</span> parent;</span><br><span class="line">    <span class="keyword">let</span> isContainer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (parentFiber.tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> HostComponent:</span><br><span class="line">            parent = parentFiber.stateNode;</span><br><span class="line">            isContainer = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HostRoot:</span><br><span class="line">            parent = parentFiber.stateNode.containerInfo; <span class="comment">// dom</span></span><br><span class="line">            isContainer = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HostPortal:</span><br><span class="line">            parent = parentFiber.stateNode.containerInfo;</span><br><span class="line">            isContainer = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            invariant(</span><br><span class="line">                <span class="literal">false</span>,</span><br><span class="line">                <span class="string">&#x27;Invalid host parent fiber. This error is likely caused by a bug &#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;in React. Please file an issue.&#x27;</span>,</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parentFiber.effectTag &amp; ContentReset) &#123;</span><br><span class="line">        <span class="comment">// Reset the text content of the parent before doing any insertions</span></span><br><span class="line">        resetTextContent(parent);</span><br><span class="line">        <span class="comment">// Clear ContentReset from the effect tag</span></span><br><span class="line">        parentFiber.effectTag &amp;= ~ContentReset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> before = getHostSibling(finishedWork); <span class="comment">// 复用情况下找到下一个相邻节点</span></span><br><span class="line">    <span class="comment">// We only have the top Fiber that was inserted but we need to recurse down its</span></span><br><span class="line">    <span class="comment">// children to find all the terminal nodes.</span></span><br><span class="line">    <span class="keyword">let</span> node: Fiber = finishedWork;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.tag === HostComponent || node.tag === HostText) &#123;</span><br><span class="line">            <span class="keyword">const</span> stateNode = node.stateNode;</span><br><span class="line">            <span class="keyword">if</span> (before) &#123;</span><br><span class="line">                <span class="comment">// 如果有相邻节点，插在前面</span></span><br><span class="line">                <span class="comment">// 这里都是插在before前面</span></span><br><span class="line">                <span class="comment">// 区别是insertInContainerBefore里面判断了parent是不是COMMENT_NODE</span></span><br><span class="line">                <span class="keyword">if</span> (isContainer) &#123;</span><br><span class="line">                    insertInContainerBefore(parent, stateNode, before);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    insertBefore(parent, stateNode, before);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 都是parent.appendChild(stateNode)</span></span><br><span class="line">                <span class="comment">// 区别同上</span></span><br><span class="line">                <span class="keyword">if</span> (isContainer) &#123;</span><br><span class="line">                    appendChildToContainer(parent, stateNode);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    appendChild(parent, stateNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.tag === HostPortal) &#123;</span><br><span class="line">            <span class="comment">// If the insertion itself is a portal, then we don&#x27;t want to traverse</span></span><br><span class="line">            <span class="comment">// down its children. Instead, we&#x27;ll get insertions from each child in</span></span><br><span class="line">            <span class="comment">// the portal directly.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.child !== <span class="literal">null</span>) &#123;</span><br><span class="line">            node.child.return = node;</span><br><span class="line">            node = node.child;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node === finishedWork) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (node.sibling === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.return === <span class="literal">null</span> || node.return === finishedWork) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.return;</span><br><span class="line">        &#125;</span><br><span class="line">        node.sibling.return = node.return;</span><br><span class="line">        node = node.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="commitLayoutEffects"><a href="#commitLayoutEffects" class="headerlink" title="commitLayoutEffects"></a>commitLayoutEffects</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLayoutEffects</span>(<span class="params">root: FiberRoot, committedExpirationTime: ExpirationTime</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 生命周期和ref</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Should probably move the bulk of this function to commitWork.</span></span><br><span class="line">    <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">        setCurrentDebugFiberInDEV(nextEffect); <span class="comment">// dev</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> effectTag = nextEffect.effectTag;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (effectTag &amp; (Update | Callback)) &#123;</span><br><span class="line">            recordEffect(); <span class="comment">// false</span></span><br><span class="line">            <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">            commitLayoutEffectOnFiber(</span><br><span class="line">                <span class="comment">// componentDidUpdate</span></span><br><span class="line">                root,</span><br><span class="line">                current,</span><br><span class="line">                nextEffect,</span><br><span class="line">                committedExpirationTime,</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (effectTag &amp; Ref) &#123;</span><br><span class="line">            recordEffect(); <span class="comment">// false</span></span><br><span class="line">            commitAttachRef(nextEffect);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (effectTag &amp; Passive) &#123;</span><br><span class="line">            rootDoesHavePassiveEffects = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resetCurrentDebugFiberInDEV();</span><br><span class="line">        nextEffect = nextEffect.nextEffect;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="commitLifeCycles"><a href="#commitLifeCycles" class="headerlink" title="commitLifeCycles"></a>commitLifeCycles</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLifeCycles</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    finishedRoot: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">    current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    committedExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">        <span class="keyword">case</span> ForwardRef:</span><br><span class="line">        <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">            commitHookEffectList(UnmountLayout, MountLayout, finishedWork);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">            <span class="keyword">const</span> instance = finishedWork.stateNode;</span><br><span class="line">            <span class="keyword">if</span> (finishedWork.effectTag &amp; Update) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">                    startPhaseTimer(finishedWork, <span class="string">&#x27;componentDidMount&#x27;</span>); <span class="comment">// false</span></span><br><span class="line">                    <span class="comment">// We could update instance props and state here,</span></span><br><span class="line">                    <span class="comment">// but instead we rely on them being set during last render.</span></span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> revisit this when we implement resuming.</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// debugger</span></span><br><span class="line">                    instance.componentDidMount(); <span class="comment">// 生命周期</span></span><br><span class="line">                    stopPhaseTimer(); <span class="comment">// false</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> prevProps =</span><br><span class="line">                        finishedWork.elementType === finishedWork.type</span><br><span class="line">                            ? current.memoizedProps</span><br><span class="line">                            : resolveDefaultProps(finishedWork.type, current.memoizedProps);</span><br><span class="line">                    <span class="keyword">const</span> prevState = current.memoizedState;</span><br><span class="line">                    startPhaseTimer(finishedWork, <span class="string">&#x27;componentDidUpdate&#x27;</span>);</span><br><span class="line">                    <span class="comment">// We could update instance props and state here,</span></span><br><span class="line">                    <span class="comment">// but instead we rely on them being set during last render.</span></span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> revisit this when we implement resuming.</span></span><br><span class="line"></span><br><span class="line">                    instance.componentDidUpdate(</span><br><span class="line">                        prevProps,</span><br><span class="line">                        prevState,</span><br><span class="line">                        instance.__reactInternalSnapshotBeforeUpdate,</span><br><span class="line">                    );</span><br><span class="line">                    stopPhaseTimer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> updateQueue = finishedWork.updateQueue;</span><br><span class="line">            <span class="keyword">if</span> (updateQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// We could update instance props and state here,</span></span><br><span class="line">                <span class="comment">// but instead we rely on them being set during last render.</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> revisit this when we implement resuming.</span></span><br><span class="line">                commitUpdateQueue(finishedWork, updateQueue, instance, committedExpirationTime);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> HostRoot: &#123;</span><br><span class="line">            <span class="keyword">const</span> updateQueue = finishedWork.updateQueue;</span><br><span class="line">            <span class="keyword">if</span> (updateQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> instance = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (finishedWork.child !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (finishedWork.child.tag) &#123;</span><br><span class="line">                        <span class="keyword">case</span> HostComponent:</span><br><span class="line">                            instance = getPublicInstance(finishedWork.child.stateNode);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> ClassComponent:</span><br><span class="line">                            instance = finishedWork.child.stateNode;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                commitUpdateQueue(finishedWork, updateQueue, instance, committedExpirationTime);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> HostComponent: &#123;</span><br><span class="line">            <span class="keyword">const</span> instance: Instance = finishedWork.stateNode;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Renderers may schedule work to be done after host components are mounted</span></span><br><span class="line">            <span class="comment">// (eg DOM renderer may schedule auto-focus for inputs and form controls).</span></span><br><span class="line">            <span class="comment">// These effects should only be committed when components are first mounted,</span></span><br><span class="line">            <span class="comment">// aka when there is no current/alternate.</span></span><br><span class="line">            <span class="keyword">if</span> (current === <span class="literal">null</span> &amp;&amp; finishedWork.effectTag &amp; Update) &#123;</span><br><span class="line">                <span class="keyword">const</span> type = finishedWork.type;</span><br><span class="line">                <span class="keyword">const</span> props = finishedWork.memoizedProps;</span><br><span class="line">                commitMount(instance, type, props, finishedWork);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> HostText: &#123;</span><br><span class="line">            <span class="comment">// We have no life-cycles associated with text.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> HostPortal: &#123;</span><br><span class="line">            <span class="comment">// We have no life-cycles associated with portals.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Profiler: &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SuspenseComponent:</span><br><span class="line">        <span class="keyword">case</span> SuspenseListComponent:</span><br><span class="line">        <span class="keyword">case</span> IncompleteClassComponent:</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> EventTarget: &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> EventComponent: &#123;</span><br><span class="line">            <span class="keyword">if</span> (enableEventAPI) &#123;</span><br><span class="line">                mountEventComponent(finishedWork.stateNode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>completeWork</title>
    <url>/my-notes/2020/09/09/react/completeWork/</url>
    <content><![CDATA[<p>根据 fiber tag 创建 dom 节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    renderExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> IndeterminateComponent:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LazyComponent:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SimpleMemoComponent:</span><br><span class="line">        <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">            <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">            <span class="keyword">if</span> (isLegacyContextProvider(Component)) &#123;</span><br><span class="line">                popLegacyContext(workInProgress);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> HostRoot: &#123;</span><br><span class="line">            popHostContainer(workInProgress);</span><br><span class="line">            popTopLevelLegacyContextObject(workInProgress);</span><br><span class="line">            <span class="keyword">const</span> fiberRoot = (workInProgress.stateNode: FiberRoot);</span><br><span class="line">            <span class="keyword">if</span> (fiberRoot.pendingContext) &#123;</span><br><span class="line">                fiberRoot.context = fiberRoot.pendingContext;</span><br><span class="line">                fiberRoot.pendingContext = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current === <span class="literal">null</span> || current.child === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If we hydrated, pop so that we can delete any remaining children</span></span><br><span class="line">                <span class="comment">// that weren&#x27;t hydrated.</span></span><br><span class="line">                popHydrationState(workInProgress);</span><br><span class="line">                <span class="comment">// This resets the hacky state to fix isMounted before committing.</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Delete this when we delete isMounted and findDOMNode.</span></span><br><span class="line">                workInProgress.effectTag &amp;= ~Placement;</span><br><span class="line">            &#125;</span><br><span class="line">            updateHostContainer(workInProgress);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> HostComponent: &#123;</span><br><span class="line">            <span class="comment">// 5</span></span><br><span class="line">            popHostContext(workInProgress);</span><br><span class="line">            <span class="keyword">const</span> rootContainerInstance = getRootHostContainer(); <span class="comment">// 返回div#app</span></span><br><span class="line">            <span class="keyword">const</span> type = workInProgress.type;</span><br><span class="line">            <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; workInProgress.stateNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                updateHostComponent(</span><br><span class="line">                    <span class="comment">// 有stateNode（dom）,更新</span></span><br><span class="line">                    current,</span><br><span class="line">                    workInProgress,</span><br><span class="line">                    type,</span><br><span class="line">                    newProps,</span><br><span class="line">                    rootContainerInstance,</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (current.ref !== workInProgress.ref) &#123;</span><br><span class="line">                    markRef(workInProgress);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!newProps) &#123;</span><br><span class="line">                    invariant(</span><br><span class="line">                        workInProgress.stateNode !== <span class="literal">null</span>,</span><br><span class="line">                        <span class="string">&#x27;We must have new props for new mounts. This error is likely &#x27;</span> +</span><br><span class="line">                            <span class="string">&#x27;caused by a bug in React. Please file an issue.&#x27;</span>,</span><br><span class="line">                    );</span><br><span class="line">                    <span class="comment">// This can happen when we abort work.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 返回 http://www.w3.org/1999/xhtml</span></span><br><span class="line">                <span class="keyword">const</span> currentHostContext = getHostContext();</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Move createInstance to beginWork and keep it on a context</span></span><br><span class="line">                <span class="comment">// &quot;stack&quot; as the parent. Then append children as we go in beginWork</span></span><br><span class="line">                <span class="comment">// or completeWork depending on we want to add then top-&gt;down or</span></span><br><span class="line">                <span class="comment">// bottom-&gt;up. Top-&gt;down is faster in IE11.</span></span><br><span class="line">                <span class="keyword">let</span> wasHydrated = popHydrationState(workInProgress);</span><br><span class="line">                <span class="keyword">if</span> (wasHydrated) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Move this and createInstance step into the beginPhase</span></span><br><span class="line">                    <span class="comment">// to consolidate.</span></span><br><span class="line">                    <span class="keyword">if</span> (</span><br><span class="line">                        prepareToHydrateHostInstance(</span><br><span class="line">                            workInProgress,</span><br><span class="line">                            rootContainerInstance,</span><br><span class="line">                            currentHostContext,</span><br><span class="line">                        )</span><br><span class="line">                    ) &#123;</span><br><span class="line">                        <span class="comment">// If changes to the hydrated node needs to be applied at the</span></span><br><span class="line">                        <span class="comment">// commit-phase we mark this as such.</span></span><br><span class="line">                        markUpdate(workInProgress);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// debugger</span></span><br><span class="line">                    <span class="comment">// 根据fiber创建dom</span></span><br><span class="line">                    <span class="comment">// 返回创建的dom节点</span></span><br><span class="line">                    <span class="keyword">let</span> instance = createInstance(</span><br><span class="line">                        type,</span><br><span class="line">                        newProps,</span><br><span class="line">                        rootContainerInstance,</span><br><span class="line">                        currentHostContext,</span><br><span class="line">                        workInProgress,</span><br><span class="line">                    );</span><br><span class="line"></span><br><span class="line">                    appendAllChildren(instance, workInProgress, <span class="literal">false</span>, <span class="literal">false</span>); <span class="comment">// 添加child ?</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Certain renderers require commit-time effects for initial mount.</span></span><br><span class="line">                    <span class="comment">// (eg DOM renderer supports auto-focus for certain elements).</span></span><br><span class="line">                    <span class="comment">// Make sure such renderers get scheduled for later work.</span></span><br><span class="line">                    <span class="keyword">if</span> (</span><br><span class="line">                        finalizeInitialChildren(</span><br><span class="line">                            instance,</span><br><span class="line">                            type,</span><br><span class="line">                            newProps,</span><br><span class="line">                            rootContainerInstance,</span><br><span class="line">                            currentHostContext,</span><br><span class="line">                        )</span><br><span class="line">                    ) &#123;</span><br><span class="line">                        markUpdate(workInProgress);</span><br><span class="line">                    &#125;</span><br><span class="line">                    workInProgress.stateNode = instance;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (workInProgress.ref !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If there is a ref on a host node we need to schedule a callback</span></span><br><span class="line">                    markRef(workInProgress);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> HostText: &#123;</span><br><span class="line">            <span class="keyword">let</span> newText = newProps;</span><br><span class="line">            <span class="keyword">if</span> (current &amp;&amp; workInProgress.stateNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> oldText = current.memoizedProps;</span><br><span class="line">                <span class="comment">// If we have an alternate, that means this is an update and we need</span></span><br><span class="line">                <span class="comment">// to schedule a side-effect to do the updates.</span></span><br><span class="line">                updateHostText(current, workInProgress, oldText, newText);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> newText !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">                    invariant(</span><br><span class="line">                        workInProgress.stateNode !== <span class="literal">null</span>,</span><br><span class="line">                        <span class="string">&#x27;We must have new props for new mounts. This error is likely &#x27;</span> +</span><br><span class="line">                            <span class="string">&#x27;caused by a bug in React. Please file an issue.&#x27;</span>,</span><br><span class="line">                    );</span><br><span class="line">                    <span class="comment">// This can happen when we abort work.</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">const</span> rootContainerInstance = getRootHostContainer();</span><br><span class="line">                <span class="keyword">const</span> currentHostContext = getHostContext();</span><br><span class="line">                <span class="keyword">let</span> wasHydrated = popHydrationState(workInProgress);</span><br><span class="line">                <span class="keyword">if</span> (wasHydrated) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prepareToHydrateHostTextInstance(workInProgress)) &#123;</span><br><span class="line">                        markUpdate(workInProgress);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    workInProgress.stateNode = createTextInstance(</span><br><span class="line">                        newText,</span><br><span class="line">                        rootContainerInstance,</span><br><span class="line">                        currentHostContext,</span><br><span class="line">                        workInProgress,</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> ForwardRef:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SuspenseComponent: &#123;</span><br><span class="line">            popSuspenseContext(workInProgress);</span><br><span class="line">            <span class="keyword">const</span> nextState: <span class="literal">null</span> | SuspenseState = workInProgress.memoizedState;</span><br><span class="line">            <span class="keyword">if</span> ((workInProgress.effectTag &amp; DidCapture) !== NoEffect) &#123;</span><br><span class="line">                <span class="comment">// Something suspended. Re-render with the fallback children.</span></span><br><span class="line">                workInProgress.expirationTime = renderExpirationTime;</span><br><span class="line">                <span class="comment">// Do not reset the effect list.</span></span><br><span class="line">                <span class="keyword">return</span> workInProgress;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> nextDidTimeout = nextState !== <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> prevDidTimeout = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// In cases where we didn&#x27;t find a suitable hydration boundary we never</span></span><br><span class="line">                <span class="comment">// downgraded this to a DehydratedSuspenseComponent, but we still need to</span></span><br><span class="line">                <span class="comment">// pop the hydration state since we might be inside the insertion tree.</span></span><br><span class="line">                popHydrationState(workInProgress);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> prevState: <span class="literal">null</span> | SuspenseState = current.memoizedState;</span><br><span class="line">                prevDidTimeout = prevState !== <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (!nextDidTimeout &amp;&amp; prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// We just switched from the fallback to the normal children.</span></span><br><span class="line">                    <span class="comment">// Delete the fallback.</span></span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Would it be better to store the fallback fragment on</span></span><br><span class="line">                    <span class="comment">// the stateNode during the begin phase?</span></span><br><span class="line">                    <span class="keyword">const</span> currentFallbackChild: Fiber | <span class="literal">null</span> = (current.child: any).sibling;</span><br><span class="line">                    <span class="keyword">if</span> (currentFallbackChild !== <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Deletions go at the beginning of the return fiber&#x27;s effect list</span></span><br><span class="line">                        <span class="keyword">const</span> first = workInProgress.firstEffect;</span><br><span class="line">                        <span class="keyword">if</span> (first !== <span class="literal">null</span>) &#123;</span><br><span class="line">                            workInProgress.firstEffect = currentFallbackChild;</span><br><span class="line">                            currentFallbackChild.nextEffect = first;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChild;</span><br><span class="line">                            currentFallbackChild.nextEffect = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        currentFallbackChild.effectTag = Deletion;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nextDidTimeout &amp;&amp; !prevDidTimeout) &#123;</span><br><span class="line">                <span class="comment">// If this subtreee is running in batched mode we can suspend,</span></span><br><span class="line">                <span class="comment">// otherwise we won&#x27;t suspend.</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> This will still suspend a synchronous tree if anything</span></span><br><span class="line">                <span class="comment">// in the concurrent tree already suspended during this render.</span></span><br><span class="line">                <span class="comment">// This is a known bug.</span></span><br><span class="line">                <span class="keyword">if</span> ((workInProgress.mode &amp; BatchedMode) !== NoMode) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Move this back to throwException because this is too late</span></span><br><span class="line">                    <span class="comment">// if this is a large tree which is common for initial loads. We</span></span><br><span class="line">                    <span class="comment">// don&#x27;t know if we should restart a render or not until we get</span></span><br><span class="line">                    <span class="comment">// this marker, and this is too late.</span></span><br><span class="line">                    <span class="comment">// If this render already had a ping or lower pri updates,</span></span><br><span class="line">                    <span class="comment">// and this is the first time we know we&#x27;re going to suspend we</span></span><br><span class="line">                    <span class="comment">// should be able to immediately restart from within throwException.</span></span><br><span class="line">                    <span class="keyword">const</span> hasInvisibleChildContext =</span><br><span class="line">                        current === <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                        workInProgress.memoizedProps.unstable_avoidThisFallback !== <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (</span><br><span class="line">                        hasInvisibleChildContext ||</span><br><span class="line">                        hasSuspenseContext(</span><br><span class="line">                            suspenseStackCursor.current,</span><br><span class="line">                            (InvisibleParentSuspenseContext: SuspenseContext),</span><br><span class="line">                        )</span><br><span class="line">                    ) &#123;</span><br><span class="line">                        <span class="comment">// If this was in an invisible tree or a new render, then showing</span></span><br><span class="line">                        <span class="comment">// this boundary is ok.</span></span><br><span class="line">                        renderDidSuspend();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Otherwise, we&#x27;re going to have to hide content so we should</span></span><br><span class="line">                        <span class="comment">// suspend for longer if possible.</span></span><br><span class="line">                        renderDidSuspendDelayIfPossible();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (supportsPersistence) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Only schedule updates if not prevDidTimeout.</span></span><br><span class="line">                <span class="keyword">if</span> (nextDidTimeout) &#123;</span><br><span class="line">                    <span class="comment">// If this boundary just timed out, schedule an effect to attach a</span></span><br><span class="line">                    <span class="comment">// retry listener to the proimse. This flag is also used to hide the</span></span><br><span class="line">                    <span class="comment">// primary children.</span></span><br><span class="line">                    workInProgress.effectTag |= Update;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (supportsMutation) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Only schedule updates if these values are non equal, i.e. it changed.</span></span><br><span class="line">                <span class="keyword">if</span> (nextDidTimeout || prevDidTimeout) &#123;</span><br><span class="line">                    <span class="comment">// If this boundary just timed out, schedule an effect to attach a</span></span><br><span class="line">                    <span class="comment">// retry listener to the proimse. This flag is also used to hide the</span></span><br><span class="line">                    <span class="comment">// primary children. In mutation mode, we also need the flag to</span></span><br><span class="line">                    <span class="comment">// *unhide* children that were previously hidden, so check if the</span></span><br><span class="line">                    <span class="comment">// is currently timed out, too.</span></span><br><span class="line">                    workInProgress.effectTag |= Update;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Fragment:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Mode:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Profiler:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HostPortal:</span><br><span class="line">            popHostContainer(workInProgress);</span><br><span class="line">            updateHostContainer(workInProgress);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ContextProvider:</span><br><span class="line">            <span class="comment">// Pop provider fiber</span></span><br><span class="line">            popProvider(workInProgress);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ContextConsumer:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MemoComponent:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IncompleteClassComponent: &#123;</span><br><span class="line">            <span class="comment">// Same as class component case. I put it down here so that the tags are</span></span><br><span class="line">            <span class="comment">// sequential to ensure this switch is compiled to a jump table.</span></span><br><span class="line">            <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">            <span class="keyword">if</span> (isLegacyContextProvider(Component)) &#123;</span><br><span class="line">                popLegacyContext(workInProgress);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> DehydratedSuspenseComponent: &#123;</span><br><span class="line">            <span class="keyword">if</span> (enableSuspenseServerRenderer) &#123;</span><br><span class="line">                popSuspenseContext(workInProgress);</span><br><span class="line">                <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">let</span> wasHydrated = popHydrationState(workInProgress);</span><br><span class="line">                    invariant(</span><br><span class="line">                        wasHydrated,</span><br><span class="line">                        <span class="string">&#x27;A dehydrated suspense component was completed without a hydrated node. &#x27;</span> +</span><br><span class="line">                            <span class="string">&#x27;This is probably a bug in React.&#x27;</span>,</span><br><span class="line">                    );</span><br><span class="line">                    <span class="keyword">if</span> (enableSchedulerTracing) &#123;</span><br><span class="line">                        markDidDeprioritizeIdleSubtree();</span><br><span class="line">                    &#125;</span><br><span class="line">                    skipPastDehydratedSuspenseInstance(workInProgress);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((workInProgress.effectTag &amp; DidCapture) === NoEffect) &#123;</span><br><span class="line">                    <span class="comment">// This boundary did not suspend so it&#x27;s now hydrated.</span></span><br><span class="line">                    <span class="comment">// To handle any future suspense cases, we&#x27;re going to now upgrade it</span></span><br><span class="line">                    <span class="comment">// to a Suspense component. We detach it from the existing current fiber.</span></span><br><span class="line">                    current.alternate = <span class="literal">null</span>;</span><br><span class="line">                    workInProgress.alternate = <span class="literal">null</span>;</span><br><span class="line">                    workInProgress.tag = SuspenseComponent;</span><br><span class="line">                    workInProgress.memoizedState = <span class="literal">null</span>;</span><br><span class="line">                    workInProgress.stateNode = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SuspenseListComponent: &#123;</span><br><span class="line">            popSuspenseContext(workInProgress);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((workInProgress.effectTag &amp; DidCapture) === NoEffect) &#123;</span><br><span class="line">                <span class="comment">// This is the first pass. We need to figure out if anything is still</span></span><br><span class="line">                <span class="comment">// suspended in the rendered set.</span></span><br><span class="line">                <span class="keyword">const</span> renderedChildren = workInProgress.child;</span><br><span class="line">                <span class="comment">// If new content unsuspended, but there&#x27;s still some content that</span></span><br><span class="line">                <span class="comment">// didn&#x27;t. Then we need to do a second pass that forces everything</span></span><br><span class="line">                <span class="comment">// to keep showing their fallbacks.</span></span><br><span class="line">                <span class="keyword">const</span> needsRerender = hasSuspendedChildrenAndNewContent(</span><br><span class="line">                    workInProgress,</span><br><span class="line">                    renderedChildren,</span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">if</span> (needsRerender) &#123;</span><br><span class="line">                    <span class="comment">// Rerender the whole list, but this time, we&#x27;ll force fallbacks</span></span><br><span class="line">                    <span class="comment">// to stay in place.</span></span><br><span class="line">                    workInProgress.effectTag |= DidCapture;</span><br><span class="line">                    <span class="comment">// Reset the effect list before doing the second pass since that&#x27;s now invalid.</span></span><br><span class="line">                    workInProgress.firstEffect = workInProgress.lastEffect = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// Schedule work so we know not to bail out.</span></span><br><span class="line">                    workInProgress.expirationTime = renderExpirationTime;</span><br><span class="line">                    <span class="keyword">return</span> workInProgress;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                workInProgress.effectTag &amp;= ~DidCapture;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> EventComponent: &#123;</span><br><span class="line">            <span class="keyword">if</span> (enableEventAPI) &#123;</span><br><span class="line">                popHostContext(workInProgress);</span><br><span class="line">                <span class="keyword">const</span> rootContainerInstance = getRootHostContainer();</span><br><span class="line">                <span class="keyword">const</span> responder = workInProgress.type.responder;</span><br><span class="line">                <span class="keyword">let</span> eventComponentInstance: ReactEventComponentInstance | <span class="literal">null</span> =</span><br><span class="line">                    workInProgress.stateNode;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (eventComponentInstance === <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">let</span> responderState = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (__DEV__ &amp;&amp; !responder.allowMultipleHostChildren) &#123;</span><br><span class="line">                        <span class="keyword">const</span> hostChildrenCount = getEventComponentHostChildrenCount(</span><br><span class="line">                            workInProgress,</span><br><span class="line">                        );</span><br><span class="line">                        warning(</span><br><span class="line">                            (hostChildrenCount || <span class="number">0</span>) &lt; <span class="number">2</span>,</span><br><span class="line">                            <span class="string">&#x27;A &quot;&lt;%s&gt;&quot; event component cannot contain multiple host children.&#x27;</span>,</span><br><span class="line">                            getComponentName(workInProgress.type),</span><br><span class="line">                        );</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (responder.createInitialState !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        responderState = responder.createInitialState(newProps);</span><br><span class="line">                    &#125;</span><br><span class="line">                    eventComponentInstance = workInProgress.stateNode = &#123;</span><br><span class="line">                        currentFiber: workInProgress,</span><br><span class="line">                        props: newProps,</span><br><span class="line">                        responder,</span><br><span class="line">                        rootEventTypes: <span class="literal">null</span>,</span><br><span class="line">                        rootInstance: rootContainerInstance,</span><br><span class="line">                        state: responderState,</span><br><span class="line">                    &#125;;</span><br><span class="line">                    markUpdate(workInProgress);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Update the props on the event component state node</span></span><br><span class="line">                    eventComponentInstance.props = newProps;</span><br><span class="line">                    <span class="comment">// Update the root container, so we can properly unmount events at some point</span></span><br><span class="line">                    eventComponentInstance.rootInstance = rootContainerInstance;</span><br><span class="line">                    <span class="comment">// Update the current fiber</span></span><br><span class="line">                    eventComponentInstance.currentFiber = workInProgress;</span><br><span class="line">                    updateEventComponent(eventComponentInstance);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> EventTarget: &#123;</span><br><span class="line">            <span class="keyword">if</span> (enableEventAPI) &#123;</span><br><span class="line">                popHostContext(workInProgress);</span><br><span class="line">                <span class="keyword">const</span> type = workInProgress.type.type;</span><br><span class="line">                <span class="keyword">const</span> rootContainerInstance = getRootHostContainer();</span><br><span class="line">                <span class="keyword">const</span> shouldUpdate = handleEventTarget(</span><br><span class="line">                    type,</span><br><span class="line">                    newProps,</span><br><span class="line">                    rootContainerInstance,</span><br><span class="line">                    workInProgress,</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// Update the latest props on the stateNode. This is used</span></span><br><span class="line">                <span class="comment">// during the event phase to find the most current props.</span></span><br><span class="line">                workInProgress.stateNode.props = newProps;</span><br><span class="line">                <span class="keyword">if</span> (shouldUpdate) &#123;</span><br><span class="line">                    markUpdate(workInProgress);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            invariant(</span><br><span class="line">                <span class="literal">false</span>,</span><br><span class="line">                <span class="string">&#x27;Unknown unit of work tag. This error is likely caused by a bug in &#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;React. Please file an issue.&#x27;</span>,</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="createInstance"><a href="#createInstance" class="headerlink" title="createInstance"></a>createInstance</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    type: string,</span></span></span><br><span class="line"><span class="function"><span class="params">    props: Props,</span></span></span><br><span class="line"><span class="function"><span class="params">    rootContainerInstance: Container,</span></span></span><br><span class="line"><span class="function"><span class="params">    hostContext: HostContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    internalInstanceHandle: Object,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Instance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> parentNamespace: string;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parentNamespace = ((hostContext: any): HostContextProd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获得当前的dom实例 createElement结果</span></span><br><span class="line">    <span class="keyword">const</span> domElement: Instance = createElement(type, props, rootContainerInstance, parentNamespace);</span><br><span class="line">    <span class="comment">// 给dom添加属性指向对应fiber</span></span><br><span class="line">    precacheFiberNode(internalInstanceHandle, domElement);</span><br><span class="line">    <span class="comment">// 给dom添加属性指向对应props</span></span><br><span class="line">    updateFiberProps(domElement, props);</span><br><span class="line">    <span class="keyword">return</span> domElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="appendAllChildren"><a href="#appendAllChildren" class="headerlink" title="appendAllChildren"></a>appendAllChildren</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在浏览器环境中他固定为true</span></span><br><span class="line"><span class="keyword">if</span> (supportsMutation) &#123;</span><br><span class="line">    <span class="comment">// Mutation mode</span></span><br><span class="line"></span><br><span class="line">    appendAllChildren = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        parent: Instance,</span></span></span><br><span class="line"><span class="function"><span class="params">        workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">        needsVisibilityToggle: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">        isHidden: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) </span>&#123;</span><br><span class="line">        <span class="comment">// We only have the top Fiber that was created but we need recurse down its</span></span><br><span class="line">        <span class="comment">// children to find all the terminal nodes.</span></span><br><span class="line">        <span class="keyword">let</span> node = workInProgress.child;</span><br><span class="line">        <span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.tag === HostComponent || node.tag === HostText) &#123;</span><br><span class="line">                appendInitialChild(parent, node.stateNode);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.tag === HostPortal) &#123;</span><br><span class="line">                <span class="comment">// If we have a portal child, then we don&#x27;t want to traverse</span></span><br><span class="line">                <span class="comment">// down its children. Instead, we&#x27;ll get insertions from each child in</span></span><br><span class="line">                <span class="comment">// the portal directly.</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.child !== <span class="literal">null</span>) &#123;</span><br><span class="line">                node.child.return = node;</span><br><span class="line">                node = node.child;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node === workInProgress) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (node.sibling === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.return === <span class="literal">null</span> || node.return === workInProgress) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.return;</span><br><span class="line">            &#125;</span><br><span class="line">            node.sibling.return = node.return;</span><br><span class="line">            node = node.sibling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="finalizeInitialChildren"><a href="#finalizeInitialChildren" class="headerlink" title="finalizeInitialChildren"></a>finalizeInitialChildren</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">finalizeInitialChildren</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    domElement: Instance,</span></span></span><br><span class="line"><span class="function"><span class="params">    type: string,</span></span></span><br><span class="line"><span class="function"><span class="params">    props: Props,</span></span></span><br><span class="line"><span class="function"><span class="params">    rootContainerInstance: Container,</span></span></span><br><span class="line"><span class="function"><span class="params">    hostContext: HostContext,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    setInitialProperties(domElement, type, props, rootContainerInstance);</span><br><span class="line">    <span class="comment">// 判断是否需要autoFocus</span></span><br><span class="line">    <span class="keyword">return</span> shouldAutoFocusHostComponent(type, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setInitialProperties"><a href="#setInitialProperties" class="headerlink" title="setInitialProperties"></a>setInitialProperties</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setInitialProperties</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    domElement: Element,</span></span></span><br><span class="line"><span class="function"><span class="params">    tag: string,</span></span></span><br><span class="line"><span class="function"><span class="params">    rawProps: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">    rootContainerElement: Element | Document,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isCustomComponentTag = isCustomComponent(tag, rawProps); <span class="comment">// 是否自定义标签</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Make sure that we check isMounted before firing any of these events.</span></span><br><span class="line">    <span class="keyword">let</span> props: <span class="built_in">Object</span>;</span><br><span class="line">    <span class="keyword">switch</span> (</span><br><span class="line">        tag <span class="comment">// 给以下特殊标签添加默认事件</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;iframe&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;object&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;embed&#x27;</span>:</span><br><span class="line">            trapBubbledEvent(TOP_LOAD, domElement);</span><br><span class="line">            props = rawProps;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;video&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;audio&#x27;</span>:</span><br><span class="line">            <span class="comment">// Create listener for each media event</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; mediaEventTypes.length; i++) &#123;</span><br><span class="line">                trapBubbledEvent(mediaEventTypes[i], domElement);</span><br><span class="line">            &#125;</span><br><span class="line">            props = rawProps;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;source&#x27;</span>:</span><br><span class="line">            trapBubbledEvent(TOP_ERROR, domElement);</span><br><span class="line">            props = rawProps;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;img&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;image&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;link&#x27;</span>:</span><br><span class="line">            trapBubbledEvent(TOP_ERROR, domElement);</span><br><span class="line">            trapBubbledEvent(TOP_LOAD, domElement);</span><br><span class="line">            props = rawProps;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;form&#x27;</span>:</span><br><span class="line">            trapBubbledEvent(TOP_RESET, domElement);</span><br><span class="line">            trapBubbledEvent(TOP_SUBMIT, domElement);</span><br><span class="line">            props = rawProps;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;details&#x27;</span>:</span><br><span class="line">            trapBubbledEvent(TOP_TOGGLE, domElement);</span><br><span class="line">            props = rawProps;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;input&#x27;</span>:</span><br><span class="line">            ReactDOMInputInitWrapperState(domElement, rawProps);</span><br><span class="line">            props = ReactDOMInputGetHostProps(domElement, rawProps);</span><br><span class="line">            trapBubbledEvent(TOP_INVALID, domElement);</span><br><span class="line">            <span class="comment">// For controlled components we always need to ensure we&#x27;re listening</span></span><br><span class="line">            <span class="comment">// to onChange. Even if there is no listener.</span></span><br><span class="line">            ensureListeningTo(rootContainerElement, <span class="string">&#x27;onChange&#x27;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;option&#x27;</span>:</span><br><span class="line">            ReactDOMOptionValidateProps(domElement, rawProps);</span><br><span class="line">            props = ReactDOMOptionGetHostProps(domElement, rawProps);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;select&#x27;</span>:</span><br><span class="line">            ReactDOMSelectInitWrapperState(domElement, rawProps);</span><br><span class="line">            props = ReactDOMSelectGetHostProps(domElement, rawProps);</span><br><span class="line">            trapBubbledEvent(TOP_INVALID, domElement);</span><br><span class="line">            <span class="comment">// For controlled components we always need to ensure we&#x27;re listening</span></span><br><span class="line">            <span class="comment">// to onChange. Even if there is no listener.</span></span><br><span class="line">            ensureListeningTo(rootContainerElement, <span class="string">&#x27;onChange&#x27;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;textarea&#x27;</span>:</span><br><span class="line">            ReactDOMTextareaInitWrapperState(domElement, rawProps);</span><br><span class="line">            props = ReactDOMTextareaGetHostProps(domElement, rawProps);</span><br><span class="line">            trapBubbledEvent(TOP_INVALID, domElement);</span><br><span class="line">            <span class="comment">// For controlled components we always need to ensure we&#x27;re listening</span></span><br><span class="line">            <span class="comment">// to onChange. Even if there is no listener.</span></span><br><span class="line">            ensureListeningTo(rootContainerElement, <span class="string">&#x27;onChange&#x27;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            props = rawProps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assertValidProps(tag, props); <span class="comment">// 判断props合法</span></span><br><span class="line">    setInitialDOMProperties(</span><br><span class="line">        <span class="comment">// 根据props设置dom属性, 事件绑定的开始</span></span><br><span class="line">        tag,</span><br><span class="line">        domElement,</span><br><span class="line">        rootContainerElement,</span><br><span class="line">        props,</span><br><span class="line">        isCustomComponentTag,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;input&#x27;</span>:</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Make sure we check if this is still unmounted or do any clean</span></span><br><span class="line">            <span class="comment">// up necessary since we never stop tracking anymore.</span></span><br><span class="line">            track((domElement: any));</span><br><span class="line">            ReactDOMInputPostMountWrapper(domElement, rawProps, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;textarea&#x27;</span>:</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Make sure we check if this is still unmounted or do any clean</span></span><br><span class="line">            <span class="comment">// up necessary since we never stop tracking anymore.</span></span><br><span class="line">            track((domElement: any));</span><br><span class="line">            ReactDOMTextareaPostMountWrapper(domElement, rawProps);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;option&#x27;</span>:</span><br><span class="line">            ReactDOMOptionPostMountWrapper(domElement, rawProps);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;select&#x27;</span>:</span><br><span class="line">            ReactDOMSelectPostMountWrapper(domElement, rawProps);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> props.onClick === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> This cast may not be sound for SVG, MathML or custom elements.</span></span><br><span class="line">                trapClickOnNonInteractiveElement(((domElement: any): HTMLElement));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>hooks</title>
    <url>/my-notes/2020/09/09/react/hooks/</url>
    <content><![CDATA[<p>在<code>renderWithHooks</code>中添加了方法,调用的 mount 或者 uodate 的 hooks 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ReactCurrentDispatcher.current =</span><br><span class="line">        nextCurrentHook === <span class="literal">null</span> ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行函数，得到children</span></span><br><span class="line"><span class="keyword">let</span> children = Component(props, refOrContext);</span><br></pre></td></tr></table></figure>

<h2 id="公共"><a href="#公共" class="headerlink" title="公共"></a>公共</h2><h3 id="mountWorkInProgressHook"><a href="#mountWorkInProgressHook" class="headerlink" title="mountWorkInProgressHook"></a>mountWorkInProgressHook</h3><p>基于这个方法，所有的 hooks 都在一条链上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountWorkInProgressHook</span>(<span class="params"></span>): <span class="title">Hook</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> hook: Hook = &#123;</span><br><span class="line">        memoizedState: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">        baseState: <span class="literal">null</span>,</span><br><span class="line">        queue: <span class="literal">null</span>,</span><br><span class="line">        baseUpdate: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">        next: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// This is the first hook in the list</span></span><br><span class="line">        firstWorkInProgressHook = workInProgressHook = hook;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Append to the end of the list</span></span><br><span class="line">        workInProgressHook = workInProgressHook.next = hook;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="updateWorkInProgressHook"><a href="#updateWorkInProgressHook" class="headerlink" title="updateWorkInProgressHook"></a>updateWorkInProgressHook</h3><p>在跟新时都有用到，用来记录当前工作的 hook 和 next hook</p>
<p>并返回一个 clone hook</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateWorkInProgressHook</span>(<span class="params"></span>): <span class="title">Hook</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function is used both for updates and for re-renders triggered by a</span></span><br><span class="line">    <span class="comment">// render phase update. It assumes there is either a current hook we can</span></span><br><span class="line">    <span class="comment">// clone, or a work-in-progress hook from a previous render pass that we can</span></span><br><span class="line">    <span class="comment">// use as a base. When we reach the end of the base list, we must switch to</span></span><br><span class="line">    <span class="comment">// the dispatcher used for mounts.</span></span><br><span class="line">    <span class="keyword">if</span> (nextWorkInProgressHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// There&#x27;s already a work-in-progress. Reuse it.</span></span><br><span class="line">        workInProgressHook = nextWorkInProgressHook;</span><br><span class="line">        nextWorkInProgressHook = workInProgressHook.next;</span><br><span class="line"></span><br><span class="line">        currentHook = nextCurrentHook;</span><br><span class="line">        nextCurrentHook = currentHook !== <span class="literal">null</span> ? currentHook.next : <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Clone from the current hook.</span></span><br><span class="line">        invariant(nextCurrentHook !== <span class="literal">null</span>, <span class="string">&#x27;Rendered more hooks than during the previous render.&#x27;</span>);</span><br><span class="line">        currentHook = nextCurrentHook;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> newHook: Hook = &#123;</span><br><span class="line">            memoizedState: currentHook.memoizedState,</span><br><span class="line"></span><br><span class="line">            baseState: currentHook.baseState,</span><br><span class="line">            queue: currentHook.queue,</span><br><span class="line">            baseUpdate: currentHook.baseUpdate,</span><br><span class="line"></span><br><span class="line">            next: <span class="literal">null</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// This is the first hook in the list.</span></span><br><span class="line">            workInProgressHook = firstWorkInProgressHook = newHook;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Append to the end of the list.</span></span><br><span class="line">            workInProgressHook = workInProgressHook.next = newHook;</span><br><span class="line">        &#125;</span><br><span class="line">        nextCurrentHook = currentHook.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法绑定"><a href="#方法绑定" class="headerlink" title="方法绑定"></a>方法绑定</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 应该是错误处理</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ContextOnlyDispatcher: Dispatcher = &#123;</span><br><span class="line">    readContext,</span><br><span class="line"></span><br><span class="line">    useCallback: throwInvalidHookError,</span><br><span class="line">    useContext: throwInvalidHookError,</span><br><span class="line">    useEffect: throwInvalidHookError,</span><br><span class="line">    useImperativeHandle: throwInvalidHookError,</span><br><span class="line">    useLayoutEffect: throwInvalidHookError,</span><br><span class="line">    useMemo: throwInvalidHookError,</span><br><span class="line">    useReducer: throwInvalidHookError,</span><br><span class="line">    useRef: throwInvalidHookError,</span><br><span class="line">    useState: throwInvalidHookError,</span><br><span class="line">    useDebugValue: throwInvalidHookError,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化用</span></span><br><span class="line"><span class="keyword">const</span> HooksDispatcherOnMount: Dispatcher = &#123;</span><br><span class="line">    readContext,</span><br><span class="line"></span><br><span class="line">    useCallback: mountCallback,</span><br><span class="line">    useContext: readContext,</span><br><span class="line">    useEffect: mountEffect,</span><br><span class="line">    useImperativeHandle: mountImperativeHandle,</span><br><span class="line">    useLayoutEffect: mountLayoutEffect,</span><br><span class="line">    useMemo: mountMemo,</span><br><span class="line">    useReducer: mountReducer,</span><br><span class="line">    useRef: mountRef,</span><br><span class="line">    useState: mountState,</span><br><span class="line">    useDebugValue: mountDebugValue,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟新用</span></span><br><span class="line"><span class="keyword">const</span> HooksDispatcherOnUpdate: Dispatcher = &#123;</span><br><span class="line">    readContext,</span><br><span class="line"></span><br><span class="line">    useCallback: updateCallback,</span><br><span class="line">    useContext: readContext,</span><br><span class="line">    useEffect: updateEffect,</span><br><span class="line">    useImperativeHandle: updateImperativeHandle,</span><br><span class="line">    useLayoutEffect: updateLayoutEffect,</span><br><span class="line">    useMemo: updateMemo,</span><br><span class="line">    useReducer: updateReducer,</span><br><span class="line">    useRef: updateRef,</span><br><span class="line">    useState: updateState,</span><br><span class="line">    useDebugValue: updateDebugValue,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useRef</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dispatcher = resolveDispatcher();</span><br><span class="line">    <span class="keyword">return</span> dispatcher.useRef(initialValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveDispatcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dispatcher = ReactCurrentDispatcher.current;</span><br><span class="line">    !(dispatcher !== <span class="literal">null</span>)</span><br><span class="line">        ? invariant(</span><br><span class="line">              <span class="literal">false</span>,</span><br><span class="line">              <span class="string">&#x27;Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.&#x27;</span>,</span><br><span class="line">          )</span><br><span class="line">        : <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> dispatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>然后进入<code>dispatcher.useRef</code>即<code>mountRef</code></p>
<h4 id="mountRef"><a href="#mountRef" class="headerlink" title="mountRef"></a>mountRef</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountRef</span>&lt;<span class="title">T</span>&gt;(<span class="params">initialValue: T</span>): </span>&#123;current: T&#125; &#123;</span><br><span class="line">    <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">    <span class="keyword">const</span> ref = &#123;<span class="attr">current</span>: initialValue&#125;;</span><br><span class="line">    hook.memoizedState = ref;</span><br><span class="line">    <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dispatcher = resolveDispatcher();</span><br><span class="line">    <span class="keyword">return</span> dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>开始都差不多，进入 <code>dispatcher.useState</code>即<code>mountState</code></p>
<h4 id="mountState"><a href="#mountState" class="headerlink" title="mountState"></a>mountState</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basicStateReducer</span>&lt;<span class="title">S</span>&gt;(<span class="params">state: S, action: BasicStateAction&lt;S&gt;</span>): <span class="title">S</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span> ? action(state) : action;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mountState&lt;S&gt;(initialState: (() =&gt; S) | S): [S, Dispatch&lt;BasicStateAction&lt;S&gt;&gt;] &#123;</span><br><span class="line">    <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        initialState = initialState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// memoizedState 最新结果</span></span><br><span class="line">    hook.memoizedState = hook.baseState = initialState;</span><br><span class="line">    <span class="keyword">const</span> queue = (hook.queue = &#123;</span><br><span class="line">        last: <span class="literal">null</span>,</span><br><span class="line">        dispatch: <span class="literal">null</span>,</span><br><span class="line">        lastRenderedReducer: basicStateReducer,</span><br><span class="line">        lastRenderedState: (initialState: any),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 跟新方法</span></span><br><span class="line">    <span class="keyword">const</span> dispatch: Dispatch&lt;BasicStateAction&lt;S&gt;&gt; = (queue.dispatch = (dispatchAction.bind(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="comment">// Flow doesn&#x27;t know this is non-null, but we do.</span></span><br><span class="line">        ((currentlyRenderingFiber: any): Fiber),</span><br><span class="line">        queue,</span><br><span class="line">    ): any));</span><br><span class="line">    <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><h4 id="dispatchAction"><a href="#dispatchAction" class="headerlink" title="dispatchAction"></a>dispatchAction</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object.is polyfill</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is</span>(<span class="params">x: any, y: any</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        (x === y &amp;&amp; (x !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y)) || (x !== x &amp;&amp; y !== y) <span class="comment">// eslint-disable-line no-self-compare</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// action 已经计算好的值，即setXXX的传参,</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchAction</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params">fiber: Fiber, queue: UpdateQueue&lt;S, A&gt;, action: A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> alternate = fiber.alternate;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        fiber === currentlyRenderingFiber ||</span><br><span class="line">        (alternate !== <span class="literal">null</span> &amp;&amp; alternate === currentlyRenderingFiber)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// This is a render phase update. Stash it in a lazily-created map of</span></span><br><span class="line">        <span class="comment">// queue -&gt; linked list of updates. After this render pass, we&#x27;ll restart</span></span><br><span class="line">        <span class="comment">// and apply the stashed updates on top of the work-in-progress hook.</span></span><br><span class="line">        didScheduleRenderPhaseUpdate = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">            expirationTime: renderExpirationTime,</span><br><span class="line">            suspenseConfig: <span class="literal">null</span>,</span><br><span class="line">            action,</span><br><span class="line">            eagerReducer: <span class="literal">null</span>,</span><br><span class="line">            eagerState: <span class="literal">null</span>,</span><br><span class="line">            next: <span class="literal">null</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (renderPhaseUpdates === <span class="literal">null</span>) &#123;</span><br><span class="line">            renderPhaseUpdates = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);</span><br><span class="line">        <span class="keyword">if</span> (firstRenderPhaseUpdate === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            renderPhaseUpdates.set(queue, update);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Append the update to the end of the list.</span></span><br><span class="line">            <span class="keyword">let</span> lastRenderPhaseUpdate = firstRenderPhaseUpdate;</span><br><span class="line">            <span class="keyword">while</span> (lastRenderPhaseUpdate.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">                lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;</span><br><span class="line">            &#125;</span><br><span class="line">            lastRenderPhaseUpdate.next = update;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (revertPassiveEffectsChange) &#123;</span><br><span class="line">            flushPassiveEffects();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> currentTime = requestCurrentTime();</span><br><span class="line">        <span class="keyword">const</span> suspenseConfig = requestCurrentSuspenseConfig();</span><br><span class="line">        <span class="keyword">const</span> expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> update: Update&lt;S, A&gt; = &#123;</span><br><span class="line">            expirationTime,</span><br><span class="line">            suspenseConfig,</span><br><span class="line">            action,</span><br><span class="line">            eagerReducer: <span class="literal">null</span>,</span><br><span class="line">            eagerState: <span class="literal">null</span>,</span><br><span class="line">            next: <span class="literal">null</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Append the update to the end of the list.</span></span><br><span class="line">        <span class="keyword">const</span> last = queue.last;</span><br><span class="line">        <span class="keyword">if</span> (last === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// This is the first update. Create a circular list.</span></span><br><span class="line">            update.next = update;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> first = last.next;</span><br><span class="line">            <span class="keyword">if</span> (first !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Still circular.</span></span><br><span class="line">                update.next = first;</span><br><span class="line">            &#125;</span><br><span class="line">            last.next = update;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// queue里放着就数据，last是新数据</span></span><br><span class="line">        queue.last = update;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            fiber.expirationTime === NoWork &amp;&amp;</span><br><span class="line">            (alternate === <span class="literal">null</span> || alternate.expirationTime === NoWork)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// The queue is currently empty, which means we can eagerly compute the</span></span><br><span class="line">            <span class="comment">// next state before entering the render phase. If the new state is the</span></span><br><span class="line">            <span class="comment">// same as the current state, we may be able to bail out entirely.</span></span><br><span class="line">            <span class="keyword">const</span> lastRenderedReducer = queue.lastRenderedReducer;</span><br><span class="line">            <span class="keyword">if</span> (lastRenderedReducer !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> prevDispatcher;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 上一个值</span></span><br><span class="line">                    <span class="keyword">const</span> currentState: S = (queue.lastRenderedState: any);</span><br><span class="line">                    <span class="comment">// 最新值</span></span><br><span class="line">                    <span class="keyword">const</span> eagerState = lastRenderedReducer(currentState, action);</span><br><span class="line">                    <span class="comment">// Stash the eagerly computed state, and the reducer used to compute</span></span><br><span class="line">                    <span class="comment">// it, on the update object. If the reducer hasn&#x27;t changed by the</span></span><br><span class="line">                    <span class="comment">// time we enter the render phase, then the eager state can be used</span></span><br><span class="line">                    <span class="comment">// without calling the reducer again.</span></span><br><span class="line">                    update.eagerReducer = lastRenderedReducer;</span><br><span class="line">                    update.eagerState = eagerState;</span><br><span class="line">                    <span class="comment">// 即Object.is,相同就return</span></span><br><span class="line">                    <span class="keyword">if</span> (is(eagerState, currentState)) &#123;</span><br><span class="line">                        <span class="comment">// Fast path. We can bail out without scheduling React to re-render.</span></span><br><span class="line">                        <span class="comment">// It&#x27;s still possible that we&#x27;ll need to rebase this update later,</span></span><br><span class="line">                        <span class="comment">// if the component re-renders for a different reason and by that</span></span><br><span class="line">                        <span class="comment">// time the reducer has changed.</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    <span class="comment">// Suppress the error. It will throw again in the render phase.</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">                        ReactCurrentDispatcher.current = prevDispatcher;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有跟新，就去scheduleWork</span></span><br><span class="line">        scheduleWork(fiber, expirationTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="scheduleWork"><a href="#scheduleWork" class="headerlink" title="scheduleWork"></a>scheduleWork</h4><p>见 schedule.md</p>
<h3 id="跟新"><a href="#跟新" class="headerlink" title="跟新"></a>跟新</h3><p>跟新时 <code>dispatcher.useState</code> = <code>updateState</code></p>
<h4 id="updateState"><a href="#updateState" class="headerlink" title="updateState"></a>updateState</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">function updateState&lt;S&gt;(initialState: (() =&gt; S) | S): [S, Dispatch&lt;BasicStateAction&lt;S&gt;&gt;] &#123;</span><br><span class="line">    <span class="keyword">return</span> updateReducer(basicStateReducer, (initialState: any));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateReducer</span>&lt;<span class="title">S</span>, <span class="title">I</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    reducer: (S, A) =&gt; S,</span></span></span><br><span class="line"><span class="function"><span class="params">    initialArg: I,</span></span></span><br><span class="line"><span class="function"><span class="params">    init?: (I) =&gt; S,</span></span></span><br><span class="line">): [S, Dispatch&lt;A&gt;] &#123;</span><br><span class="line">    <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">    <span class="keyword">const</span> queue = hook.queue;</span><br><span class="line">    invariant(</span><br><span class="line">        queue !== <span class="literal">null</span>,</span><br><span class="line">        <span class="string">&#x27;Should have a queue. This is likely a bug in React. Please file an issue.&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    queue.lastRenderedReducer = reducer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numberOfReRenders &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// This is a re-render. Apply the new render phase updates to the previous</span></span><br><span class="line">        <span class="comment">// work-in-progress hook.</span></span><br><span class="line">        <span class="keyword">const</span> dispatch: Dispatch&lt;A&gt; = (queue.dispatch: any);</span><br><span class="line">        <span class="keyword">if</span> (renderPhaseUpdates !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Render phase updates are stored in a map of queue -&gt; linked list</span></span><br><span class="line">            <span class="keyword">const</span> firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);</span><br><span class="line">            <span class="keyword">if</span> (firstRenderPhaseUpdate !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                renderPhaseUpdates.delete(queue);</span><br><span class="line">                <span class="keyword">let</span> newState = hook.memoizedState;</span><br><span class="line">                <span class="keyword">let</span> update = firstRenderPhaseUpdate;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// Process this render phase update. We don&#x27;t have to check the</span></span><br><span class="line">                    <span class="comment">// priority because it will always be the same as the current</span></span><br><span class="line">                    <span class="comment">// render&#x27;s.</span></span><br><span class="line">                    <span class="keyword">const</span> action = update.action;</span><br><span class="line">                    newState = reducer(newState, action);</span><br><span class="line">                    update = update.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (update !== <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Mark that the fiber performed work, but only if the new state is</span></span><br><span class="line">                <span class="comment">// different from the current state.</span></span><br><span class="line">                <span class="keyword">if</span> (!is(newState, hook.memoizedState)) &#123;</span><br><span class="line">                    markWorkInProgressReceivedUpdate();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                hook.memoizedState = newState;</span><br><span class="line">                <span class="comment">// Don&#x27;t persist the state accumlated from the render phase updates to</span></span><br><span class="line">                <span class="comment">// the base state unless the queue is empty.</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Not sure if this is the desired semantics, but it&#x27;s what we</span></span><br><span class="line">                <span class="comment">// do for gDSFP. I can&#x27;t remember why.</span></span><br><span class="line">                <span class="keyword">if</span> (hook.baseUpdate === queue.last) &#123;</span><br><span class="line">                    hook.baseState = newState;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                queue.lastRenderedState = newState;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> [newState, dispatch];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The last update in the entire queue</span></span><br><span class="line">    <span class="keyword">const</span> last = queue.last;</span><br><span class="line">    <span class="comment">// The last update that is part of the base state.</span></span><br><span class="line">    <span class="keyword">const</span> baseUpdate = hook.baseUpdate;</span><br><span class="line">    <span class="keyword">const</span> baseState = hook.baseState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the first unprocessed update.</span></span><br><span class="line">    <span class="keyword">let</span> first;</span><br><span class="line">    <span class="keyword">if</span> (baseUpdate !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (last !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// For the first update, the queue is a circular linked list where</span></span><br><span class="line">            <span class="comment">// `queue.last.next = queue.first`. Once the first update commits, and</span></span><br><span class="line">            <span class="comment">// the `baseUpdate` is no longer empty, we can unravel the list.</span></span><br><span class="line">            last.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        first = baseUpdate.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        first = last !== <span class="literal">null</span> ? last.next : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (first !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 新 state 数据</span></span><br><span class="line">        <span class="keyword">let</span> newState = baseState;</span><br><span class="line">        <span class="keyword">let</span> newBaseState = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> newBaseUpdate = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> prevUpdate = baseUpdate;</span><br><span class="line">        <span class="keyword">let</span> update = first;</span><br><span class="line">        <span class="keyword">let</span> didSkip = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> updateExpirationTime = update.expirationTime;</span><br><span class="line">            <span class="keyword">if</span> (updateExpirationTime &lt; renderExpirationTime) &#123;</span><br><span class="line">                <span class="comment">// Priority is insufficient. Skip this update. If this is the first</span></span><br><span class="line">                <span class="comment">// skipped update, the previous update/state is the new base</span></span><br><span class="line">                <span class="comment">// update/state.</span></span><br><span class="line">                <span class="keyword">if</span> (!didSkip) &#123;</span><br><span class="line">                    didSkip = <span class="literal">true</span>;</span><br><span class="line">                    newBaseUpdate = prevUpdate;</span><br><span class="line">                    newBaseState = newState;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Update the remaining priority in the queue.</span></span><br><span class="line">                <span class="keyword">if</span> (updateExpirationTime &gt; remainingExpirationTime) &#123;</span><br><span class="line">                    remainingExpirationTime = updateExpirationTime;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// This update does have sufficient priority.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Mark the event time of this update as relevant to this render pass.</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> This should ideally use the true event time of this update rather than</span></span><br><span class="line">                <span class="comment">// its priority which is a derived and not reverseable value.</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> We should skip this update if it was already committed but currently</span></span><br><span class="line">                <span class="comment">// we have no way of detecting the difference between a committed and suspended</span></span><br><span class="line">                <span class="comment">// update here.</span></span><br><span class="line">                markRenderEventTimeAndConfig(updateExpirationTime, update.suspenseConfig);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Process this update.</span></span><br><span class="line">                <span class="keyword">if</span> (update.eagerReducer === reducer) &#123;</span><br><span class="line">                    <span class="comment">// If this update was processed eagerly, and its reducer matches the</span></span><br><span class="line">                    <span class="comment">// current reducer, we can use the eagerly computed state.</span></span><br><span class="line">                    newState = ((update.eagerState: any): S);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> action = update.action;</span><br><span class="line">                    newState = reducer(newState, action);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            prevUpdate = update;</span><br><span class="line">            update = update.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!didSkip) &#123;</span><br><span class="line">            newBaseUpdate = prevUpdate;</span><br><span class="line">            newBaseState = newState;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mark that the fiber performed work, but only if the new state is</span></span><br><span class="line">        <span class="comment">// different from the current state.</span></span><br><span class="line">        <span class="comment">// 标记fiber已完成工作，前提是新旧数据不同，通过Object.is</span></span><br><span class="line">        <span class="keyword">if</span> (!is(newState, hook.memoizedState)) &#123;</span><br><span class="line">            markWorkInProgressReceivedUpdate();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hook.memoizedState = newState;</span><br><span class="line">        hook.baseUpdate = newBaseUpdate;</span><br><span class="line">        hook.baseState = newBaseState;</span><br><span class="line"></span><br><span class="line">        queue.lastRenderedState = newState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dispatch: Dispatch&lt;A&gt; = (queue.dispatch: any);</span><br><span class="line">    <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="updateWorkInProgressHook-1"><a href="#updateWorkInProgressHook-1" class="headerlink" title="updateWorkInProgressHook"></a>updateWorkInProgressHook</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateWorkInProgressHook</span>(<span class="params"></span>): <span class="title">Hook</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function is used both for updates and for re-renders triggered by a</span></span><br><span class="line">    <span class="comment">// render phase update. It assumes there is either a current hook we can</span></span><br><span class="line">    <span class="comment">// clone, or a work-in-progress hook from a previous render pass that we can</span></span><br><span class="line">    <span class="comment">// use as a base. When we reach the end of the base list, we must switch to</span></span><br><span class="line">    <span class="comment">// the dispatcher used for mounts.</span></span><br><span class="line">    <span class="keyword">if</span> (nextWorkInProgressHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// There&#x27;s already a work-in-progress. Reuse it.</span></span><br><span class="line">        workInProgressHook = nextWorkInProgressHook;</span><br><span class="line">        nextWorkInProgressHook = workInProgressHook.next;</span><br><span class="line"></span><br><span class="line">        currentHook = nextCurrentHook;</span><br><span class="line">        nextCurrentHook = currentHook !== <span class="literal">null</span> ? currentHook.next : <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Clone from the current hook.</span></span><br><span class="line">        invariant(nextCurrentHook !== <span class="literal">null</span>, <span class="string">&#x27;Rendered more hooks than during the previous render.&#x27;</span>);</span><br><span class="line">        currentHook = nextCurrentHook;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clone 当前 hook</span></span><br><span class="line">        <span class="keyword">const</span> newHook: Hook = &#123;</span><br><span class="line">            memoizedState: currentHook.memoizedState,</span><br><span class="line"></span><br><span class="line">            baseState: currentHook.baseState,</span><br><span class="line">            queue: currentHook.queue,</span><br><span class="line">            baseUpdate: currentHook.baseUpdate,</span><br><span class="line"></span><br><span class="line">            next: <span class="literal">null</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// This is the first hook in the list.</span></span><br><span class="line">            workInProgressHook = firstWorkInProgressHook = newHook;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Append to the end of the list.</span></span><br><span class="line">            workInProgressHook = workInProgressHook.next = newHook;</span><br><span class="line">        &#125;</span><br><span class="line">        nextCurrentHook = currentHook.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><h3 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h3><h4 id="mountEffect-和-mountEffectImpl"><a href="#mountEffect-和-mountEffectImpl" class="headerlink" title="mountEffect 和 mountEffectImpl"></a>mountEffect 和 mountEffectImpl</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffect</span>(<span class="params">create: () =&gt; (() =&gt; void) | void, deps: Array&lt;mixed&gt; | void | null</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mountEffectImpl(</span><br><span class="line">        UpdateEffect | PassiveEffect, <span class="comment">// 有这两种effect处理</span></span><br><span class="line">        UnmountPassive | MountPassive, <span class="comment">// 192</span></span><br><span class="line">        create,</span><br><span class="line">        deps,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffectImpl</span>(<span class="params">fiberEffectTag, hookEffectTag, create, deps</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">    <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">    sideEffectTag |= fiberEffectTag;</span><br><span class="line">    hook.memoizedState = pushEffect(hookEffectTag, create, <span class="literal">undefined</span>, nextDeps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pushEffect"><a href="#pushEffect" class="headerlink" title="pushEffect"></a>pushEffect</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushEffect</span>(<span class="params">tag, create, destroy, deps</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> effect: Effect = &#123;</span><br><span class="line">        tag,</span><br><span class="line">        create,</span><br><span class="line">        destroy,</span><br><span class="line">        deps,</span><br><span class="line">        <span class="comment">// Circular</span></span><br><span class="line">        next: (<span class="literal">null</span>: any),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (componentUpdateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">        componentUpdateQueue = createFunctionComponentUpdateQueue();</span><br><span class="line">        componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> lastEffect = componentUpdateQueue.lastEffect;</span><br><span class="line">        <span class="keyword">if</span> (lastEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">            componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">            lastEffect.next = effect;</span><br><span class="line">            effect.next = firstEffect;</span><br><span class="line">            componentUpdateQueue.lastEffect = effect;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> effect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行-1"><a href="#执行-1" class="headerlink" title="执行"></a>执行</h3><p>从 <code>commitRoot</code>开始</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 开始渲染流程</span></span><br><span class="line">    <span class="comment">// debugger;</span></span><br><span class="line">    <span class="comment">// 优先级相关，最后还是运行commitRootImpl</span></span><br><span class="line">    runWithPriority(ImmediatePriority, commitRootImpl.bind(<span class="literal">null</span>, root)); <span class="comment">// 渲染并执行componentDidMount</span></span><br><span class="line">    <span class="comment">// If there are passive effects, schedule a callback to flush them. This goes</span></span><br><span class="line">    <span class="comment">// outside commitRootImpl so that it inherits the priority of the render.</span></span><br><span class="line">    <span class="keyword">if</span> (rootWithPendingPassiveEffects !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// debugger;</span></span><br><span class="line">        <span class="comment">// 这里是调度管理，先不看，直接进里面</span></span><br><span class="line">        <span class="keyword">const</span> priorityLevel = getCurrentPriorityLevel();</span><br><span class="line">        scheduleCallback(priorityLevel, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// hooks的useEffect在这里执行,不过是在RequestAnimationFrame里,不好一步追踪到这，只能打断点反追</span></span><br><span class="line">            flushPassiveEffects();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="flushPassiveEffects"><a href="#flushPassiveEffects" class="headerlink" title="flushPassiveEffects"></a>flushPassiveEffects</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">flushPassiveEffects</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rootWithPendingPassiveEffects === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> root = rootWithPendingPassiveEffects;</span><br><span class="line">    <span class="keyword">const</span> expirationTime = pendingPassiveEffectsExpirationTime;</span><br><span class="line">    rootWithPendingPassiveEffects = <span class="literal">null</span>;</span><br><span class="line">    pendingPassiveEffectsExpirationTime = NoWork;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> prevInteractions: <span class="built_in">Set</span>&lt;Interaction&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> prevExecutionContext = executionContext;</span><br><span class="line">    executionContext |= CommitContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: This currently assumes there are no passive effects on the root</span></span><br><span class="line">    <span class="comment">// fiber, because the root is not part of its own effect list. This could</span></span><br><span class="line">    <span class="comment">// change in the future.</span></span><br><span class="line">    <span class="keyword">let</span> effect = root.current.firstEffect;</span><br><span class="line">    <span class="keyword">while</span> (effect !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                commitPassiveHookEffects(effect);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                invariant(effect !== <span class="literal">null</span>, <span class="string">&#x27;Should be working on an effect.&#x27;</span>);</span><br><span class="line">                captureCommitPhaseError(effect, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        effect = effect.nextEffect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    executionContext = prevExecutionContext;</span><br><span class="line">    flushSyncCallbackQueue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If additional passive effects were scheduled, increment a counter. If this</span></span><br><span class="line">    <span class="comment">// exceeds the limit, we&#x27;ll fire a warning.</span></span><br><span class="line">    nestedPassiveUpdateCount =</span><br><span class="line">        rootWithPendingPassiveEffects === <span class="literal">null</span> ? <span class="number">0</span> : nestedPassiveUpdateCount + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="commitPassiveHookEffects"><a href="#commitPassiveHookEffects" class="headerlink" title="commitPassiveHookEffects"></a>commitPassiveHookEffects</h4><p>先执行卸载的<code>return</code>,在执行本体</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">commitPassiveHookEffects</span>(<span class="params">finishedWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    commitHookEffectList(UnmountPassive, NoHookEffect, finishedWork);</span><br><span class="line">    commitHookEffectList(NoHookEffect, MountPassive, finishedWork);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="commitHookEffectList"><a href="#commitHookEffectList" class="headerlink" title="commitHookEffectList"></a>commitHookEffectList</h4><p>这个方法在很多地方都有用到，目前已知的从<code>commitPassiveHookEffects</code>过来的是<code>useEffect</code>,其他未知</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitHookEffectList</span>(<span class="params">unmountTag: number, mountTag: number, finishedWork: Fiber</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> updateQueue: FunctionComponentUpdateQueue | <span class="literal">null</span> = (finishedWork.updateQueue: any);</span><br><span class="line">    <span class="keyword">let</span> lastEffect = updateQueue !== <span class="literal">null</span> ? updateQueue.lastEffect : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">        <span class="keyword">let</span> effect = firstEffect;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((effect.tag &amp; unmountTag) !== NoHookEffect) &#123;</span><br><span class="line">                <span class="comment">// Unmount</span></span><br><span class="line">                <span class="keyword">const</span> destroy = effect.destroy;</span><br><span class="line">                effect.destroy = <span class="literal">undefined</span>;</span><br><span class="line">                <span class="keyword">if</span> (destroy !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    destroy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((effect.tag &amp; mountTag) !== NoHookEffect) &#123;</span><br><span class="line">                <span class="comment">// Mount</span></span><br><span class="line">                <span class="keyword">const</span> create = effect.create;</span><br><span class="line">                <span class="comment">// return就是destroy</span></span><br><span class="line">                effect.destroy = create();</span><br><span class="line">            &#125;</span><br><span class="line">            effect = effect.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (effect !== firstEffect);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><h4 id="updateEffect"><a href="#updateEffect" class="headerlink" title="updateEffect"></a>updateEffect</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffect</span>(<span class="params">create: () =&gt; (() =&gt; void) | void, deps: Array&lt;mixed&gt; | void | null</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> updateEffectImpl(</span><br><span class="line">        UpdateEffect | PassiveEffect,</span><br><span class="line">        UnmountPassive | MountPassive,</span><br><span class="line">        create,</span><br><span class="line">        deps,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffectImpl</span>(<span class="params">fiberEffectTag, hookEffectTag, create, deps</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">    <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">    <span class="keyword">let</span> destroy = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> prevEffect = currentHook.memoizedState;</span><br><span class="line">        destroy = prevEffect.destroy;</span><br><span class="line">        <span class="comment">// 判断依赖是否有变，</span></span><br><span class="line">        <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> prevDeps = prevEffect.deps;</span><br><span class="line">            <span class="comment">//  循环依赖，用Object.is</span></span><br><span class="line">            <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">                <span class="comment">// 依赖不变，是NoHookEffect，所以useEffect不执行destroy和create</span></span><br><span class="line">                pushEffect(NoHookEffect, create, destroy, nextDeps);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只有依赖有变或者没依赖才有fiberEffectTag标记，不过没发现有什么用</span></span><br><span class="line">    sideEffectTag |= fiberEffectTag;</span><br><span class="line">    hook.memoizedState = pushEffect(hookEffectTag, create, destroy, nextDeps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><p>context 见 context.md</p>
]]></content>
      <tags>
        <tag>react源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>reconcileChildFibers</title>
    <url>/my-notes/2020/09/10/react/schedule/</url>
    <content><![CDATA[<h3 id="scheduleWork"><a href="#scheduleWork" class="headerlink" title="scheduleWork"></a>scheduleWork</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">scheduleUpdateOnFiber</span>(<span class="params">fiber: Fiber, expirationTime: ExpirationTime</span>) </span>&#123;</span><br><span class="line">    checkForNestedUpdates(); <span class="comment">// 判断是否超出更新限制 50条，否则报错</span></span><br><span class="line">    <span class="comment">// 根节点：更新了fiber.stateNode的时间，返回fiber.stateNode，即FiberRoot</span></span><br><span class="line">    <span class="comment">// 子节点： 返回根节点</span></span><br><span class="line">    <span class="keyword">const</span> root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root.pingTime = NoWork;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回优先级,见常量 ReactPriorityLevel</span></span><br><span class="line">    <span class="comment">// 已知第一次渲染是97，setState是98，useState是98</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>currentPriorityLevel仅在flushTask李改变，目前还没找到什么时候调用过</span></span><br><span class="line">    <span class="keyword">const</span> priorityLevel = getCurrentPriorityLevel();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expirationTime === Sync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// Check if we&#x27;re inside unbatchedUpdates 8 &amp; 8 = 8 !== 0</span></span><br><span class="line">            (executionContext &amp; LegacyUnbatchedContext) !== NoContext &amp;&amp;</span><br><span class="line">            <span class="comment">// Check if we&#x27;re not already rendering 8 &amp; (16 | 32) = 0</span></span><br><span class="line">            (executionContext &amp; (RenderContext | CommitContext)) === NoContext</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// This is a legacy edge case. The initial mount of a ReactDOM.render-ed</span></span><br><span class="line">            <span class="comment">// root inside of batchedUpdates should be synchronous, but layout updates</span></span><br><span class="line">            <span class="comment">// should be deferred until the end of the batch.</span></span><br><span class="line">            <span class="keyword">let</span> callback = renderRoot(root, Sync, <span class="literal">true</span>); <span class="comment">// 返回commitRoot</span></span><br><span class="line">            <span class="comment">// 前景：react完成了fiber树的构建并已经执行了渲染前的状态合并(getDerivedStateFromProps等生命周期已执行)</span></span><br><span class="line">            <span class="comment">// fiber树里已经构建好了真实的dom节点，放在stateNode里，就差一步插入了</span></span><br><span class="line">            <span class="comment">// debugger</span></span><br><span class="line">            <span class="keyword">while</span> (callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">                callback = callback(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// setState, useState进这里</span></span><br><span class="line">            scheduleCallbackForRoot(root, ImmediatePriority, Sync);</span><br><span class="line">            <span class="keyword">if</span> (executionContext === NoContext) &#123;</span><br><span class="line">                <span class="comment">// Flush the synchronous work now, wnless we&#x27;re already working or inside</span></span><br><span class="line">                <span class="comment">// a batch. This is intentionally inside scheduleUpdateOnFiber instead of</span></span><br><span class="line">                <span class="comment">// scheduleCallbackForFiber to preserve the ability to schedule a callback</span></span><br><span class="line">                <span class="comment">// without immediately flushing it. We only do this for user-initated</span></span><br><span class="line">                <span class="comment">// updates, to preserve historical behavior of sync mode.</span></span><br><span class="line">                flushSyncCallbackQueue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        scheduleCallbackForRoot(root, priorityLevel, expirationTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        (executionContext &amp; DiscreteEventContext) !== NoContext &amp;&amp;</span><br><span class="line">        <span class="comment">// Only updates at user-blocking priority or greater are considered</span></span><br><span class="line">        <span class="comment">// discrete, even inside a discrete event.</span></span><br><span class="line">        (priorityLevel === UserBlockingPriority || priorityLevel === ImmediatePriority)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// This is the result of a discrete event. Track the lowest priority</span></span><br><span class="line">        <span class="comment">// discrete update per root so we can flush them early, if needed.</span></span><br><span class="line">        <span class="keyword">if</span> (rootsWithPendingDiscreteUpdates === <span class="literal">null</span>) &#123;</span><br><span class="line">            rootsWithPendingDiscreteUpdates = <span class="keyword">new</span> <span class="built_in">Map</span>([[root, expirationTime]]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root);</span><br><span class="line">            <span class="keyword">if</span> (lastDiscreteTime === <span class="literal">undefined</span> || lastDiscreteTime &gt; expirationTime) &#123;</span><br><span class="line">                rootsWithPendingDiscreteUpdates.set(root, expirationTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> scheduleWork = scheduleUpdateOnFiber;</span><br></pre></td></tr></table></figure>

<h3 id="markUpdateTimeFromFiberToRoot"><a href="#markUpdateTimeFromFiberToRoot" class="headerlink" title="markUpdateTimeFromFiberToRoot"></a>markUpdateTimeFromFiberToRoot</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markUpdateTimeFromFiberToRoot</span>(<span class="params">fiber, expirationTime</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Update the source fiber&#x27;s expiration time</span></span><br><span class="line">    <span class="comment">// fiber.expirationTime默认是0</span></span><br><span class="line">    <span class="keyword">if</span> (fiber.expirationTime &lt; expirationTime) &#123;</span><br><span class="line">        fiber.expirationTime = expirationTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> alternate = fiber.alternate;</span><br><span class="line">    <span class="keyword">if</span> (alternate !== <span class="literal">null</span> &amp;&amp; alternate.expirationTime &lt; expirationTime) &#123;</span><br><span class="line">        alternate.expirationTime = expirationTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Walk the parent path to the root and update the child expiration time.</span></span><br><span class="line">    <span class="keyword">let</span> node = fiber.return;</span><br><span class="line">    <span class="keyword">let</span> root = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span> &amp;&amp; fiber.tag === HostRoot) &#123;</span><br><span class="line">        <span class="comment">// 3 === 3</span></span><br><span class="line">        root = fiber.stateNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">            alternate = node.alternate;</span><br><span class="line">            <span class="comment">// 跟新childExpirationTime</span></span><br><span class="line">            <span class="keyword">if</span> (node.childExpirationTime &lt; expirationTime) &#123;</span><br><span class="line">                node.childExpirationTime = expirationTime;</span><br><span class="line">                <span class="keyword">if</span> (alternate !== <span class="literal">null</span> &amp;&amp; alternate.childExpirationTime &lt; expirationTime) &#123;</span><br><span class="line">                    alternate.childExpirationTime = expirationTime;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alternate !== <span class="literal">null</span> &amp;&amp; alternate.childExpirationTime &lt; expirationTime) &#123;</span><br><span class="line">                alternate.childExpirationTime = expirationTime;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.return === <span class="literal">null</span> &amp;&amp; node.tag === HostRoot) &#123;</span><br><span class="line">                root = node.stateNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 注释：跟新根节点的firstPendingTime和lastPendingTime</span></span><br><span class="line">        <span class="comment">// Update the first and last pending expiration times in this root</span></span><br><span class="line">        <span class="keyword">const</span> firstPendingTime = root.firstPendingTime;</span><br><span class="line">        <span class="keyword">if</span> (expirationTime &gt; firstPendingTime) &#123;</span><br><span class="line">            root.firstPendingTime = expirationTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> lastPendingTime = root.lastPendingTime;</span><br><span class="line">        <span class="keyword">if</span> (lastPendingTime === NoWork || expirationTime &lt; lastPendingTime) &#123;</span><br><span class="line">            root.lastPendingTime = expirationTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="scheduleCallbackForRoot"><a href="#scheduleCallbackForRoot" class="headerlink" title="scheduleCallbackForRoot"></a>scheduleCallbackForRoot</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use this function, along with runRootCallback, to ensure that only a single</span></span><br><span class="line"><span class="comment">// callback per root is scheduled. It&#x27;s still possible to call renderRoot</span></span><br><span class="line"><span class="comment">// directly, but scheduling via this function helps avoid excessive callbacks.</span></span><br><span class="line"><span class="comment">// It works by storing the callback node and expiration time on the root. When a</span></span><br><span class="line"><span class="comment">// new callback comes in, it compares the expiration time to determine if it</span></span><br><span class="line"><span class="comment">// should cancel the previous one. It also relies on commitRoot scheduling a</span></span><br><span class="line"><span class="comment">// callback to render the next level, because that means we don&#x27;t need a</span></span><br><span class="line"><span class="comment">// separate callback per expiration time.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleCallbackForRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">    priorityLevel: ReactPriorityLevel,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> existingCallbackExpirationTime = root.callbackExpirationTime;</span><br><span class="line">    <span class="keyword">if</span> (existingCallbackExpirationTime &lt; expirationTime) &#123;</span><br><span class="line">        <span class="comment">// New callback has higher priority than the existing one.</span></span><br><span class="line">        <span class="keyword">const</span> existingCallbackNode = root.callbackNode;</span><br><span class="line">        <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">            cancelCallback(existingCallbackNode);</span><br><span class="line">        &#125;</span><br><span class="line">        root.callbackExpirationTime = expirationTime;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expirationTime === Sync) &#123;</span><br><span class="line">            <span class="comment">// Sync React callbacks are scheduled on a special internal queue</span></span><br><span class="line">            <span class="comment">// 同步的放在一个队列中</span></span><br><span class="line">            root.callbackNode = scheduleSyncCallback(</span><br><span class="line">                runRootCallback.bind(<span class="literal">null</span>, root, renderRoot.bind(<span class="literal">null</span>, root, expirationTime)),</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> options = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (expirationTime !== Never) &#123;</span><br><span class="line">                <span class="keyword">let</span> timeout = expirationTimeToMs(expirationTime) - now();</span><br><span class="line">                options = &#123;timeout&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            root.callbackNode = scheduleCallback(</span><br><span class="line">                priorityLevel,</span><br><span class="line">                runRootCallback.bind(<span class="literal">null</span>, root, renderRoot.bind(<span class="literal">null</span>, root, expirationTime)),</span><br><span class="line">                options,</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                enableUserTimingAPI &amp;&amp;</span><br><span class="line">                expirationTime !== Sync &amp;&amp;</span><br><span class="line">                (executionContext &amp; (RenderContext | CommitContext)) === NoContext</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// Scheduled an async callback, and we&#x27;re not already working. Add an</span></span><br><span class="line">                <span class="comment">// entry to the flamegraph that shows we&#x27;re waiting for a callback</span></span><br><span class="line">                <span class="comment">// to fire.</span></span><br><span class="line">                startRequestCallbackTimer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Associate the current interactions with this new root+priority.</span></span><br><span class="line">    schedulePendingInteractions(root, expirationTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="scheduleSyncCallback"><a href="#scheduleSyncCallback" class="headerlink" title="scheduleSyncCallback"></a>scheduleSyncCallback</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> syncQueue: <span class="built_in">Array</span>&lt;SchedulerCallback&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">scheduleSyncCallback</span>(<span class="params">callback: SchedulerCallback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Push this callback into an internal queue. We&#x27;ll flush these either in</span></span><br><span class="line">    <span class="comment">// the next tick, or earlier if something calls `flushSyncCallbackQueue`.</span></span><br><span class="line">    <span class="keyword">if</span> (syncQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">        syncQueue = [callback];</span><br><span class="line">        <span class="comment">// Flush the queue in the next tick, at the earliest.</span></span><br><span class="line">        immediateQueueCallbackNode = Scheduler_scheduleCallback(</span><br><span class="line">            Scheduler_ImmediatePriority, <span class="comment">// 立即优先级 1</span></span><br><span class="line">            flushSyncCallbackQueueImpl, <span class="comment">// 回调方法 执行syncQueue里的方法</span></span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Push onto existing queue. Don&#x27;t need to schedule a callback because</span></span><br><span class="line">        <span class="comment">// we already scheduled one when we created the queue.</span></span><br><span class="line">        syncQueue.push(callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fakeCallbackNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Scheduler-scheduleCallback"><a href="#Scheduler-scheduleCallback" class="headerlink" title="Scheduler_scheduleCallback"></a>Scheduler_scheduleCallback</h3><p>即<code>unstable_scheduleCallback</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_scheduleCallback</span>(<span class="params">priorityLevel, callback, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currentTime = getCurrentTime(); <span class="comment">// 获取当前时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> startTime;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">&#x27;object&#x27;</span> &amp;&amp; options !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> delay = options.delay;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> delay === <span class="string">&#x27;number&#x27;</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            startTime = currentTime + delay;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startTime = currentTime;</span><br><span class="line">        &#125;</span><br><span class="line">        timeout =</span><br><span class="line">            <span class="keyword">typeof</span> options.timeout === <span class="string">&#x27;number&#x27;</span></span><br><span class="line">                ? options.timeout</span><br><span class="line">                : timeoutForPriorityLevel(priorityLevel);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        timeout = timeoutForPriorityLevel(priorityLevel);</span><br><span class="line">        startTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> expirationTime = startTime + timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newTask = &#123;</span><br><span class="line">        callback,</span><br><span class="line">        priorityLevel,</span><br><span class="line">        startTime,</span><br><span class="line">        expirationTime,</span><br><span class="line">        next: <span class="literal">null</span>,</span><br><span class="line">        previous: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (startTime &gt; currentTime) &#123;</span><br><span class="line">        <span class="comment">// This is a delayed task.</span></span><br><span class="line">        insertDelayedTask(newTask, startTime);</span><br><span class="line">        <span class="keyword">if</span> (firstTask === <span class="literal">null</span> &amp;&amp; firstDelayedTask === newTask) &#123;</span><br><span class="line">            <span class="comment">// All tasks are delayed, and this is the task with the earliest delay.</span></span><br><span class="line">            <span class="keyword">if</span> (isHostTimeoutScheduled) &#123;</span><br><span class="line">                <span class="comment">// Cancel an existing timeout.</span></span><br><span class="line">                cancelHostTimeout();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isHostTimeoutScheduled = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Schedule a timeout.</span></span><br><span class="line">            requestHostTimeout(handleTimeout, startTime - currentTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insertScheduledTask(newTask, expirationTime);</span><br><span class="line">        <span class="comment">// Schedule a host callback, if needed. If we&#x27;re already performing work,</span></span><br><span class="line">        <span class="comment">// wait until the next time we yield.</span></span><br><span class="line">        <span class="keyword">if</span> (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) &#123;</span><br><span class="line">            isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">            requestHostCallback(flushWork);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="timeoutForPriorityLevel"><a href="#timeoutForPriorityLevel" class="headerlink" title="timeoutForPriorityLevel"></a>timeoutForPriorityLevel</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">固定参数见 <span class="string">`常量.md`</span>-&gt;<span class="string">`优先级`</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutForPriorityLevel</span>(<span class="params">priorityLevel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (priorityLevel) &#123;</span><br><span class="line">    <span class="keyword">case</span> ImmediatePriority:</span><br><span class="line">      <span class="keyword">return</span> IMMEDIATE_PRIORITY_TIMEOUT;</span><br><span class="line">    <span class="keyword">case</span> UserBlockingPriority:</span><br><span class="line">      <span class="keyword">return</span> USER_BLOCKING_PRIORITY;</span><br><span class="line">    <span class="keyword">case</span> IdlePriority:</span><br><span class="line">      <span class="keyword">return</span> IDLE_PRIORITY;</span><br><span class="line">    <span class="keyword">case</span> LowPriority:</span><br><span class="line">      <span class="keyword">return</span> LOW_PRIORITY_TIMEOUT;</span><br><span class="line">    <span class="keyword">case</span> NormalPriority:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> NORMAL_PRIORITY_TIMEOUT;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="insertScheduledTask"><a href="#insertScheduledTask" class="headerlink" title="insertScheduledTask"></a>insertScheduledTask</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertScheduledTask</span>(<span class="params">newTask, expirationTime</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Insert the new task into the list, ordered first by its timeout, then by</span></span><br><span class="line">    <span class="comment">// insertion. So the new task is inserted after any other task the</span></span><br><span class="line">    <span class="comment">// same timeout</span></span><br><span class="line">    <span class="keyword">if</span> (firstTask === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一个任务</span></span><br><span class="line">        <span class="comment">// This is the first task in the list.</span></span><br><span class="line">        firstTask = newTask.next = newTask.previous = newTask;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">var</span> task = firstTask;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (expirationTime &lt; task.expirationTime) &#123;</span><br><span class="line">                <span class="comment">// The new task times out before this one.</span></span><br><span class="line">                next = task;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            task = task.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (task !== firstTask);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No task with a later timeout was found, which means the new task has</span></span><br><span class="line">            <span class="comment">// the latest timeout in the list.</span></span><br><span class="line">            next = firstTask;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next === firstTask) &#123;</span><br><span class="line">            <span class="comment">// The new task has the earliest expiration in the entire list.</span></span><br><span class="line">            firstTask = newTask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> previous = next.previous;</span><br><span class="line">        previous.next = next.previous = newTask;</span><br><span class="line">        newTask.next = next;</span><br><span class="line">        newTask.previous = previous;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="requestHostCallback"><a href="#requestHostCallback" class="headerlink" title="requestHostCallback"></a>requestHostCallback</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">requestHostCallback = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (scheduledHostCallback === <span class="literal">null</span>) &#123;</span><br><span class="line">        scheduledHostCallback = callback;</span><br><span class="line">        <span class="keyword">if</span> (!isAnimationFrameScheduled) &#123;</span><br><span class="line">            <span class="comment">// If rAF didn&#x27;t already schedule one, we need to schedule a frame.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> If this rAF doesn&#x27;t materialize because the browser throttles,</span></span><br><span class="line">            <span class="comment">// we might want to still have setTimeout trigger rIC as a backup to</span></span><br><span class="line">            <span class="comment">// ensure that we keep performing work.</span></span><br><span class="line">            isAnimationFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">            requestAnimationFrameWithTimeout(animationTick);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="requestAnimationFrameWithTimeout"><a href="#requestAnimationFrameWithTimeout" class="headerlink" title="requestAnimationFrameWithTimeout"></a>requestAnimationFrameWithTimeout</h3><p><code>equestAnimationFrame</code>在后台时会停止工作，所以需要<code>localSetTimeout</code>辅助</p>
<p>把渲染流程放在了<code>requestAnimationFrame</code>或<code>setTimeOut</code>里面</p>
<p><code>requestAnimationFrame</code>使得在一次同步事件中的所有更改都一起处理</p>
<p>最后的处理就是<code>callback</code>了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// requestAnimationFrame does not run when the tab is in the background. If</span></span><br><span class="line"><span class="comment">// we&#x27;re backgrounded we prefer for that work to happen so that the page</span></span><br><span class="line"><span class="comment">// continues to load in the background. So we also schedule a &#x27;setTimeout&#x27; as</span></span><br><span class="line"><span class="comment">// a fallback.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Need a better heuristic for backgrounded work.</span></span><br><span class="line"><span class="keyword">const</span> ANIMATION_FRAME_TIMEOUT = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> rAFID;</span><br><span class="line"><span class="keyword">let</span> rAFTimeoutID;</span><br><span class="line"><span class="keyword">const</span> requestAnimationFrameWithTimeout = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// schedule rAF and also a setTimeout</span></span><br><span class="line">    rAFID = localRequestAnimationFrame(<span class="function"><span class="keyword">function</span> (<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// cancel the setTimeout</span></span><br><span class="line">        localClearTimeout(rAFTimeoutID);</span><br><span class="line">        callback(timestamp);</span><br><span class="line">    &#125;);</span><br><span class="line">    rAFTimeoutID = localSetTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// cancel the requestAnimationFrame</span></span><br><span class="line">        localCancelAnimationFrame(rAFID);</span><br><span class="line">        callback(getCurrentTime());</span><br><span class="line">    &#125;, ANIMATION_FRAME_TIMEOUT);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="animationTick"><a href="#animationTick" class="headerlink" title="animationTick"></a>animationTick</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> animationTick = <span class="function"><span class="keyword">function</span> (<span class="params">rafTime</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (scheduledHostCallback !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Eagerly schedule the next animation callback at the beginning of the</span></span><br><span class="line">        <span class="comment">// frame. If the scheduler queue is not empty at the end of the frame, it</span></span><br><span class="line">        <span class="comment">// will continue flushing inside that callback. If the queue *is* empty,</span></span><br><span class="line">        <span class="comment">// then it will exit immediately. Posting the callback at the start of the</span></span><br><span class="line">        <span class="comment">// frame ensures it&#x27;s fired within the earliest possible frame. If we</span></span><br><span class="line">        <span class="comment">// waited until the end of the frame to post the callback, we risk the</span></span><br><span class="line">        <span class="comment">// browser skipping a frame and not firing the callback until the frame</span></span><br><span class="line">        <span class="comment">// after that.</span></span><br><span class="line">        requestAnimationFrameWithTimeout(animationTick);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No pending work. Exit.</span></span><br><span class="line">        isAnimationFrameScheduled = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> nextFrameTime = rafTime - frameDeadline + activeFrameTime;</span><br><span class="line">    <span class="keyword">if</span> (nextFrameTime &lt; activeFrameTime &amp;&amp; previousFrameTime &lt; activeFrameTime &amp;&amp; !fpsLocked) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextFrameTime &lt; <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="comment">// Defensive coding. We don&#x27;t support higher frame rates than 120hz.</span></span><br><span class="line">            <span class="comment">// If the calculated frame time gets lower than 8, it is probably a bug.</span></span><br><span class="line">            nextFrameTime = <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If one frame goes long, then the next one can be short to catch up.</span></span><br><span class="line">        <span class="comment">// If two frames are short in a row, then that&#x27;s an indication that we</span></span><br><span class="line">        <span class="comment">// actually have a higher frame rate than what we&#x27;re currently optimizing.</span></span><br><span class="line">        <span class="comment">// We adjust our heuristic dynamically accordingly. For example, if we&#x27;re</span></span><br><span class="line">        <span class="comment">// running on 120hz display or 90hz VR display.</span></span><br><span class="line">        <span class="comment">// Take the max of the two in case one of them was an anomaly due to</span></span><br><span class="line">        <span class="comment">// missed frame deadlines.</span></span><br><span class="line">        activeFrameTime = nextFrameTime &lt; previousFrameTime ? previousFrameTime : nextFrameTime;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        previousFrameTime = nextFrameTime;</span><br><span class="line">    &#125;</span><br><span class="line">    frameDeadline = rafTime + activeFrameTime;</span><br><span class="line">    <span class="keyword">if</span> (!isMessageEventScheduled) &#123;</span><br><span class="line">        isMessageEventScheduled = <span class="literal">true</span>;</span><br><span class="line">        port.postMessage(<span class="literal">undefined</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="flushSyncCallbackQueue"><a href="#flushSyncCallbackQueue" class="headerlink" title="flushSyncCallbackQueue"></a>flushSyncCallbackQueue</h3><p><code>callback</code>看上方<code>scheduleCallbackForRoot</code>里面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">flushSyncCallbackQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (immediateQueueCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">        Scheduler_cancelCallback(immediateQueueCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line">    flushSyncCallbackQueueImpl();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSyncCallbackQueueImpl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFlushingSyncQueue &amp;&amp; syncQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Prevent re-entrancy.</span></span><br><span class="line">        isFlushingSyncQueue = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> isSync = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; syncQueue.length; i++) &#123;</span><br><span class="line">                <span class="keyword">let</span> callback = syncQueue[i];</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    callback = callback(isSync);</span><br><span class="line">                &#125; <span class="keyword">while</span> (callback !== <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            syncQueue = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="comment">// If something throws, leave the remaining callbacks on the queue.</span></span><br><span class="line">            <span class="keyword">if</span> (syncQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">                syncQueue = syncQueue.slice(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Resume flushing in the next tick</span></span><br><span class="line">            Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueue);</span><br><span class="line">            <span class="keyword">throw</span> error;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            isFlushingSyncQueue = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="runRootCallback"><a href="#runRootCallback" class="headerlink" title="runRootCallback"></a>runRootCallback</h3><p><code>runRootCallback</code>里面又执行了<code>renderRoot</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runRootCallback</span>(<span class="params">root, callback, isSync</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">    <span class="keyword">const</span> prevCallbackNode = root.callbackNode;</span><br><span class="line">    <span class="keyword">let</span> continuation = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        continuation = callback(isSync);</span><br><span class="line">        <span class="keyword">if</span> (continuation !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> runRootCallback.bind(<span class="literal">null</span>, root, continuation);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// If the callback exits without returning a continuation, remove the</span></span><br><span class="line">        <span class="comment">// corresponding callback node from the root. Unless the callback node</span></span><br><span class="line">        <span class="comment">// has changed, which implies that it was already cancelled by a high</span></span><br><span class="line">        <span class="comment">// priority update.</span></span><br><span class="line">        <span class="keyword">if</span> (continuation === <span class="literal">null</span> &amp;&amp; prevCallbackNode === root.callbackNode) &#123;</span><br><span class="line">            root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">            root.callbackExpirationTime = NoWork;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="renderRoot"><a href="#renderRoot" class="headerlink" title="renderRoot"></a>renderRoot</h3><p>见 renderRoot.md</p>
<p>之后就是渲染那一套</p>
]]></content>
      <tags>
        <tag>react源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>connectAdvanced</title>
    <url>/my-notes/2020/09/14/react-redux/connectAdvanced/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hoistStatics <span class="keyword">from</span> <span class="string">&#x27;hoist-non-react-statics&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> invariant <span class="keyword">from</span> <span class="string">&#x27;invariant&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> React, &#123;useContext, useMemo, useEffect, useLayoutEffect, useRef, useReducer&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;isValidElementType, isContextConsumer&#125; <span class="keyword">from</span> <span class="string">&#x27;react-is&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Subscription <span class="keyword">from</span> <span class="string">&#x27;../utils/Subscription&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;ReactReduxContext&#125; <span class="keyword">from</span> <span class="string">&#x27;./Context&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define some constant arrays just to avoid re-creating these</span></span><br><span class="line"><span class="keyword">const</span> EMPTY_ARRAY = [];</span><br><span class="line"><span class="keyword">const</span> NO_SUBSCRIPTION_ARRAY = [<span class="literal">null</span>, <span class="literal">null</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stringifyComponent = <span class="function">(<span class="params">Comp</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(Comp);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">String</span>(Comp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">storeStateUpdatesReducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [, updateCount] = state;</span><br><span class="line">    <span class="keyword">return</span> [action.payload, updateCount + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initStateUpdates = <span class="function">() =&gt;</span> [<span class="literal">null</span>, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// React currently throws a warning when using useLayoutEffect on the server.</span></span><br><span class="line"><span class="comment">// To get around it, we can conditionally useEffect on the server (no-op) and</span></span><br><span class="line"><span class="comment">// useLayoutEffect in the browser. We need useLayoutEffect because we want</span></span><br><span class="line"><span class="comment">// `connect` to perform sync updates to a ref to save the latest props after</span></span><br><span class="line"><span class="comment">// a render is actually committed to the DOM.</span></span><br><span class="line"><span class="comment">// 在服务器上使用useEffect,浏览器使用useLayoutEffect</span></span><br><span class="line"><span class="keyword">const</span> useIsomorphicLayoutEffect =</span><br><span class="line">    <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> <span class="built_in">window</span>.document !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> <span class="built_in">window</span>.document.createElement !== <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">        ? useLayoutEffect</span><br><span class="line">        : useEffect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">connectAdvanced</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">/*</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    selectorFactory is a func that is responsible for returning the selector function used to</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    compute new props from state, props, and dispatch. For example:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">      export default connectAdvanced((dispatch, options) =&gt; (state, props) =&gt; (&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">        thing: state.things[props.thingId],</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">        saveThing: fields =&gt; dispatch(actionCreators.saveThing(props.thingId, fields)),</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">      &#125;))(YourComponent)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    Access to dispatch is provided to the factory so selectorFactories can bind actionCreators</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    outside of their selector as an optimization. Options passed to connectAdvanced are passed to</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    the selectorFactory, along with displayName and WrappedComponent, as the second argument.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    Note that selectorFactory is responsible for all caching/memoization of inbound and outbound</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    props. Do not use connectAdvanced directly without memoizing results between calls to your</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    selector, otherwise the Connect component will re-render on every state or props change.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">  */</span></span></span></span><br><span class="line"><span class="function"><span class="params">    selectorFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="regexp">//</span> options object:</span></span></span><br><span class="line"><span class="function"><span class="params">    &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="regexp">//</span> the func used to compute this HOC<span class="string">&#x27;s displayName from the wrapped component&#x27;</span>s displayName.</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="regexp">//</span> probably overridden by wrapper functions such as connect()</span></span></span><br><span class="line"><span class="function"><span class="params">        getDisplayName = (name) =&gt; <span class="string">`ConnectAdvanced(<span class="subst">$&#123;name&#125;</span>)`</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="regexp">//</span> shown in error messages</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="regexp">//</span> probably overridden by wrapper functions such as connect()</span></span></span><br><span class="line"><span class="function"><span class="params">        methodName = <span class="string">&#x27;connectAdvanced&#x27;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="regexp">//</span> REMOVED: if defined, the name of the property passed to the wrapped element indicating the number of</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="regexp">//</span> calls to render. useful for watching in react devtools for unnecessary re-renders.</span></span></span><br><span class="line"><span class="function"><span class="params">        renderCountProp = undefined,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="regexp">//</span> determines whether this HOC subscribes to store changes</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="regexp">//</span> 有mapStateToProps传递才是true</span></span></span><br><span class="line"><span class="function"><span class="params">        shouldHandleStateChanges = true,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="regexp">//</span> REMOVED: the key of props/context to get the store</span></span></span><br><span class="line"><span class="function"><span class="params">        storeKey = <span class="string">&#x27;store&#x27;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="regexp">//</span> REMOVED: expose the wrapped component via refs</span></span></span><br><span class="line"><span class="function"><span class="params">        withRef = false,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="regexp">//</span> use React<span class="string">&#x27;s forwardRef to expose a ref of the wrapped component</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        forwardRef = false,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        // the context consumer to use</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        context = ReactReduxContext,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        // additional options are passed through to the selectorFactory</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        ...connectOptions</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    &#125; = &#123;&#125;,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    invariant(</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        renderCountProp === undefined,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        `renderCountProp is removed. render counting is built into the latest React Dev Tools profiling extension`,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    );</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    invariant(</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        !withRef,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        &#x27;</span>withRef is removed. To access the wrapped instance, use a ref on the connected component<span class="string">&#x27;,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    );</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    const customStoreWarningMessage =</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        &#x27;</span>To use a custom Redux store for specific components, create a custom React context with <span class="string">&#x27; +</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        &quot;React.createContext(), and pass the context object to React Redux&#x27;</span>s Provider and specific components<span class="string">&quot; +</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        &#x27; like: &lt;Provider context=&#123;MyContext&#125;&gt;&lt;ConnectedComponent context=&#123;MyContext&#125; /&gt;&lt;/Provider&gt;. &#x27; +</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        &#x27;You may also pass a &#123;context : MyContext&#125; option to connect&#x27;;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    invariant(</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        storeKey === &#x27;store&#x27;,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        &#x27;storeKey has been removed and does not do anything. &#x27; + customStoreWarningMessage,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    );</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    const Context = context;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    // 高阶组件执行到这一步，WrappedComponent是用户业务组件</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    return function wrapWithConnect(WrappedComponent) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            invariant(</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                isValidElementType(WrappedComponent),</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                `You must pass a component to the function returned by ` +</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    `$&#123;methodName&#125;. Instead received $&#123;stringifyComponent(WrappedComponent)&#125;`,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            );</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        const wrappedComponentName =</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            WrappedComponent.displayName || WrappedComponent.name || &#x27;Component&#x27;;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        const displayName = getDisplayName(wrappedComponentName);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        const selectorFactoryOptions = &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            ...connectOptions,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            getDisplayName,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            methodName,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            renderCountProp,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            shouldHandleStateChanges,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            storeKey,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            displayName,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            wrappedComponentName,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            WrappedComponent,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        &#125;;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        // 默认是true,可被用户覆盖</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        const &#123;pure&#125; = connectOptions;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        // 见 selectorFactory.md -&gt; finalPropsSelectorFactory</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        function createChildSelector(store) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            return selectorFactory(store.dispatch, selectorFactoryOptions);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        // If we aren&#x27;t running in &quot;</span>pure<span class="string">&quot; mode, we don&#x27;t want to memoize values.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        // To avoid conditionally calling hooks, we fall back to a tiny wrapper</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        // that just executes the given callback immediately.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        const usePureOnlyMemo = pure ? useMemo : (callback) =&gt; callback();</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        function ConnectFunction(props) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // context, ref, rest其他props属性</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            const [propsContext, forwardedRef, wrapperProps] = useMemo(() =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // Distinguish between actual &quot;</span>data<span class="string">&quot; props that were passed to the wrapper component,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // and values needed to control behavior (forwarded refs, alternate context instances).</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // To maintain the wrapperProps object reference, memoize this destructuring.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                const &#123;forwardedRef, ...wrapperProps&#125; = props;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                return [props.context, forwardedRef, wrapperProps];</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            &#125;, [props]);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // 判断使用哪个context(用户or默认)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            const ContextToUse = useMemo(() =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // 使用用户传递的context或默认context</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // Users may optionally pass in a custom context instance to use instead of our ReactReduxContext.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // Memoize the check that determines which context instance we should use.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                return propsContext &amp;&amp;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    propsContext.Consumer &amp;&amp;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    isContextConsumer(&lt;propsContext.Consumer /&gt;)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    ? propsContext</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    : Context;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            &#125;, [propsContext, Context]);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // Retrieve the store and ancestor subscription via context, if available</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            /**</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">       * &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            store,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            subscription</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">          &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">       */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // useContext见react context.md</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // contextValue应该是&#123;store,subscription&#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            const contextValue = useContext(ContextToUse);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // The store _must_ exist as either a prop or in context</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // 按照规范来使用redux, didStoreComeFromContext应该是true</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // 用户传递的store</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            const didStoreComeFromProps = Boolean(props.store);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // redux生成的store</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            const didStoreComeFromContext = Boolean(contextValue) &amp;&amp; Boolean(contextValue.store);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            invariant(</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                didStoreComeFromProps || didStoreComeFromContext,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                `Could not find &quot;</span>store<span class="string">&quot; in the context of ` +</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    `&quot;</span>$&#123;displayName&#125;<span class="string">&quot;. Either wrap the root component in a &lt;Provider&gt;, ` +</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    `or pass a custom React context provider to &lt;Provider&gt; and the corresponding ` +</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    `React context consumer to $&#123;displayName&#125; in connect options.`,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            );</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            const store = props.store || contextValue.store;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // 返回了函数 selectorFactory 的 pureFinalPropsSelector</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            const childPropsSelector = useMemo(() =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // 处理connect参数（MapStateToProps等），执行在下面</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // The child props selector needs the store reference as an input.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // Re-create this selector whenever the store changes.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                return createChildSelector(store);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            &#125;, [store]);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            const [subscription, notifyNestedSubs] = useMemo(() =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // This Subscription&#x27;s source should match where store came from: props vs. context. A component</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // connected to the store via props shouldn&#x27;t use subscription from context, or vice versa.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // 如果是react-redux生成的context, 传递subscription</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // 用户自定义context,就不传</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // 这里其实是关联了provider生成的contextValue</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                const subscription = new Subscription(</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    store,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    didStoreComeFromProps ? null : contextValue.subscription,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                );</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // the middle of the notification loop, where `subscription` will then be null. This can</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // probably be avoided if Subscription&#x27;s listeners logic is changed to not call listeners</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // that have been unsubscribed in the  middle of the notification loop.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // 都没`trySubscribe`,第一次就是个空函数</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                const notifyNestedSubs = subscription.notifyNestedSubs.bind(subscription);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                return [subscription, notifyNestedSubs];</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            &#125;, [store, didStoreComeFromProps, contextValue]);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // Determine what &#123;store, subscription&#125; value should be put into nested context, if necessary,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // and memoize that value to avoid unnecessary context updates.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // 替换了`contextValue`里原来的`subscription`</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            const overriddenContextValue = useMemo(() =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                if (didStoreComeFromProps) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    // This component is directly subscribed to a store from props.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    // We don&#x27;t want descendants reading from this store - pass down whatever</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    // the existing context value is from the nearest connected ancestor.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    return contextValue;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // Otherwise, put this component&#x27;s subscription instance into context, so that</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // connected descendants won&#x27;t update until after this component is done</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                return &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    ...contextValue,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    subscription,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                &#125;;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            &#125;, [didStoreComeFromProps, contextValue, subscription]);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // We need to force this wrapper component to re-render whenever a Redux store update</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // causes a change to the calculated child component props (or we caught an error in mapState)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // 建了一个count计数，用于forceUpdate,或者用于报错</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            const [[previousStateUpdateResult], forceComponentUpdateDispatch] = useReducer(</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                storeStateUpdatesReducer,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                EMPTY_ARRAY,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                initStateUpdates,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            );</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // Propagate any mapState/mapDispatch errors upwards</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            if (previousStateUpdateResult &amp;&amp; previousStateUpdateResult.error) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                throw previousStateUpdateResult.error;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // Set up refs to coordinate values between the subscription effect and the render logic</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            const lastChildProps = useRef(); // &#123;current: undefined&#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            const lastWrapperProps = useRef(wrapperProps); // &#123;current: wrapperProps&#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            const childPropsFromStoreUpdate = useRef();</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            const renderIsScheduled = useRef(false);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // 如果 pure,是useMemo,否则就是无视依赖的必定执行函数</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // 返回connect传递参数mergedProps的结果，如果不传mergedProps，返回前2个参数结果和props的&#123;...a,...b, ...props&#125;结果</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // 这也是最终的传给子组件的props</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            const actualChildProps = usePureOnlyMemo(() =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // Tricky logic here:</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // - This render may have been triggered by a Redux store update that produced new child props</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // - However, we may have gotten new wrapper props after that</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // If we have new child props, and the same wrapper props, we know we should use the new child props as-is.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // But, if we have new wrapper props, those might change the child props, so we have to recalculate things.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // So, we&#x27;ll use the child props from store update only if the wrapper props are the same as last time.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                if (</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    childPropsFromStoreUpdate.current &amp;&amp;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    wrapperProps === lastWrapperProps.current</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                ) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    return childPropsFromStoreUpdate.current;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // TODO We&#x27;re reading the store directly in render() here. Bad idea?</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // This will likely cause Bad Things (TM) to happen in Concurrent Mode.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // Note that we do this because on renders _not_ caused by store updates, we need the latest store state</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // to determine what the child props should be.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // 执行connect参数（MapStateToProps等），即 pureFinalPropsSelector</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                return childPropsSelector(store.getState(), wrapperProps);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            &#125;, [store, previousStateUpdateResult, wrapperProps]);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // We need this to execute synchronously every time we re-render. However, React warns</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // about useLayoutEffect in SSR, so we try to detect environment and fall back to</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // just useEffect instead to avoid the warning, since neither will run anyway.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            useIsomorphicLayoutEffect(() =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // We want to capture the wrapper props and child props we used for later comparisons</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                lastWrapperProps.current = wrapperProps;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                lastChildProps.current = actualChildProps;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                renderIsScheduled.current = false;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // If the render was from a store update, clear out that reference and cascade the subscriber update</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                if (childPropsFromStoreUpdate.current) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    childPropsFromStoreUpdate.current = null;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    notifyNestedSubs();</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            &#125;);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // Our re-subscribe logic only runs when the store/subscription setup changes</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            useIsomorphicLayoutEffect(() =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // If we&#x27;re not subscribed to the store, nothing to do here</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                if (!shouldHandleStateChanges) return;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // Capture values for checking if and when this component unmounts</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                let didUnsubscribe = false;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                let lastThrownError = null;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // We&#x27;ll run this callback every time a store subscription update propagates to this component</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                const checkForUpdates = () =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    if (didUnsubscribe) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        // Don&#x27;t run stale listeners.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        // Redux doesn&#x27;t guarantee unsubscriptions happen until next dispatch.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        return;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    const latestStoreState = store.getState();</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    let newChildProps, error;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    try &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        // Actually run the selector with the most recent store state and wrapper props</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        // to determine what the child props should be</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        // 同上面返回合并结果</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        newChildProps = childPropsSelector(</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                            latestStoreState,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                            lastWrapperProps.current,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        );</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    &#125; catch (e) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        error = e;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        lastThrownError = e;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    if (!error) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        lastThrownError = null;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    // If the child props haven&#x27;t changed, nothing to do here - cascade the subscription update</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    // 第一次参数相同，但renderIsScheduled.current是false</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    if (newChildProps === lastChildProps.current) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        if (!renderIsScheduled.current) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                            notifyNestedSubs();</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    &#125; else &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        // Save references to the new child props.  Note that we track the &quot;</span>child props from store update<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        // as a ref instead of a useState/useReducer because we need a way to determine if that value has</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        // been processed.  If this went into useState/useReducer, we couldn&#x27;t clear out the value without</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        // forcing another re-render, which we don&#x27;t want.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        lastChildProps.current = newChildProps;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        childPropsFromStoreUpdate.current = newChildProps;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        renderIsScheduled.current = true;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        // If the child props _did_ change (or we caught an error), this wrapper component needs to re-render</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        forceComponentUpdateDispatch(&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                            type: &#x27;STORE_UPDATED&#x27;,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                            payload: &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                                latestStoreState,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                                error,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                            &#125;,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        &#125;);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                &#125;;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // Actually subscribe to the nearest connected ancestor (or store)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                subscription.onStateChange = checkForUpdates;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                subscription.trySubscribe();</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // Pull data from the store after first render in case the store has</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                // changed since we began.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                checkForUpdates();</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                const unsubscribeWrapper = () =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    // 取消监听</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    didUnsubscribe = true;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    subscription.tryUnsubscribe();</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    subscription.onStateChange = null;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    if (lastThrownError) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        // It&#x27;s possible that we caught an error due to a bad mapState function, but the</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        // parent re-rendered without this component and we&#x27;re about to unmount.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        // This shouldn&#x27;t happen as long as we do top-down subscriptions correctly, but</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        // if we ever do those wrong, this throw will surface the error in our tests.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        // In that case, throw the error from here so it doesn&#x27;t get lost.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        throw lastThrownError;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                &#125;;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                return unsubscribeWrapper;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            &#125;, [store, subscription, childPropsSelector]);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // Now that all that&#x27;s done, we can finally try to actually render the child component.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // We memoize the elements for the rendered child component as an optimization.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            const renderedWrappedComponent = useMemo(</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                () =&gt; &lt;WrappedComponent &#123;...actualChildProps&#125; ref=&#123;forwardedRef&#125; /&gt;,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                [forwardedRef, WrappedComponent, actualChildProps],</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            );</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // If React sees the exact same element reference as last time, it bails out of re-rendering</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // that child, same as if it was wrapped in React.memo() or returned false from shouldComponentUpdate.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            const renderedChild = useMemo(() =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                if (shouldHandleStateChanges) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    // If this component is subscribed to store updates, we need to pass its own</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    // subscription instance down to our descendants. That means rendering the same</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    // Context instance, and putting a different value into the context.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    // overriddenContextValue在一般情况下应该是最上层store的clone数据</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    return (</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        &lt;ContextToUse.Provider value=&#123;overriddenContextValue&#125;&gt;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                            &#123;renderedWrappedComponent&#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                        &lt;/ContextToUse.Provider&gt;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    );</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                return renderedWrappedComponent;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            &#125;, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            // connect执行到此结束</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            return renderedChild;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        // If we&#x27;re in &quot;</span>pure<span class="string">&quot; mode, ensure our wrapper component only re-renders when incoming props have changed.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        const Connect = pure ? React.memo(ConnectFunction) : ConnectFunction;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        Connect.WrappedComponent = WrappedComponent;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        Connect.displayName = displayName;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        if (forwardRef) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            const forwarded = React.forwardRef(function forwardConnectRef(props, ref) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                return &lt;Connect &#123;...props&#125; forwardedRef=&#123;ref&#125; /&gt;;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            &#125;);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            forwarded.displayName = displayName;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            forwarded.WrappedComponent = WrappedComponent;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">            return hoistStatics(forwarded, WrappedComponent);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        // 把WrappedComponent不是react内部的属性复制到Connect里，并返回Connect</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        return hoistStatics(Connect, WrappedComponent);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    &#125;;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react-redux</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码阅读笔记（4）(compile)</title>
    <url>/my-notes/2018/05/25/vue/4/</url>
    <content><![CDATA[<p><a href="https://github.com/liutao/vue2.0-source/blob/be4ac775e26efae7b64e5254e23a97d50a9e880c/compile%E6%A6%82%E8%BF%B0.md">参考了的文章</a></p>
<p>从这里开始我会尽可能的把源码里所有的<code>if</code>情况考虑进去，还是以一个简单例子开始，之后会不断的把这个例子补充完整，以完成对每一行的解读</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>模板编译分为三个阶段：生成 ast、优化静态内容、生成 render</p>
<p>以下面代码开始</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">  var vm &#x3D; new Vue(&#123;</span><br><span class="line">    el: &#39;#app&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: &#39;第一个vue实例&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h2 id="正则补充"><a href="#正则补充" class="headerlink" title="正则补充"></a>正则补充</h2><p>这里用到了很多的正则判断，对于一些比较复杂的不清楚的在这里进行说明(超的<a href="https://github.com/liutao/vue2.0-source/blob/be4ac775e26efae7b64e5254e23a97d50a9e880c/compile%E2%80%94%E2%80%94%E7%94%9F%E6%88%90ast.md">参考文章</a>)</p>
<p>代码片段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (</span><br><span class="line">  !endTag.test(rest) &amp;&amp;</span><br><span class="line">  !startTagOpen.test(rest) &amp;&amp;</span><br><span class="line">  !comment.test(rest) &amp;&amp;</span><br><span class="line">  !conditionalComment.test(rest)</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>endTag = /^&lt;/((?:[a-zA-Z_][\w-.]_:)?[a-zA-Z_][\w-.]_)[^&gt;]*&gt;/<br>endTag 是匹配双标签的结束标签。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;&lt;&#x2F;div&gt;&#39;.match(endTag)</span><br><span class="line">&#x2F;&#x2F; [&quot;&lt;&#x2F;div&gt;&quot;, &quot;div&quot;, index: 0, input: &quot;&lt;&#x2F;div&gt;&quot;]</span><br><span class="line"></span><br><span class="line">&#39;&lt;&#x2F;div    &gt;&#39;.match(endTag)</span><br><span class="line">&#x2F;&#x2F; [&quot;&lt;&#x2F;div    &gt;&quot;, &quot;div&quot;, index: 0, input: &quot;&lt;&#x2F;div    &gt;&quot;]</span><br><span class="line"></span><br><span class="line">&#39; &lt;&#x2F;div    &gt;&#39;.match(endTag)</span><br><span class="line">&#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>

<p>startTagOpen = /^&lt;((?:[a-zA-Z_][\w-.]<em>:)?[a-zA-Z\</em>][\w-.]_)/<br>匹配开始标签</p>
<h2 id="compileToFunctions"><a href="#compileToFunctions" class="headerlink" title="compileToFunctions"></a>compileToFunctions</h2><p>从<code>compileToFunctions</code>开始，路径<code>/src/compiler/index.js</code>,<br>首先在 mount 方法里有使用到<code>compileToFunctions</code>方法，他返回了 render 函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; render, staticRenderFns &#125; &#x3D; compileToFunctions(template, &#123;</span><br><span class="line">    shouldDecodeNewlines,</span><br><span class="line">    delimiters: options.delimiters</span><br><span class="line">&#125;, this)</span><br><span class="line"></span><br><span class="line">function compileToFunctions (</span><br><span class="line">    template: string, &#x2F;&#x2F; html模板</span><br><span class="line">    options?: CompilerOptions, &#x2F;&#x2F; 上面的参数</span><br><span class="line">    vm?: Component &#x2F;&#x2F; vue</span><br><span class="line">  ): CompiledFunctionResult &#123;</span><br><span class="line">    options &#x3D; options || &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      &#x2F;&#x2F; detect possible CSP restriction</span><br><span class="line">      try &#123;</span><br><span class="line">        new Function(&#39;return 1&#39;)</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        if (e.toString().match(&#x2F;unsafe-eval|CSP&#x2F;)) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            &#39;It seems you are using the standalone build of Vue.js in an &#39; +</span><br><span class="line">            &#39;environment with Content Security Policy that prohibits unsafe-eval. &#39; +</span><br><span class="line">            &#39;The template compiler cannot work in this environment. Consider &#39; +</span><br><span class="line">            &#39;relaxing the policy to allow unsafe-eval or pre-compiling your &#39; +</span><br><span class="line">            &#39;templates into render functions.&#39;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; check cache</span><br><span class="line">    const key &#x3D; options.delimiters</span><br><span class="line">      ? String(options.delimiters) + template</span><br><span class="line">      : template &#x2F;&#x2F; key是模板html</span><br><span class="line">    if (functionCompileCache[key]) &#123; &#x2F;&#x2F; 应该是缓存</span><br><span class="line">      return functionCompileCache[key]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; compile</span><br><span class="line">    const compiled &#x3D; compile(template, options)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; check compilation errors&#x2F;tips</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      if (compiled.errors &amp;&amp; compiled.errors.length) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#96;Error compiling template:\n\n$&#123;template&#125;\n\n&#96; +</span><br><span class="line">          compiled.errors.map(e &#x3D;&gt; &#96;- $&#123;e&#125;&#96;).join(&#39;\n&#39;) + &#39;\n&#39;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      if (compiled.tips &amp;&amp; compiled.tips.length) &#123;</span><br><span class="line">        compiled.tips.forEach(msg &#x3D;&gt; tip(msg, vm))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; turn code into functions</span><br><span class="line">    const res &#x3D; &#123;&#125;</span><br><span class="line">    const fnGenErrors &#x3D; []</span><br><span class="line">    res.render &#x3D; makeFunction(compiled.render, fnGenErrors)</span><br><span class="line">    const l &#x3D; compiled.staticRenderFns.length</span><br><span class="line">    res.staticRenderFns &#x3D; new Array(l)</span><br><span class="line">    for (let i &#x3D; 0; i &lt; l; i++) &#123;</span><br><span class="line">      res.staticRenderFns[i] &#x3D; makeFunction(compiled.staticRenderFns[i], fnGenErrors)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; check function generation errors.</span><br><span class="line">    &#x2F;&#x2F; this should only happen if there is a bug in the compiler itself.</span><br><span class="line">    &#x2F;&#x2F; mostly for codegen development use</span><br><span class="line">    &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      if ((!compiled.errors || !compiled.errors.length) &amp;&amp; fnGenErrors.length) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#96;Failed to generate render function:\n\n&#96; +</span><br><span class="line">          fnGenErrors.map((&#123; err, code &#125;) &#x3D;&gt; &#96;$&#123;err.toString()&#125; in\n\n$&#123;code&#125;\n&#96;).join(&#39;\n&#39;),</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (functionCompileCache[key] &#x3D; res)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>具体说明看上面注释</p>
<p>运行到<code>compile</code>，我们跟着进去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function compile (</span><br><span class="line">    template: string,</span><br><span class="line">    options?: CompilerOptions</span><br><span class="line">  ): CompiledResult &#123;</span><br><span class="line">    &#x2F;&#x2F; finalOptions.prototype &#x3D; baseOption</span><br><span class="line">    const finalOptions &#x3D; Object.create(baseOptions)</span><br><span class="line">    const errors &#x3D; []</span><br><span class="line">    const tips &#x3D; []</span><br><span class="line">    &#x2F;&#x2F; 定义了warn方法</span><br><span class="line">    finalOptions.warn &#x3D; (msg, tip) &#x3D;&gt; &#123;</span><br><span class="line">      (tip ? tips : errors).push(msg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (options) &#123;</span><br><span class="line">      &#x2F;&#x2F; merge custom modules</span><br><span class="line">      &#x2F;&#x2F; 合并自定义modules</span><br><span class="line">      &#x2F;&#x2F; TODO 这里的options应该肯定没有这些参数才对啊？下同</span><br><span class="line">      if (options.modules) &#123;</span><br><span class="line">        finalOptions.modules &#x3D; (baseOptions.modules || []).concat(options.modules)</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; merge custom directives</span><br><span class="line">      &#x2F;&#x2F; 合并自定义directives</span><br><span class="line">      if (options.directives) &#123;</span><br><span class="line">        finalOptions.directives &#x3D; extend(</span><br><span class="line">          Object.create(baseOptions.directives),</span><br><span class="line">          options.directives</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; copy other options</span><br><span class="line">      &#x2F;&#x2F; 赋值给finalOptions</span><br><span class="line">      for (const key in options) &#123;</span><br><span class="line">        if (key !&#x3D;&#x3D; &#39;modules&#39; &amp;&amp; key !&#x3D;&#x3D; &#39;directives&#39;) &#123;</span><br><span class="line">          finalOptions[key] &#x3D; options[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 把参数带到baseCompile</span><br><span class="line">    const compiled &#x3D; baseCompile(template, finalOptions)</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      errors.push.apply(errors, detectErrors(compiled.ast))</span><br><span class="line">    &#125;</span><br><span class="line">    compiled.errors &#x3D; errors</span><br><span class="line">    compiled.tips &#x3D; tips</span><br><span class="line">    return compiled</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>第一句就出现了位置变量，根据 build/alias 的定义以及 web-runtime-with-compiler.js 里面的引用，可以发现在<code>src/platforms/web/compiler/index.js</code>里面使用了 createCompiler 方法，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* @flow *&#x2F;</span><br><span class="line"></span><br><span class="line">import &#123; isUnaryTag, canBeLeftOpenTag &#125; from &#39;.&#x2F;util&#39;</span><br><span class="line">import &#123; genStaticKeys &#125; from &#39;shared&#x2F;util&#39;</span><br><span class="line">import &#123; createCompiler &#125; from &#39;compiler&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line">import modules from &#39;.&#x2F;modules&#x2F;index&#39;</span><br><span class="line">import directives from &#39;.&#x2F;directives&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line">import &#123;</span><br><span class="line">  isPreTag,</span><br><span class="line">  mustUseProp,</span><br><span class="line">  isReservedTag,</span><br><span class="line">  getTagNamespace</span><br><span class="line">&#125; from &#39;..&#x2F;util&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line">export const baseOptions: CompilerOptions &#x3D; &#123;</span><br><span class="line">  expectHTML: true,</span><br><span class="line">  modules,</span><br><span class="line">  directives,</span><br><span class="line">  isPreTag,</span><br><span class="line">  isUnaryTag,</span><br><span class="line">  mustUseProp,</span><br><span class="line">  canBeLeftOpenTag,</span><br><span class="line">  isReservedTag,</span><br><span class="line">  getTagNamespace,</span><br><span class="line">  staticKeys: genStaticKeys(modules)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const &#123; compile, compileToFunctions &#125; &#x3D; createCompiler(baseOptions)</span><br><span class="line">export &#123; compile, compileToFunctions &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后 baseOptions 就在这里定义了，具体参数及方法会在用到的时候细看</p>
<p>运行到<code>baseCompile</code>，然后进入<code>parse</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function baseCompile (</span><br><span class="line">  template: string,</span><br><span class="line">  options: CompilerOptions</span><br><span class="line">): CompiledResult &#123;</span><br><span class="line">  const ast &#x3D; parse(template.trim(), options)</span><br><span class="line">  optimize(ast, options)</span><br><span class="line">  const code &#x3D; generate(ast, options)</span><br><span class="line">  return &#123;</span><br><span class="line">    ast,</span><br><span class="line">    render: code.render,</span><br><span class="line">    staticRenderFns: code.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>parse</code>在/src/compiler/parser/index.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Convert HTML string to AST.</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function parse (</span><br><span class="line">  template: string,</span><br><span class="line">  options: CompilerOptions</span><br><span class="line">): ASTElement | void &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; warn函数</span><br><span class="line">  warn &#x3D; options.warn || baseWarn</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 获取命名空间，svg和math</span><br><span class="line">  platformGetTagNamespace &#x3D; options.getTagNamespace || no</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 需要使用props绑定的属性，比如value、selected等</span><br><span class="line">  platformMustUseProp &#x3D; options.mustUseProp || no</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 是否是pre标签</span><br><span class="line">  platformIsPreTag &#x3D; options.isPreTag || no</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 取options.modules里有preTransformNode参数的数组，下同</span><br><span class="line">  preTransforms &#x3D; pluckModuleFunction(options.modules, &#39;preTransformNode&#39;)</span><br><span class="line">  transforms &#x3D; pluckModuleFunction(options.modules, &#39;transformNode&#39;)</span><br><span class="line">  postTransforms &#x3D; pluckModuleFunction(options.modules, &#39;postTransformNode&#39;)</span><br><span class="line">  delimiters &#x3D; options.delimiters</span><br><span class="line"></span><br><span class="line">  const stack &#x3D; []</span><br><span class="line">  const preserveWhitespace &#x3D; options.preserveWhitespace !&#x3D;&#x3D; false</span><br><span class="line">  let root</span><br><span class="line">  let currentParent</span><br><span class="line">  let inVPre &#x3D; false</span><br><span class="line">  let inPre &#x3D; false</span><br><span class="line">  let warned &#x3D; false</span><br><span class="line"></span><br><span class="line">  function warnOnce (msg) &#123;</span><br><span class="line">    if (!warned) &#123;</span><br><span class="line">      warned &#x3D; true</span><br><span class="line">      warn(msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function endPre (element) &#123;</span><br><span class="line">    &#x2F;&#x2F; check pre state</span><br><span class="line">    if (element.pre) &#123;</span><br><span class="line">      inVPre &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line">    if (platformIsPreTag(element.tag)) &#123;</span><br><span class="line">      inPre &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  parseHTML(template, &#123;</span><br><span class="line">    warn,</span><br><span class="line">    expectHTML: options.expectHTML,</span><br><span class="line">    isUnaryTag: options.isUnaryTag,</span><br><span class="line">    canBeLeftOpenTag: options.canBeLeftOpenTag,</span><br><span class="line">    shouldDecodeNewlines: options.shouldDecodeNewlines,</span><br><span class="line">    start (tag, attrs, unary) &#123;</span><br><span class="line">      &#x2F;&#x2F; check namespace.</span><br><span class="line">      &#x2F;&#x2F; inherit parent ns if there is one</span><br><span class="line">      &#x2F;&#x2F; 第一遍还不清楚是啥</span><br><span class="line">      const ns &#x3D; (currentParent &amp;&amp; currentParent.ns) || platformGetTagNamespace(tag)</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; handle IE svg bug</span><br><span class="line">      &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">      if (isIE &amp;&amp; ns &#x3D;&#x3D;&#x3D; &#39;svg&#39;) &#123;</span><br><span class="line">        attrs &#x3D; guardIESVGBug(attrs)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const element: ASTElement &#x3D; &#123;</span><br><span class="line">        type: 1,</span><br><span class="line">        tag,</span><br><span class="line">        attrsList: attrs,</span><br><span class="line">        attrsMap: makeAttrsMap(attrs), &#x2F;&#x2F; 把attr转换成对象，并且检验重复属性</span><br><span class="line">        parent: currentParent,</span><br><span class="line">        children: []</span><br><span class="line">      &#125;</span><br><span class="line">      if (ns) &#123;</span><br><span class="line">        element.ns &#x3D; ns</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 如果标签是style和script</span><br><span class="line">      if (isForbiddenTag(element) &amp;&amp; !isServerRendering()) &#123;</span><br><span class="line">        element.forbidden &#x3D; true</span><br><span class="line">        process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; warn(</span><br><span class="line">          &#39;Templates should only be responsible for mapping the state to the &#39; +</span><br><span class="line">          &#39;UI. Avoid placing tags with side-effects in your templates, such as &#39; +</span><br><span class="line">          &#96;&lt;$&#123;tag&#125;&gt;&#96; + &#39;, as they will not be parsed.&#39;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; apply pre-transforms</span><br><span class="line">      for (let i &#x3D; 0; i &lt; preTransforms.length; i++) &#123;</span><br><span class="line">        preTransforms[i](element, options)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!inVPre) &#123;</span><br><span class="line">        processPre(element) &#x2F;&#x2F; 如果标签有v-pre，则element.pre &#x3D; true</span><br><span class="line">        if (element.pre) &#123;</span><br><span class="line">          inVPre &#x3D; true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (platformIsPreTag(element.tag)) &#123; &#x2F;&#x2F; 判断tag是不是pre</span><br><span class="line">        inPre &#x3D; true</span><br><span class="line">      &#125;</span><br><span class="line">      if (inVPre) &#123;</span><br><span class="line">        processRawAttrs(element)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        processFor(element) &#x2F;&#x2F; v-for</span><br><span class="line">        processIf(element) &#x2F;&#x2F; v-if</span><br><span class="line">        processOnce(element) &#x2F;&#x2F; v-once element.once &#x3D; true</span><br><span class="line">        processKey(element) &#x2F;&#x2F; key element.key &#x3D; i</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; determine whether this is a plain element after</span><br><span class="line">        &#x2F;&#x2F; removing structural attributes</span><br><span class="line">        &#x2F;&#x2F; 不存在其他属性的&#39;纯&#39;元素</span><br><span class="line">        element.plain &#x3D; !element.key &amp;&amp; !attrs.length</span><br><span class="line"></span><br><span class="line">        processRef(element) &#x2F;&#x2F; ref</span><br><span class="line">        processSlot(element) &#x2F;&#x2F; slot</span><br><span class="line">        processComponent(element) &#x2F;&#x2F; is</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; transforms包含了class和style的处理函数</span><br><span class="line">        &#x2F;&#x2F; 给element添加了staticClass(class)和classBinding(:class||v-bind:class)属性</span><br><span class="line">        &#x2F;&#x2F; 给element添加了staticStyle(style)和styleBinding(:style||v-bind:style)属性</span><br><span class="line">        for (let i &#x3D; 0; i &lt; transforms.length; i++) &#123;</span><br><span class="line">          transforms[i](element, options)</span><br><span class="line">        &#125;</span><br><span class="line">        processAttrs(element) &#x2F;&#x2F; 处理除了上面的其他属性</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      function checkRootConstraints (el) &#123;</span><br><span class="line">        if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">          &#x2F;&#x2F; slot和template报错提示</span><br><span class="line">          if (el.tag &#x3D;&#x3D;&#x3D; &#39;slot&#39; || el.tag &#x3D;&#x3D;&#x3D; &#39;template&#39;) &#123;</span><br><span class="line">            warnOnce(</span><br><span class="line">              &#96;Cannot use &lt;$&#123;el.tag&#125;&gt; as component root element because it may &#96; +</span><br><span class="line">              &#39;contain multiple nodes.&#39;</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; 根节点不能加v-for报错提示</span><br><span class="line">          if (el.attrsMap.hasOwnProperty(&#39;v-for&#39;)) &#123;</span><br><span class="line">            warnOnce(</span><br><span class="line">              &#39;Cannot use v-for on stateful component root element because &#39; +</span><br><span class="line">              &#39;it renders multiple elements.&#39;</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; tree management</span><br><span class="line">      if (!root) &#123; &#x2F;&#x2F; 第一次进入这个if</span><br><span class="line">        root &#x3D; element</span><br><span class="line">        checkRootConstraints(root) &#x2F;&#x2F; 见上面函数</span><br><span class="line">      &#125; else if (!stack.length) &#123;</span><br><span class="line">        &#x2F;&#x2F; allow root elements with v-if, v-else-if and v-else</span><br><span class="line">        if (root.if &amp;&amp; (element.elseif || element.else)) &#123;</span><br><span class="line">          checkRootConstraints(element)</span><br><span class="line">          addIfCondition(root, &#123;</span><br><span class="line">            exp: element.elseif,</span><br><span class="line">            block: element</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; else if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">          warnOnce(</span><br><span class="line">            &#96;Component template should contain exactly one root element. &#96; +</span><br><span class="line">            &#96;If you are using v-if on multiple elements, &#96; +</span><br><span class="line">            &#96;use v-else-if to chain them instead.&#96;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (currentParent &amp;&amp; !element.forbidden) &#123; &#x2F;&#x2F; 第一次不进if</span><br><span class="line">        if (element.elseif || element.else) &#123;</span><br><span class="line">          processIfConditions(element, currentParent)</span><br><span class="line">        &#125; else if (element.slotScope) &#123; &#x2F;&#x2F; scoped slot</span><br><span class="line">          currentParent.plain &#x3D; false</span><br><span class="line">          const name &#x3D; element.slotTarget || &#39;&quot;default&quot;&#39;</span><br><span class="line">          ;(currentParent.scopedSlots || (currentParent.scopedSlots &#x3D; &#123;&#125;))[name] &#x3D; element</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          currentParent.children.push(element)</span><br><span class="line">          element.parent &#x3D; currentParent</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (!unary) &#123; &#x2F;&#x2F; 不是单标签</span><br><span class="line">        currentParent &#x3D; element</span><br><span class="line">        stack.push(element)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        endPre(element)</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; apply post-transforms</span><br><span class="line">      &#x2F;&#x2F; 不知道是啥</span><br><span class="line">      for (let i &#x3D; 0; i &lt; postTransforms.length; i++) &#123;</span><br><span class="line">        postTransforms[i](element, options)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    end () &#123;</span><br><span class="line">      &#x2F;&#x2F; remove trailing whitespace</span><br><span class="line">      const element &#x3D; stack[stack.length - 1]</span><br><span class="line">      const lastNode &#x3D; element.children[element.children.length - 1]</span><br><span class="line">      if (lastNode &amp;&amp; lastNode.type &#x3D;&#x3D;&#x3D; 3 &amp;&amp; lastNode.text &#x3D;&#x3D;&#x3D; &#39; &#39; &amp;&amp; !inPre) &#123;</span><br><span class="line">        element.children.pop()</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; pop stack 删除最近的一个闭合标签</span><br><span class="line">      stack.length -&#x3D; 1</span><br><span class="line">      &#x2F;&#x2F; currentParent变为上一层节点</span><br><span class="line">      currentParent &#x3D; stack[stack.length - 1]</span><br><span class="line">      &#x2F;&#x2F; pre做结束处理</span><br><span class="line">      endPre(element)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    chars (text: string) &#123;</span><br><span class="line">      if (!currentParent) &#123; &#x2F;&#x2F; 这里可能是Component template必须要有个根节点</span><br><span class="line">        if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">          if (text &#x3D;&#x3D;&#x3D; template) &#123;</span><br><span class="line">            warnOnce(</span><br><span class="line">              &#39;Component template requires a root element, rather than just text.&#39;</span><br><span class="line">            )</span><br><span class="line">          &#125; else if ((text &#x3D; text.trim())) &#123;</span><br><span class="line">            warnOnce(</span><br><span class="line">              &#96;text &quot;$&#123;text&#125;&quot; outside root element will be ignored.&#96;</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; IE textarea placeholder bug</span><br><span class="line">      &#x2F;&#x2F; ie才有的bug，现在没条件测试</span><br><span class="line">      &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">      if (isIE &amp;&amp;</span><br><span class="line">          currentParent.tag &#x3D;&#x3D;&#x3D; &#39;textarea&#39; &amp;&amp;</span><br><span class="line">          currentParent.attrsMap.placeholder &#x3D;&#x3D;&#x3D; text) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      const children &#x3D; currentParent.children</span><br><span class="line">      text &#x3D; inPre || text.trim() &#x2F;&#x2F; pre里面或者存在静态文本</span><br><span class="line">        ? decodeHTMLCached(text) &#x2F;&#x2F; text处理,取了textContent的值，在chrome把&lt;转为了&lt;</span><br><span class="line">        &#x2F;&#x2F; only preserve whitespace if its not right after a starting tag</span><br><span class="line">        : preserveWhitespace &amp;&amp; children.length ? &#39; &#39; : &#39;&#39;</span><br><span class="line">      if (text) &#123;</span><br><span class="line">        let expression</span><br><span class="line">        if (!inVPre &amp;&amp; text !&#x3D;&#x3D; &#39; &#39; &amp;&amp; (expression &#x3D; parseText(text, delimiters))) &#123; &#x2F;&#x2F; 判断是不是&#123;&#123;&#125;&#125;表达式, 并提取表达式为render函数</span><br><span class="line">          children.push(&#123;</span><br><span class="line">            type: 2,</span><br><span class="line">            expression,</span><br><span class="line">            text</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; else if (text !&#x3D;&#x3D; &#39; &#39; || !children.length || children[children.length - 1].text !&#x3D;&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F; 纯粹的静态文本、父节点v-pre|pre、</span><br><span class="line">          children.push(&#123;</span><br><span class="line">            type: 3,</span><br><span class="line">            text</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行到<code>parseHTML</code>,继续跟进</p>
<p>文件在 src/compiler/parser/html-parser.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function parseHTML (html, options) &#123;</span><br><span class="line">  const stack &#x3D; [] &#x2F;&#x2F; 一些赋值操作</span><br><span class="line">  const expectHTML &#x3D; options.expectHTML</span><br><span class="line">  const isUnaryTag &#x3D; options.isUnaryTag || no</span><br><span class="line">  const canBeLeftOpenTag &#x3D; options.canBeLeftOpenTag || no</span><br><span class="line">  let index &#x3D; 0</span><br><span class="line">  let last, lastTag</span><br><span class="line">  while (html) &#123; &#x2F;&#x2F; 循环template模板</span><br><span class="line">    last &#x3D; html</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Make sure we&#39;re not in a plaintext content element like script&#x2F;style</span><br><span class="line">    &#x2F;&#x2F; 不是script,style,textarea中的一个</span><br><span class="line">    if (!lastTag || !isPlainTextElement(lastTag)) &#123;</span><br><span class="line">      let textEnd &#x3D; html.indexOf(&#39;&lt;&#39;)</span><br><span class="line">      if (textEnd &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Comment: 是不是注释</span><br><span class="line">        &#x2F;&#x2F; 注释直接截取不做额外处理</span><br><span class="line">        if (comment.test(html)) &#123;</span><br><span class="line">          const commentEnd &#x3D; html.indexOf(&#39;--&gt;&#39;)</span><br><span class="line"></span><br><span class="line">          if (commentEnd &gt;&#x3D; 0) &#123;</span><br><span class="line">            advance(commentEnd + 3)</span><br><span class="line">            continue</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; http:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Conditional_comment#Downlevel-revealed_conditional_comment</span><br><span class="line">        &#x2F;&#x2F; 看链接</span><br><span class="line">        if (conditionalComment.test(html)) &#123;</span><br><span class="line">          const conditionalEnd &#x3D; html.indexOf(&#39;]&gt;&#39;)</span><br><span class="line"></span><br><span class="line">          if (conditionalEnd &gt;&#x3D; 0) &#123;</span><br><span class="line">            advance(conditionalEnd + 2)</span><br><span class="line">            continue</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Doctype:</span><br><span class="line">        const doctypeMatch &#x3D; html.match(doctype)</span><br><span class="line">        if (doctypeMatch) &#123;</span><br><span class="line">          advance(doctypeMatch[0].length)</span><br><span class="line">          continue</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; End tag: 末尾标签</span><br><span class="line">        const endTagMatch &#x3D; html.match(endTag)</span><br><span class="line">        if (endTagMatch) &#123;</span><br><span class="line">          const curIndex &#x3D; index</span><br><span class="line">          advance(endTagMatch[0].length)</span><br><span class="line">          parseEndTag(endTagMatch[1], curIndex, index)</span><br><span class="line">          continue</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Start tag: 开始标签</span><br><span class="line">        const startTagMatch &#x3D; parseStartTag()</span><br><span class="line">        if (startTagMatch) &#123;</span><br><span class="line">          handleStartTag(startTagMatch)</span><br><span class="line">          continue</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      let text, rest, next</span><br><span class="line">      if (textEnd &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 第二次进这里 去除换行符</span><br><span class="line">        rest &#x3D; html.slice(textEnd)</span><br><span class="line">        while (</span><br><span class="line">          !endTag.test(rest) &amp;&amp; &#x2F;&#x2F; 不是结束标签</span><br><span class="line">          !startTagOpen.test(rest) &amp;&amp; &#x2F;&#x2F; 不是开始标签</span><br><span class="line">          !comment.test(rest) &amp;&amp; &#x2F;&#x2F; 不是注释</span><br><span class="line">          !conditionalComment.test(rest) &#x2F;&#x2F; 不是![</span><br><span class="line">        ) &#123;</span><br><span class="line">          &#x2F;&#x2F; &lt; in plain text, be forgiving and treat it as text</span><br><span class="line">          &#x2F;&#x2F; &lt;可能会存在文本中，fds&quot;&lt;&quot;fasdf,但在chrome里&lt;会被转化为&lt;</span><br><span class="line">          &#x2F;&#x2F; 目前还不清楚怎么进这个条件</span><br><span class="line">          &#x2F;&#x2F; 不过这里的最终目的还是为了找到最近的并且是标签的&lt;</span><br><span class="line">          next &#x3D; rest.indexOf(&#39;&lt;&#39;, 1)</span><br><span class="line">          if (next &lt; 0) break</span><br><span class="line">          textEnd +&#x3D; next</span><br><span class="line">          rest &#x3D; html.slice(textEnd)</span><br><span class="line">        &#125;</span><br><span class="line">        text &#x3D; html.substring(0, textEnd)</span><br><span class="line">        advance(textEnd)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (textEnd &lt; 0) &#123;</span><br><span class="line">        text &#x3D; html</span><br><span class="line">        html &#x3D; &#39;&#39;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (options.chars &amp;&amp; text) &#123; &#x2F;&#x2F; 本例第二次loop进入这里</span><br><span class="line">        options.chars(text)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      var stackedTag &#x3D; lastTag.toLowerCase()</span><br><span class="line">      var reStackedTag &#x3D; reCache[stackedTag] || (reCache[stackedTag] &#x3D; new RegExp(&#39;([\\s\\S]*?)(&lt;&#x2F;&#39; + stackedTag + &#39;[^&gt;]*&gt;)&#39;, &#39;i&#39;))</span><br><span class="line">      var endTagLength &#x3D; 0</span><br><span class="line">      var rest &#x3D; html.replace(reStackedTag, function (all, text, endTag) &#123;</span><br><span class="line">        endTagLength &#x3D; endTag.length</span><br><span class="line">        if (!isPlainTextElement(stackedTag) &amp;&amp; stackedTag !&#x3D;&#x3D; &#39;noscript&#39;) &#123;</span><br><span class="line">          text &#x3D; text</span><br><span class="line">            .replace(&#x2F;&lt;!--([\s\S]*?)--&gt;&#x2F;g, &#39;$1&#39;)</span><br><span class="line">            .replace(&#x2F;&lt;!\[CDATA\[([\s\S]*?)]]&gt;&#x2F;g, &#39;$1&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">        if (options.chars) &#123;</span><br><span class="line">          options.chars(text)</span><br><span class="line">        &#125;</span><br><span class="line">        return &#39;&#39;</span><br><span class="line">      &#125;)</span><br><span class="line">      index +&#x3D; html.length - rest.length</span><br><span class="line">      html &#x3D; rest</span><br><span class="line">      parseEndTag(stackedTag, index - endTagLength, index)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (html &#x3D;&#x3D;&#x3D; last) &#123;</span><br><span class="line">      options.chars &amp;&amp; options.chars(html)</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; !stack.length &amp;&amp; options.warn) &#123;</span><br><span class="line">        options.warn(&#96;Mal-formatted tag at end of template: &quot;$&#123;html&#125;&quot;&#96;)</span><br><span class="line">      &#125;</span><br><span class="line">      break</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Clean up any remaining tags</span><br><span class="line">  parseEndTag()</span><br><span class="line"></span><br><span class="line">  function advance (n) &#123;</span><br><span class="line">    index +&#x3D; n</span><br><span class="line">    html &#x3D; html.substring(n)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function parseStartTag () &#123;</span><br><span class="line">    &#x2F;&#x2F; match在不加g的时候同exec方法</span><br><span class="line">    &#x2F;&#x2F; 0返回匹配，1返回正则括号里的匹配</span><br><span class="line">    const start &#x3D; html.match(startTagOpen)</span><br><span class="line">    if (start) &#123;</span><br><span class="line">      const match &#x3D; &#123;</span><br><span class="line">        tagName: start[1],</span><br><span class="line">        attrs: [],</span><br><span class="line">        start: index</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 给index重新赋值并且截取html模板</span><br><span class="line">      advance(start[0].length)</span><br><span class="line">      let end, attr</span><br><span class="line">      &#x2F;&#x2F; end匹配&gt;,attr获取标签的属性(id,class等)</span><br><span class="line">      &#x2F;&#x2F; attr并不能一次性获取全部属性，而是通过不断的遍历和截取字符窜每次获取一组属性</span><br><span class="line">      &#x2F;&#x2F; 这个匹配正则需要研究一下</span><br><span class="line">      &#x2F;&#x2F; &#x2F;^\s*([^\s&quot;&#39;&lt;&gt;\&#x2F;&#x3D;]+)(?:\s*((?:&#x3D;))\s*(?:&quot;([^&quot;]*)&quot;+|&#39;([^&#39;]*)&#39;+|([^\s&quot;&#39;&#x3D;&lt;&gt;&#96;]+)))?&#x2F;</span><br><span class="line">      &#x2F;&#x2F; 3,4,5分别匹配了id&#x3D;&quot;app&quot;|id&#x3D;&#39;app&#39;|id&#x3D;app 三种属性书写格式</span><br><span class="line">      &#x2F;&#x2F; 当匹配到末尾标签&gt;时跳出循环</span><br><span class="line">      while (!(end &#x3D; html.match(startTagClose)) &amp;&amp; (attr &#x3D; html.match(attribute))) &#123;</span><br><span class="line">        advance(attr[0].length)</span><br><span class="line">        match.attrs.push(attr)</span><br><span class="line">      &#125;</span><br><span class="line">      if (end) &#123;</span><br><span class="line">        &#x2F;&#x2F; 单标签斜杠</span><br><span class="line">        match.unarySlash &#x3D; end[1]</span><br><span class="line">        advance(end[0].length)</span><br><span class="line">        match.end &#x3D; index &#x2F;&#x2F; 末尾index</span><br><span class="line">        return match</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function handleStartTag (match) &#123;</span><br><span class="line">    const tagName &#x3D; match.tagName</span><br><span class="line">    const unarySlash &#x3D; match.unarySlash</span><br><span class="line"></span><br><span class="line">    if (expectHTML) &#123;</span><br><span class="line">      &#x2F;&#x2F; 判断了p和 不是段落标签 (这是标签嵌套规范，可以自行搜索)</span><br><span class="line">      if (lastTag &#x3D;&#x3D;&#x3D; &#39;p&#39; &amp;&amp; isNonPhrasingTag(tagName)) &#123;</span><br><span class="line">        parseEndTag(lastTag)</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 可以不闭合的标签</span><br><span class="line">      if (canBeLeftOpenTag(tagName) &amp;&amp; lastTag &#x3D;&#x3D;&#x3D; tagName) &#123;</span><br><span class="line">        parseEndTag(tagName)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 是否单标签</span><br><span class="line">    const unary &#x3D; isUnaryTag(tagName) || tagName &#x3D;&#x3D;&#x3D; &#39;html&#39; &amp;&amp; lastTag &#x3D;&#x3D;&#x3D; &#39;head&#39; || !!unarySlash</span><br><span class="line"></span><br><span class="line">    const l &#x3D; match.attrs.length</span><br><span class="line">    const attrs &#x3D; new Array(l)</span><br><span class="line">    for (let i &#x3D; 0; i &lt; l; i++) &#123;</span><br><span class="line">      const args &#x3D; match.attrs[i]</span><br><span class="line">      &#x2F;&#x2F; hackish work around FF bug https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id&#x3D;369778</span><br><span class="line">      if (IS_REGEX_CAPTURING_BROKEN &amp;&amp; args[0].indexOf(&#39;&quot;&quot;&#39;) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">        if (args[3] &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123; delete args[3] &#125;</span><br><span class="line">        if (args[4] &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123; delete args[4] &#125;</span><br><span class="line">        if (args[5] &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123; delete args[5] &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      const value &#x3D; args[3] || args[4] || args[5] || &#39;&#39;</span><br><span class="line">      attrs[i] &#x3D; &#123;</span><br><span class="line">        name: args[1],</span><br><span class="line">        value: decodeAttr(</span><br><span class="line">          value,</span><br><span class="line">          options.shouldDecodeNewlines &#x2F;&#x2F; ie才会出的问题，其他浏览器没有</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 不是单标签就添加到stack数组</span><br><span class="line">    if (!unary) &#123;</span><br><span class="line">      stack.push(&#123; tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs &#125;)</span><br><span class="line">      lastTag &#x3D; tagName</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (options.start) &#123; &#x2F;&#x2F; 这里调用start方法，回到start函数</span><br><span class="line">      options.start(tagName, attrs, unary, match.start, match.end)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function parseEndTag (tagName, start, end) &#123;</span><br><span class="line">    let pos, lowerCasedTagName</span><br><span class="line">    if (start &#x3D;&#x3D; null) start &#x3D; index</span><br><span class="line">    if (end &#x3D;&#x3D; null) end &#x3D; index</span><br><span class="line"></span><br><span class="line">    if (tagName) &#123;</span><br><span class="line">      lowerCasedTagName &#x3D; tagName.toLowerCase()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Find the closest opened tag of the same type</span><br><span class="line">    &#x2F;&#x2F; 找到最近的相同标签</span><br><span class="line">    if (tagName) &#123;</span><br><span class="line">      for (pos &#x3D; stack.length - 1; pos &gt;&#x3D; 0; pos--) &#123;</span><br><span class="line">        if (stack[pos].lowerCasedTag &#x3D;&#x3D;&#x3D; lowerCasedTagName) &#123;</span><br><span class="line">          break</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; If no tag name is provided, clean shop</span><br><span class="line">      pos &#x3D; 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (pos &gt;&#x3D; 0) &#123;</span><br><span class="line">      &#x2F;&#x2F; Close all the open elements, up the stack</span><br><span class="line">      &#x2F;&#x2F;</span><br><span class="line">      for (let i &#x3D; stack.length - 1; i &gt;&#x3D; pos; i--) &#123;</span><br><span class="line">        if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp;</span><br><span class="line">            (i &gt; pos || !tagName) &amp;&amp;</span><br><span class="line">            options.warn) &#123;</span><br><span class="line">          &#x2F;&#x2F; 没有对应的结束标签</span><br><span class="line">          options.warn(</span><br><span class="line">            &#96;tag &lt;$&#123;stack[i].tag&#125;&gt; has no matching end tag.&#96;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        if (options.end) &#123;</span><br><span class="line">          options.end(stack[i].tag, start, end)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Remove the open elements from the stack</span><br><span class="line">      &#x2F;&#x2F; 删除最后一个</span><br><span class="line">      stack.length &#x3D; pos</span><br><span class="line">      &#x2F;&#x2F; lastTag变成最后一个</span><br><span class="line">      lastTag &#x3D; pos &amp;&amp; stack[pos - 1].tag</span><br><span class="line">    &#125; else if (lowerCasedTagName &#x3D;&#x3D;&#x3D; &#39;br&#39;) &#123;</span><br><span class="line">      if (options.start) &#123;</span><br><span class="line">        options.start(tagName, [], true, start, end)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (lowerCasedTagName &#x3D;&#x3D;&#x3D; &#39;p&#39;) &#123;</span><br><span class="line">      if (options.start) &#123;</span><br><span class="line">        options.start(tagName, [], false, start, end)</span><br><span class="line">      &#125;</span><br><span class="line">      if (options.end) &#123;</span><br><span class="line">        options.end(tagName, start, end)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>parse 返回了一个 ast 树，所有的节点都经过了最基础的处理。<br>然后是<code>optimize(ast, options)</code></p>
<p><code>optimize</code>在 src/compiler/optimizer.js</p>
<p><code>optimize</code>的作用是找出 ast 树里面的静态节点(节点是静态文本也没有 v 事件绑定)和静态根节点(节点下的所有子节点都是静态节点)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Goal of the optimizer: walk the generated template AST tree</span><br><span class="line"> * and detect sub-trees that are purely static, i.e. parts of</span><br><span class="line"> * the DOM that never needs to change.</span><br><span class="line"> * 找出ast里面的静态节点，然后不需要重复的取处理他们(因为他们是静态的不会改变的)</span><br><span class="line"> *</span><br><span class="line"> * Once we detect these sub-trees, we can:</span><br><span class="line"> *</span><br><span class="line"> * 1. Hoist them into constants, so that we no longer need to</span><br><span class="line"> *    create fresh nodes for them on each re-render;</span><br><span class="line"> * 2. Completely skip them in the patching process.</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function optimize (root: ?ASTElement, options: CompilerOptions) &#123;</span><br><span class="line">  if (!root) return</span><br><span class="line">  isStaticKey &#x3D; genStaticKeysCached(options.staticKeys || &#39;&#39;)</span><br><span class="line">  isPlatformReservedTag &#x3D; options.isReservedTag || no</span><br><span class="line">  &#x2F;&#x2F; first pass: mark all non-static nodes.</span><br><span class="line">  &#x2F;&#x2F; 标记节点是否静态</span><br><span class="line">  markStatic(root)</span><br><span class="line">  &#x2F;&#x2F; second pass: mark static roots.</span><br><span class="line">  &#x2F;&#x2F; 标记是否是静态根节点</span><br><span class="line">  markStaticRoots(root, false)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function markStatic (node: ASTNode) &#123;</span><br><span class="line">  node.static &#x3D; isStatic(node)</span><br><span class="line">  if (node.type &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">    &#x2F;&#x2F; do not make component slot content static. this avoids</span><br><span class="line">    &#x2F;&#x2F; 1. components not able to mutate slot nodes</span><br><span class="line">    &#x2F;&#x2F; 2. static slot content fails for hot-reloading</span><br><span class="line">    if (</span><br><span class="line">      !isPlatformReservedTag(node.tag) &amp;&amp;</span><br><span class="line">      node.tag !&#x3D;&#x3D; &#39;slot&#39; &amp;&amp;</span><br><span class="line">      node.attrsMap[&#39;inline-template&#39;] &#x3D;&#x3D; null</span><br><span class="line">    ) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i &#x3D; 0, l &#x3D; node.children.length; i &lt; l; i++) &#123;</span><br><span class="line">      const child &#x3D; node.children[i]</span><br><span class="line">      markStatic(child)</span><br><span class="line">      if (!child.static) &#123;</span><br><span class="line">        node.static &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isStatic (node: ASTNode): boolean &#123;</span><br><span class="line">  if (node.type &#x3D;&#x3D;&#x3D; 2) &#123; &#x2F;&#x2F; expression 有表达式就不是</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">  if (node.type &#x3D;&#x3D;&#x3D; 3) &#123; &#x2F;&#x2F; text &#x2F;&#x2F; 文本就是</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">  return !!(node.pre || ( &#x2F;&#x2F; v-pre不做编译，是</span><br><span class="line">    !node.hasBindings &amp;&amp; &#x2F;&#x2F; no dynamic bindings 没有动态绑定</span><br><span class="line">    !node.if &amp;&amp; !node.for &amp;&amp; &#x2F;&#x2F; not v-if or v-for or v-else</span><br><span class="line">    !isBuiltInTag(node.tag) &amp;&amp; &#x2F;&#x2F; not a built-in</span><br><span class="line">    isPlatformReservedTag(node.tag) &amp;&amp; &#x2F;&#x2F; not a component</span><br><span class="line">    !isDirectChildOfTemplateFor(node) &amp;&amp; &#x2F;&#x2F; template没有for</span><br><span class="line">    Object.keys(node).every(isStaticKey) &#x2F;&#x2F; 节点的属性只能是isStaticKey里面那几个</span><br><span class="line">  ))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function markStaticRoots (node: ASTNode, isInFor: boolean) &#123;</span><br><span class="line">  if (node.type &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">    if (node.static || node.once) &#123;</span><br><span class="line">      node.staticInFor &#x3D; isInFor</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; For a node to qualify as a static root, it should have children that</span><br><span class="line">    &#x2F;&#x2F; are not just static text. Otherwise the cost of hoisting out will</span><br><span class="line">    &#x2F;&#x2F; outweigh the benefits and it&#39;s better off to just always render it fresh.</span><br><span class="line">    if (node.static &amp;&amp; node.children.length &amp;&amp; !( &#x2F;&#x2F; 该节点静态</span><br><span class="line">      node.children.length &#x3D;&#x3D;&#x3D; 1 &amp;&amp; &#x2F;&#x2F; 节点只有一个子节点</span><br><span class="line">      node.children[0].type &#x3D;&#x3D;&#x3D; 3 &#x2F;&#x2F; 子节点是文本节点</span><br><span class="line">    )) &#123;</span><br><span class="line">      node.staticRoot &#x3D; true</span><br><span class="line">      return</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      node.staticRoot &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line">    if (node.children) &#123; &#x2F;&#x2F; 有多个子节点就进行循环递归判断</span><br><span class="line">      for (let i &#x3D; 0, l &#x3D; node.children.length; i &lt; l; i++) &#123;</span><br><span class="line">        markStaticRoots(node.children[i], isInFor || !!node.for)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (node.ifConditions) &#123;</span><br><span class="line">      walkThroughConditionsBlocks(node.ifConditions, isInFor)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/my-notes/2019/07/02/%E7%AE%97%E6%B3%95/0.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul>
<li>push 和 pop</li>
<li>后进先出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Stack &#123;</span><br><span class="line">    constructor(...items) &#123;</span><br><span class="line">        this.reverse &#x3D; false;</span><br><span class="line">        this.stack &#x3D; [...items];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    push(...items) &#123;</span><br><span class="line">        return this.reverse</span><br><span class="line">            ? this.stack.unshift(...items)</span><br><span class="line">            : this.stack.push(...items);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pop() &#123;</span><br><span class="line">        return this.reverse ? this.stack.shift() : this.stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const stack &#x3D; new Stack(4, 5);</span><br><span class="line">stack.reverse &#x3D; true;</span><br><span class="line">console.log(stack.push(1, 2, 3) &#x3D;&#x3D;&#x3D; 5) &#x2F;&#x2F; true</span><br><span class="line">console.log(stack.stack &#x3D;&#x3D;&#x3D;[1, 2, 3, 4, 5]) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul>
<li>unshift 和 pop</li>
<li>先进先出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Queue &#123;</span><br><span class="line">    constructor(...items) &#123;</span><br><span class="line">        this.reverse &#x3D; false;</span><br><span class="line">        this.queue &#x3D; [...items];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    enqueue(...items) &#123;</span><br><span class="line">        return this.reverse</span><br><span class="line">            ? this.queue.push(...items)</span><br><span class="line">            : this.queue.unshift(...items);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dequeue() &#123;</span><br><span class="line">        return this.reverse ? this.queue.shift() : this.queue.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><ul>
<li>pop、unshift、shift、push、delete</li>
<li>print</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    constructor(data) &#123;</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">        this.next &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class NodeList &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.head &#x3D; null;</span><br><span class="line">        this.tail &#x3D; null;</span><br><span class="line">        this.length &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    push(data) &#123;</span><br><span class="line">        if (!data) return null;</span><br><span class="line">        const node &#x3D;  new Node(data);</span><br><span class="line">        if (this.isEmpty()) &#123;</span><br><span class="line">          this.head &#x3D; node</span><br><span class="line">          this.tail &#x3D; node</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.tail.next &#x3D; node</span><br><span class="line">            this.tail &#x3D; node</span><br><span class="line">        &#125;</span><br><span class="line">        this.length++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unshift(data) &#123;</span><br><span class="line">        if (!data) return null;</span><br><span class="line">        const node &#x3D;  new Node(data);</span><br><span class="line">        if (this.isEmpty()) &#123;</span><br><span class="line">          this.head &#x3D; node</span><br><span class="line">          this.tail &#x3D; node</span><br><span class="line">        &#125;</span><br><span class="line">        node.next &#x3D; this.head;</span><br><span class="line">        this.head &#x3D; node</span><br><span class="line">        this.length++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pop() &#123;</span><br><span class="line">        if (this.isEmpty()) return null;</span><br><span class="line">        let node &#x3D; this.head;</span><br><span class="line">        const tail &#x3D; this.tail;</span><br><span class="line">        if (this.length &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">            this.head &#x3D; this.tail &#x3D; null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while(node.next) &#123;</span><br><span class="line">                if (node.next &#x3D;&#x3D;&#x3D; this.tail) &#123;</span><br><span class="line">                    node.next &#x3D; null;</span><br><span class="line">                    this.tail &#x3D; node;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                node &#x3D; node.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.length--;</span><br><span class="line">        return tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shift() &#123;</span><br><span class="line">        if (this.isEmpty()) return null;</span><br><span class="line">        const head &#x3D; this.head;</span><br><span class="line">        if (this.length &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">            this.head &#x3D; this.tail &#x3D; null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.head &#x3D; this.head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        this.length--;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get(index) &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt;&#x3D; this.length) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        let node &#x3D; this.head;</span><br><span class="line">        let i &#x3D; 0;</span><br><span class="line">        while(i &lt; index) &#123;</span><br><span class="line">            node &#x3D; node.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete(index) &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt;&#x3D; this.length) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index &#x3D;&#x3D;&#x3D; 0) return this.shift();</span><br><span class="line">        if (index &#x3D;&#x3D;&#x3D; this.length - 1) return this.pop();</span><br><span class="line">        let node &#x3D; this.head;</span><br><span class="line">        let last &#x3D; null;</span><br><span class="line">        let i &#x3D; 0;</span><br><span class="line">        while(i &lt; index) &#123;</span><br><span class="line">            last &#x3D; node;</span><br><span class="line">            node &#x3D; node.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        last.next &#x3D; node.next;</span><br><span class="line">        this.length--;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf() &#123;</span><br><span class="line">        if (this.length &#x3D;&#x3D;&#x3D; 0) return null;</span><br><span class="line">        let node &#x3D; this.head;</span><br><span class="line">        const list &#x3D; [];</span><br><span class="line">        while(node) &#123;</span><br><span class="line">            list.push(node.data);</span><br><span class="line">            node &#x3D; node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list.join(&#39; -&gt; &#39;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        return this.length &#x3D;&#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>大致同上，要注意 prev 的指向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    constructor(data) &#123;</span><br><span class="line">        &#x2F;&#x2F; data 包含链表项应存储的值</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">        &#x2F;&#x2F; next 是指向列表中下一项的指针</span><br><span class="line">        this.next &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; prev 是指向列表中上一项的指针</span><br><span class="line">        this.prev &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    constructor(val) &#123;</span><br><span class="line">        this.val &#x3D; val;</span><br><span class="line">        this.left &#x3D; null;</span><br><span class="line">        this.right &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BST &#123;</span><br><span class="line">    constructor(...arg) &#123;</span><br><span class="line">        this.root &#x3D; null;</span><br><span class="line">        if (arg.length) &#123;</span><br><span class="line">            arg.forEach(v &#x3D;&gt; this.insert(v))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    insert(val) &#123;</span><br><span class="line">        if (this.root &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">            this.root &#x3D; new Node(val);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            let node &#x3D; this.root;</span><br><span class="line">            while (node) &#123; &#x2F;&#x2F; 找到相应左&#x2F;右节点插入</span><br><span class="line">                if (node.val &#x3D;&#x3D;&#x3D; val) return false;</span><br><span class="line">                if (node.val &gt; val) &#123;</span><br><span class="line">                    if (!node.left) &#123;</span><br><span class="line">                        node.left &#x3D; new Node(val);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    node &#x3D; node.left;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (!node.right) &#123;</span><br><span class="line">                        node.right &#x3D; new Node(val);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    node &#x3D; node.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete(val) &#123;</span><br><span class="line">        let node &#x3D; this.root;</span><br><span class="line">        let prev &#x3D; null;</span><br><span class="line">        let type &#x3D; null; &#x2F;&#x2F; 记录前一步是左节点还是右节点</span><br><span class="line">        if (node &#x3D;&#x3D;&#x3D; null) return;</span><br><span class="line">        while (node) &#123;</span><br><span class="line">            if (node.val &#x3D;&#x3D;&#x3D; val) &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果存在左右节点，把右节点的最左子节点替换删除节点</span><br><span class="line">                if (node.left &amp;&amp; node.right) &#123;</span><br><span class="line">                    let left &#x3D; node.right;</span><br><span class="line">                    let prev &#x3D; null;</span><br><span class="line">                    while(left.left) &#123; &#x2F;&#x2F; 找到最左子节点</span><br><span class="line">                        if (left.left) &#123;</span><br><span class="line">                            prev &#x3D; left;</span><br><span class="line">                            left &#x3D; left.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    node.val &#x3D; left.val;</span><br><span class="line">                    if (prev) &#123; &#x2F;&#x2F; 最左子节点的父节点指向他的右节点</span><br><span class="line">                        prev.left &#x3D; left.right;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        node.right &#x3D; left.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123; &#x2F;&#x2F; 其中一个&#x2F;两个节点不存在</span><br><span class="line">                    if (prev) &#123; &#x2F;&#x2F; 有prev表示删除的不是根节点</span><br><span class="line">                        prev[type] &#x3D; node.left || node.right</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        this.root &#x3D; node.left || node.right</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.val &gt; val) &#123;</span><br><span class="line">                prev &#x3D; node;</span><br><span class="line">                node &#x3D; node.left;</span><br><span class="line">                type &#x3D; &#39;left&#39;;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                prev &#x3D; node;</span><br><span class="line">                node &#x3D; node.right;</span><br><span class="line">                type &#x3D; &#39;right&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    preOrder() &#123;</span><br><span class="line">        let node &#x3D; this.root;</span><br><span class="line">        const cache &#x3D; [];</span><br><span class="line">        const rst &#x3D; [];</span><br><span class="line">        while(node || cache.length) &#123;</span><br><span class="line">            if (node) &#123;</span><br><span class="line">                rst.push(node.val);</span><br><span class="line">                node.right &amp;&amp; cache.push(node);</span><br><span class="line">                node &#x3D; node.left;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                const n &#x3D; cache.pop();</span><br><span class="line">                node &#x3D; n.right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return rst.join(&#39;,&#39;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inOrder() &#123;</span><br><span class="line">        let node &#x3D; this.root;</span><br><span class="line">        const cache &#x3D; [];</span><br><span class="line">        const rst &#x3D; [];</span><br><span class="line">        while(node || cache.length) &#123;</span><br><span class="line">            if (node) &#123;</span><br><span class="line">                cache.push(node);</span><br><span class="line">                node &#x3D; node.left;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                const n &#x3D; cache.pop();</span><br><span class="line">                rst.push(n.val);</span><br><span class="line">                node &#x3D; n.right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rst.join(&#39;,&#39;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postOrder() &#123;</span><br><span class="line">        let node &#x3D; this.root;</span><br><span class="line">        const cache &#x3D; [];</span><br><span class="line">        const rst &#x3D; [];</span><br><span class="line">        while(node || cache.length) &#123;</span><br><span class="line">            if (node) &#123;</span><br><span class="line">                cache.push(node);</span><br><span class="line">                node &#x3D; node.left;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                const n &#x3D; cache.pop();</span><br><span class="line">                if (!isNaN(+n)) &#123;</span><br><span class="line">                    rst.push(n);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (n.right) &#123; &#x2F;&#x2F; 如果有右节点，就先记住他的值</span><br><span class="line">                    cache.push(n.val);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    rst.push(n.val);</span><br><span class="line">                &#125;</span><br><span class="line">                node &#x3D; n.right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rst.join(&#39;,&#39;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bfs() &#123; &#x2F;&#x2F; 层次遍历（广度优先遍历）BFS</span><br><span class="line">        if (!this.root) return;</span><br><span class="line">        const queue &#x3D; [this.root];</span><br><span class="line">        const rst &#x3D; [];</span><br><span class="line">        while(queue.length) &#123;</span><br><span class="line">            const node &#x3D; queue.shift();</span><br><span class="line">            rst.push(node.val);</span><br><span class="line">            if (node.left) &#123;</span><br><span class="line">                queue.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right) &#123;</span><br><span class="line">                queue.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rst.join(&#39;,&#39;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs() &#123; &#x2F;&#x2F; 深度优先 DFS 前序遍历</span><br><span class="line">        if (!this.root) return;</span><br><span class="line">        const stack &#x3D; [this.root];</span><br><span class="line">        const rst &#x3D; [];</span><br><span class="line">        while(stack.length) &#123;</span><br><span class="line">            const node &#x3D; stack.pop();</span><br><span class="line">            rst.push(node.val);</span><br><span class="line">            if (node.right) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.left) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rst.join(&#39;,&#39;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    depth() &#123; &#x2F;&#x2F; 最大深度</span><br><span class="line">        if (!this.root) return;</span><br><span class="line">        const queue &#x3D; [this.root];</span><br><span class="line">        const dep &#x3D; [1];</span><br><span class="line">        let max &#x3D; 1;</span><br><span class="line">        while(queue.length) &#123;</span><br><span class="line">            const node &#x3D; queue.shift();</span><br><span class="line">            const level &#x3D; dep.shift();</span><br><span class="line">            max &#x3D; Math.max(level, max);</span><br><span class="line">            if (node.left) &#123;</span><br><span class="line">                queue.push(node.left);</span><br><span class="line">                dep.push(level + 1)</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right) &#123;</span><br><span class="line">                queue.push(node.right);</span><br><span class="line">                dep.push(level + 1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const tree &#x3D; new BST(50,10,33,22,66,77,43)</span><br></pre></td></tr></table></figure>

<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Graph &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.graph &#x3D; new Map();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 基础操作方法</span><br><span class="line">    addVertex(vertex) &#123; &#x2F;&#x2F; 添加定点</span><br><span class="line">        if (this.graph.has(vertex)) return;</span><br><span class="line">        this.graph.set(vertex, []);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEdge(vertex, node) &#123;</span><br><span class="line">        const map &#x3D; this.graph.get(vertex);</span><br><span class="line">        if (map &amp;&amp; !map.includes(node)) &#123;</span><br><span class="line">            map.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print() &#123;</span><br><span class="line">        for (let [key, value] of this.graph) &#123;</span><br><span class="line">            console.log(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(startNode) &#123; &#x2F;&#x2F; 深度优先遍历</span><br><span class="line">        if (!this.graph.has(startNode)) return;</span><br><span class="line">        const rst &#x3D; [];</span><br><span class="line">        const findNode &#x3D; (vertex) &#x3D;&gt; &#123;</span><br><span class="line">            rst.push(vertex);</span><br><span class="line">            const map &#x3D; this.graph.get(vertex);</span><br><span class="line">            map.forEach(v &#x3D;&gt; &#123;</span><br><span class="line">                if (!rst.includes(v)) &#123;</span><br><span class="line">                    findNode(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        findNode(startNode)</span><br><span class="line">        console.log(rst.join(&#39;,&#39;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bfs(startNode) &#123; &#x2F;&#x2F; 广度</span><br><span class="line">        if (!this.graph.has(startNode)) return;</span><br><span class="line">        const rst &#x3D; [];</span><br><span class="line">        const queue &#x3D; [startNode];</span><br><span class="line">        while (queue.length) &#123;</span><br><span class="line">            const node &#x3D; queue.shift();</span><br><span class="line">            if (rst.includes(node)) continue;</span><br><span class="line">            rst.push(node);</span><br><span class="line">            const map &#x3D; this.graph.get(node)</span><br><span class="line">            queue.push(...map);</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(rst.join(&#39;,&#39;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    findAllPath(startNode) &#123; &#x2F;&#x2F; bfs 找到startNode起点的所有路径</span><br><span class="line">        if (!this.graph.has(startNode)) return;</span><br><span class="line">        const queue &#x3D; [startNode];</span><br><span class="line">        let path &#x3D; [];</span><br><span class="line">        const rst &#x3D; [];</span><br><span class="line">        &#x2F;&#x2F; debugger</span><br><span class="line">        while (queue.length) &#123;</span><br><span class="line">            const node &#x3D; queue.shift();</span><br><span class="line">            if (rst.includes(node)) continue;</span><br><span class="line">            rst.push(node);</span><br><span class="line">            const map &#x3D; this.graph.get(node)</span><br><span class="line">            queue.push(...map);</span><br><span class="line">            if (!path.length) &#123;</span><br><span class="line">                path.push(...map.map(v &#x3D;&gt; [startNode, v]));</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F; 遍历已有的路径，如果有下家，加上去</span><br><span class="line">                if (!map.length) continue;</span><br><span class="line">                const tail &#x3D; []</span><br><span class="line">                const rest &#x3D; []</span><br><span class="line">                path.forEach(arr &#x3D;&gt; &#123;</span><br><span class="line">                    if (arr[arr.length - 1] &#x3D;&#x3D;&#x3D; node) &#123;</span><br><span class="line">                        tail.push(arr);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        rest.push(arr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                if (!tail.length) continue;</span><br><span class="line">                map.forEach(m &#x3D;&gt; &#123;</span><br><span class="line">                    tail.forEach((t) &#x3D;&gt; &#123;</span><br><span class="line">                        rest.push(t.concat(m))</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">                path &#x3D; rest;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.forEach(arr &#x3D;&gt; console.log(arr.join(&#39; &#x3D;&gt; &#39;)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    findPath(startNode, secondNode)&#123; &#x2F;&#x2F; bfs 在上面的基础上，到secondNode就停止增加路径</span><br><span class="line">        if (!this.graph.has(startNode)) return;</span><br><span class="line">        const queue &#x3D; [startNode];</span><br><span class="line">        let path &#x3D; [];</span><br><span class="line">        const rst &#x3D; [];</span><br><span class="line">        &#x2F;&#x2F; debugger</span><br><span class="line">        while (queue.length) &#123;</span><br><span class="line">            const node &#x3D; queue.shift();</span><br><span class="line">            if (rst.includes(node)) continue;</span><br><span class="line">            rst.push(node);</span><br><span class="line">            const map &#x3D; this.graph.get(node)</span><br><span class="line">            queue.push(...map);</span><br><span class="line">            if (!path.length) &#123;</span><br><span class="line">                path.push(...map.map(v &#x3D;&gt; [startNode, v]));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (!map.length) continue;</span><br><span class="line">                const tail &#x3D; []</span><br><span class="line">                const rest &#x3D; []</span><br><span class="line">                path.forEach(arr &#x3D;&gt; &#123;</span><br><span class="line">                    const last &#x3D; arr[arr.length - 1];</span><br><span class="line">                    if (last &#x3D;&#x3D;&#x3D; node &amp;&amp; last !&#x3D;&#x3D; secondNode) &#123;</span><br><span class="line">                        tail.push(arr);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        rest.push(arr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                if (!tail.length) continue;</span><br><span class="line">                map.forEach(m &#x3D;&gt; &#123;</span><br><span class="line">                    tail.forEach((t) &#x3D;&gt; &#123;</span><br><span class="line">                        rest.push(t.concat(m))</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">                path &#x3D; rest;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.forEach(arr &#x3D;&gt; console.log(arr.join(&#39; &#x3D;&gt; &#39;)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const g &#x3D; new Graph();</span><br><span class="line">const arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;];</span><br><span class="line">for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  g.addVertex(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">g.addEdge(&#39;A&#39;, &#39;B&#39;);</span><br><span class="line">g.addEdge(&#39;A&#39;, &#39;D&#39;);</span><br><span class="line">g.addEdge(&#39;A&#39;, &#39;E&#39;);</span><br><span class="line">g.addEdge(&#39;B&#39;, &#39;C&#39;);</span><br><span class="line">g.addEdge(&#39;D&#39;, &#39;E&#39;);</span><br><span class="line">g.addEdge(&#39;E&#39;, &#39;F&#39;);</span><br><span class="line">g.addEdge(&#39;E&#39;, &#39;C&#39;);</span><br><span class="line">g.addEdge(&#39;C&#39;, &#39;F&#39;);</span><br><span class="line">g.addEdge(&#39;E&#39;, &#39;G&#39;);</span><br><span class="line">g.addEdge(&#39;G&#39;, &#39;H&#39;);</span><br><span class="line">g.addEdge(&#39;H&#39;, &#39;C&#39;);</span><br><span class="line">g.print();</span><br><span class="line">g.findPath(&#39;A&#39;, &#39;C&#39;)</span><br></pre></td></tr></table></figure>

<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class PrefixTreeNode &#123;</span><br><span class="line">    constructor(value) &#123;</span><br><span class="line">        this.children &#x3D; &#123;&#125;;</span><br><span class="line">        this.isEnd &#x3D; false; &#x2F;&#x2F; 表示到这里是一个完整的单词</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PrefixTree extends PrefixTreeNode &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 基础操作方法</span><br><span class="line">    addWord(string) &#123;</span><br><span class="line">        const addWordHelper &#x3D; (node, str) &#x3D;&gt; &#123;</span><br><span class="line">            if (!str) return;</span><br><span class="line">            const &#123;children&#125; &#x3D; node;</span><br><span class="line">            const w &#x3D; str[0];</span><br><span class="line">            if (!children[w]) &#123;</span><br><span class="line">                children[w] &#x3D; new PrefixTreeNode(w);</span><br><span class="line">            &#125;</span><br><span class="line">            if (str.length &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">                children[w].isEnd &#x3D; true;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            addWordHelper(children[w], str.slice(1));</span><br><span class="line">        &#125;;</span><br><span class="line">        addWordHelper(this, string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    predictWord(string) &#123;</span><br><span class="line">        let rst &#x3D; [];</span><br><span class="line">        &#x2F;&#x2F; debugger</span><br><span class="line">        const findWordHelper &#x3D; (node, str, string) &#x3D;&gt; &#123;</span><br><span class="line">            const &#123;children&#125; &#x3D; node;</span><br><span class="line">            if (!str) &#123;</span><br><span class="line">                if (node.isEnd) &#123;</span><br><span class="line">                    rst.push(string);</span><br><span class="line">                &#125;</span><br><span class="line">                Object.values(children).forEach(v &#x3D;&gt; &#123;</span><br><span class="line">                    findWordHelper(v, &#39;&#39;, string + v.value)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                const w &#x3D; str[0];</span><br><span class="line">                if (children[w]) &#123;</span><br><span class="line">                    findWordHelper(children[w], str.slice(1), string);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        findWordHelper(this, string, string);</span><br><span class="line"></span><br><span class="line">        return rst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logAllWords() &#123;</span><br><span class="line">        return this.predictWord(&#39;&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const tree &#x3D; new PrefixTree();</span><br><span class="line">tree.addWord(&#39;be&#39;)</span><br><span class="line">tree.addWord(&#39;ball&#39;)</span><br><span class="line">tree.addWord(&#39;bell&#39;)</span><br><span class="line">tree.addWord(&#39;bear&#39;)</span><br><span class="line">tree.addWord(&#39;tear&#39;)</span><br><span class="line">tree.addWord(&#39;bad&#39;)</span><br><span class="line">console.log(tree.predictWord(&#39;t&#39;))</span><br></pre></td></tr></table></figure>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; by 司徒正美</span><br><span class="line">class Hash &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.table &#x3D; new Array(1024);</span><br><span class="line">    &#125;</span><br><span class="line">    hash(data) &#123;</span><br><span class="line">        &#x2F;&#x2F;就将字符串中的每个字符的ASCLL码值相加起来，再对数组的长度取余</span><br><span class="line">        var total &#x3D; 0;</span><br><span class="line">        for (var i &#x3D; 0; i &lt; data.length; i++) &#123;</span><br><span class="line">            total +&#x3D; data.charCodeAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&quot;Hash Value: &quot; + data + &quot; -&gt; &quot; + total);</span><br><span class="line">        return total % this.table.length;</span><br><span class="line">    &#125;</span><br><span class="line">    insert(key, val) &#123;</span><br><span class="line">        var pos &#x3D; this.hash(key);</span><br><span class="line">        this.table[pos] &#x3D; val;</span><br><span class="line">    &#125;</span><br><span class="line">    get(key) &#123;</span><br><span class="line">        var pos &#x3D; this.hash(key);</span><br><span class="line">        return this.table[pos]</span><br><span class="line">    &#125;</span><br><span class="line">    show() &#123;</span><br><span class="line">        for (var i &#x3D; 0; i &lt; this.table.length; i++) &#123;</span><br><span class="line">            if (this.table[i] !&#x3D; undefined) &#123;</span><br><span class="line">                console.log(i + &quot;:&quot; + this.table[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var someNames &#x3D; [&quot;David&quot;, &quot;Jennifer&quot;, &quot;Donnie&quot;, &quot;Raymond&quot;, &quot;Cynthia&quot;, &quot;Mike&quot;, &quot;Clayton&quot;, &quot;Danny&quot;, &quot;Jonathan&quot;];</span><br><span class="line">var hash &#x3D; new Hash();</span><br><span class="line">for (var i &#x3D; 0; i &lt; someNames.length; ++i) &#123;</span><br><span class="line">    hash.insert(someNames[i], someNames[i]);</span><br><span class="line">&#125;</span><br><span class="line">hash.show();</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>renderRoot</title>
    <url>/my-notes/2020/09/08/react/renderRoot/</url>
    <content><![CDATA[<p>构建 fiber 树和 dom 树，互相对应为参数，能互相找到，并执行了渲染前的生命周期</p>
<h3 id="然后是renderRoot"><a href="#然后是renderRoot" class="headerlink" title="然后是renderRoot"></a>然后是<code>renderRoot</code></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">    isSync: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">SchedulerCallback</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.firstPendingTime &lt; expirationTime) &#123;</span><br><span class="line">        <span class="comment">// If there&#x27;s no work left at this expiration time, exit immediately. This</span></span><br><span class="line">        <span class="comment">// happens when multiple callbacks are scheduled for a single root, but an</span></span><br><span class="line">        <span class="comment">// earlier callback flushes the work of a later one.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在同步情况下，如果还存在待提交的处理，就先执行他</span></span><br><span class="line">    <span class="keyword">if</span> (isSync &amp;&amp; root.finishedExpirationTime === expirationTime) &#123;</span><br><span class="line">        <span class="comment">// false</span></span><br><span class="line">        <span class="comment">// There&#x27;s already a pending commit at this expiration time.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> This is poorly factored. This case only exists for the</span></span><br><span class="line">        <span class="comment">// batch.commit() API.</span></span><br><span class="line">        <span class="keyword">return</span> commitRoot.bind(<span class="literal">null</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// debugger</span></span><br><span class="line">    flushPassiveEffects(); <span class="comment">// 第一次return false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the root or expiration time have changed, throw out the existing stack</span></span><br><span class="line">    <span class="comment">// and prepare a fresh one. Otherwise we&#x27;ll continue where we left off.</span></span><br><span class="line">    <span class="keyword">if</span> (root !== workInProgressRoot || expirationTime !== renderExpirationTime) &#123;</span><br><span class="line">        <span class="comment">// 创建备份为当前执行工作（workInProgress）</span></span><br><span class="line">        <span class="comment">// 给root.current创建alternate,alternate和root.current拥有相同参数，并互相为对方的alternate</span></span><br><span class="line">        prepareFreshStack(root, expirationTime);</span><br><span class="line">        <span class="comment">// 执行后workInProgressRoot就等于root.current.alternate</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have a work-in-progress fiber, it means there&#x27;s still work to do</span></span><br><span class="line">    <span class="comment">// in this root.</span></span><br><span class="line">    <span class="keyword">if</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> prevExecutionContext = executionContext; <span class="comment">// 8 记录状态</span></span><br><span class="line">        executionContext |= RenderContext; <span class="comment">// 添加RenderContext状态</span></span><br><span class="line">        <span class="keyword">let</span> prevDispatcher = ReactCurrentDispatcher.current;</span><br><span class="line">        <span class="keyword">if</span> (prevDispatcher === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// The React isomorphic package does not include a default dispatcher.</span></span><br><span class="line">            <span class="comment">// Instead the first renderer will lazily attach one, in order to give</span></span><br><span class="line">            <span class="comment">// nicer error messages.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// ContextOnlyDispatcher错误提示对象函数</span></span><br><span class="line">            <span class="comment">// hooks报错函数对象</span></span><br><span class="line">            prevDispatcher = ContextOnlyDispatcher;</span><br><span class="line">        &#125;</span><br><span class="line">        ReactCurrentDispatcher.current = ContextOnlyDispatcher;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isSync) &#123;</span><br><span class="line">                    <span class="comment">// 进这</span></span><br><span class="line">                    workLoopSync();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    workLoop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (thrownValue) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        executionContext = prevExecutionContext;</span><br><span class="line">        resetContextDependencies(); <span class="comment">// 重置context相关</span></span><br><span class="line">        ReactCurrentDispatcher.current = prevDispatcher;</span><br><span class="line">        <span class="keyword">if</span> (enableSchedulerTracing) &#123;</span><br><span class="line">            __interactionsRef.current = ((prevInteractions: any): <span class="built_in">Set</span>&lt;Interaction&gt;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// There&#x27;s still work left over. Return a continuation.</span></span><br><span class="line">            stopInterruptedWorkLoopTimer();</span><br><span class="line">            <span class="keyword">if</span> (expirationTime !== Sync) &#123;</span><br><span class="line">                startRequestCallbackTimer();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> renderRoot.bind(<span class="literal">null</span>, root, expirationTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// debugger;</span></span><br><span class="line">    <span class="comment">// We now have a consistent tree. The next step is either to commit it, or, if</span></span><br><span class="line">    <span class="comment">// something suspended, wait to commit it after a timeout.</span></span><br><span class="line">    stopFinishedWorkLoopTimer(); <span class="comment">// __DEV__ ?</span></span><br><span class="line"></span><br><span class="line">    root.finishedWork = root.current.alternate;</span><br><span class="line">    root.finishedExpirationTime = expirationTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isLocked = resolveLocksOnRoot(root, expirationTime);</span><br><span class="line">    <span class="keyword">if</span> (isLocked) &#123;</span><br><span class="line">        <span class="comment">// This root has a lock that prevents it from committing. Exit. If we begin</span></span><br><span class="line">        <span class="comment">// work on the root again, without any intervening updates, it will finish</span></span><br><span class="line">        <span class="comment">// without doing additional work.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set this to null to indicate there&#x27;s no in-progress render.</span></span><br><span class="line">    workInProgressRoot = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (workInProgressRootExitStatus) &#123;</span><br><span class="line">        <span class="keyword">case</span> RootIncomplete: &#123;</span><br><span class="line">            invariant(<span class="literal">false</span>, <span class="string">&#x27;Should have a work-in-progress.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Flow knows about invariant, so it compains if I add a break statement,</span></span><br><span class="line">        <span class="comment">// but eslint doesn&#x27;t know about invariant, so it complains if I do.</span></span><br><span class="line">        <span class="comment">// eslint-disable-next-line no-fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> RootErrored: &#123;</span><br><span class="line">            <span class="comment">// An error was thrown. First check if there is lower priority work</span></span><br><span class="line">            <span class="comment">// scheduled on this root.</span></span><br><span class="line">            <span class="keyword">const</span> lastPendingTime = root.lastPendingTime;</span><br><span class="line">            <span class="keyword">if</span> (lastPendingTime &lt; expirationTime) &#123;</span><br><span class="line">                <span class="comment">// There&#x27;s lower priority work. Before raising the error, try rendering</span></span><br><span class="line">                <span class="comment">// at the lower priority to see if it fixes it. Use a continuation to</span></span><br><span class="line">                <span class="comment">// maintain the existing priority and position in the queue.</span></span><br><span class="line">                <span class="keyword">return</span> renderRoot.bind(<span class="literal">null</span>, root, lastPendingTime);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isSync) &#123;</span><br><span class="line">                <span class="comment">// If we&#x27;re rendering asynchronously, it&#x27;s possible the error was</span></span><br><span class="line">                <span class="comment">// caused by tearing due to a mutation during an event. Try rendering</span></span><br><span class="line">                <span class="comment">// one more time without yiedling to events.</span></span><br><span class="line">                prepareFreshStack(root, expirationTime);</span><br><span class="line">                scheduleSyncCallback(renderRoot.bind(<span class="literal">null</span>, root, expirationTime));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// If we&#x27;re already rendering synchronously, commit the root in its</span></span><br><span class="line">            <span class="comment">// errored state.</span></span><br><span class="line">            <span class="keyword">return</span> commitRoot.bind(<span class="literal">null</span>, root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> RootSuspended: &#123;</span><br><span class="line">            <span class="comment">// We have an acceptable loading state. We need to figure out if we should</span></span><br><span class="line">            <span class="comment">// immediately commit it or wait a bit.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// If we have processed new updates during this render, we may now have a</span></span><br><span class="line">            <span class="comment">// new loading state ready. We want to ensure that we commit that as soon as</span></span><br><span class="line">            <span class="comment">// possible.</span></span><br><span class="line">            <span class="keyword">const</span> hasNotProcessedNewUpdates =</span><br><span class="line">                workInProgressRootLatestProcessedExpirationTime === Sync;</span><br><span class="line">            <span class="keyword">if</span> (hasNotProcessedNewUpdates &amp;&amp; !isSync) &#123;</span><br><span class="line">                <span class="comment">// If we have not processed any new updates during this pass, then this is</span></span><br><span class="line">                <span class="comment">// either a retry of an existing fallback state or a hidden tree.</span></span><br><span class="line">                <span class="comment">// Hidden trees shouldn&#x27;t be batched with other work and after that&#x27;s</span></span><br><span class="line">                <span class="comment">// fixed it can only be a retry.</span></span><br><span class="line">                <span class="comment">// We&#x27;re going to throttle committing retries so that we don&#x27;t show too</span></span><br><span class="line">                <span class="comment">// many loading states too quickly.</span></span><br><span class="line">                <span class="keyword">let</span> msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();</span><br><span class="line">                <span class="comment">// Don&#x27;t bother with a very short suspense time.</span></span><br><span class="line">                <span class="keyword">if</span> (msUntilTimeout &gt; <span class="number">10</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (workInProgressRootHasPendingPing) &#123;</span><br><span class="line">                        <span class="comment">// This render was pinged but we didn&#x27;t get to restart earlier so try</span></span><br><span class="line">                        <span class="comment">// restarting now instead.</span></span><br><span class="line">                        prepareFreshStack(root, expirationTime);</span><br><span class="line">                        <span class="keyword">return</span> renderRoot.bind(<span class="literal">null</span>, root, expirationTime);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">const</span> lastPendingTime = root.lastPendingTime;</span><br><span class="line">                    <span class="keyword">if</span> (lastPendingTime &lt; expirationTime) &#123;</span><br><span class="line">                        <span class="comment">// There&#x27;s lower priority work. It might be unsuspended. Try rendering</span></span><br><span class="line">                        <span class="comment">// at that level.</span></span><br><span class="line">                        <span class="keyword">return</span> renderRoot.bind(<span class="literal">null</span>, root, lastPendingTime);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// The render is suspended, it hasn&#x27;t timed out, and there&#x27;s no lower</span></span><br><span class="line">                    <span class="comment">// priority work to do. Instead of committing the fallback</span></span><br><span class="line">                    <span class="comment">// immediately, wait for more data to arrive.</span></span><br><span class="line">                    root.timeoutHandle = scheduleTimeout(</span><br><span class="line">                        commitRoot.bind(<span class="literal">null</span>, root),</span><br><span class="line">                        msUntilTimeout,</span><br><span class="line">                    );</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// The work expired. Commit immediately.</span></span><br><span class="line">            <span class="keyword">return</span> commitRoot.bind(<span class="literal">null</span>, root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> RootSuspendedWithDelay: &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isSync) &#123;</span><br><span class="line">                <span class="comment">// We&#x27;re suspended in a state that should be avoided. We&#x27;ll try to avoid committing</span></span><br><span class="line">                <span class="comment">// it for as long as the timeouts let us.</span></span><br><span class="line">                <span class="keyword">if</span> (workInProgressRootHasPendingPing) &#123;</span><br><span class="line">                    <span class="comment">// This render was pinged but we didn&#x27;t get to restart earlier so try</span></span><br><span class="line">                    <span class="comment">// restarting now instead.</span></span><br><span class="line">                    prepareFreshStack(root, expirationTime);</span><br><span class="line">                    <span class="keyword">return</span> renderRoot.bind(<span class="literal">null</span>, root, expirationTime);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">const</span> lastPendingTime = root.lastPendingTime;</span><br><span class="line">                <span class="keyword">if</span> (lastPendingTime &lt; expirationTime) &#123;</span><br><span class="line">                    <span class="comment">// There&#x27;s lower priority work. It might be unsuspended. Try rendering</span></span><br><span class="line">                    <span class="comment">// at that level immediately.</span></span><br><span class="line">                    <span class="keyword">return</span> renderRoot.bind(<span class="literal">null</span>, root, lastPendingTime);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> msUntilTimeout;</span><br><span class="line">                <span class="keyword">if</span> (workInProgressRootLatestSuspenseTimeout !== Sync) &#123;</span><br><span class="line">                    <span class="comment">// We have processed a suspense config whose expiration time we can use as</span></span><br><span class="line">                    <span class="comment">// the timeout.</span></span><br><span class="line">                    msUntilTimeout =</span><br><span class="line">                        expirationTimeToMs(workInProgressRootLatestSuspenseTimeout) - now();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (workInProgressRootLatestProcessedExpirationTime === Sync) &#123;</span><br><span class="line">                    <span class="comment">// This should never normally happen because only new updates cause</span></span><br><span class="line">                    <span class="comment">// delayed states, so we should have processed something. However,</span></span><br><span class="line">                    <span class="comment">// this could also happen in an offscreen tree.</span></span><br><span class="line">                    msUntilTimeout = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// If we don&#x27;t have a suspense config, we&#x27;re going to use a heuristic to</span></span><br><span class="line">                    <span class="comment">// determine how long we can suspend.</span></span><br><span class="line">                    <span class="keyword">const</span> eventTimeMs: number = inferTimeFromExpirationTime(</span><br><span class="line">                        workInProgressRootLatestProcessedExpirationTime,</span><br><span class="line">                    );</span><br><span class="line">                    <span class="keyword">const</span> currentTimeMs = now();</span><br><span class="line">                    <span class="keyword">const</span> timeUntilExpirationMs =</span><br><span class="line">                        expirationTimeToMs(expirationTime) - currentTimeMs;</span><br><span class="line">                    <span class="keyword">let</span> timeElapsed = currentTimeMs - eventTimeMs;</span><br><span class="line">                    <span class="keyword">if</span> (timeElapsed &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// We get this wrong some time since we estimate the time.</span></span><br><span class="line">                        timeElapsed = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    msUntilTimeout = jnd(timeElapsed) - timeElapsed;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Clamp the timeout to the expiration time.</span></span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Once the event time is exact instead of inferred from expiration time</span></span><br><span class="line">                    <span class="comment">// we don&#x27;t need this.</span></span><br><span class="line">                    <span class="keyword">if</span> (timeUntilExpirationMs &lt; msUntilTimeout) &#123;</span><br><span class="line">                        msUntilTimeout = timeUntilExpirationMs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Don&#x27;t bother with a very short suspense time.</span></span><br><span class="line">                <span class="keyword">if</span> (msUntilTimeout &gt; <span class="number">10</span>) &#123;</span><br><span class="line">                    <span class="comment">// The render is suspended, it hasn&#x27;t timed out, and there&#x27;s no lower</span></span><br><span class="line">                    <span class="comment">// priority work to do. Instead of committing the fallback</span></span><br><span class="line">                    <span class="comment">// immediately, wait for more data to arrive.</span></span><br><span class="line">                    root.timeoutHandle = scheduleTimeout(</span><br><span class="line">                        commitRoot.bind(<span class="literal">null</span>, root),</span><br><span class="line">                        msUntilTimeout,</span><br><span class="line">                    );</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// The work expired. Commit immediately.</span></span><br><span class="line">            <span class="keyword">return</span> commitRoot.bind(<span class="literal">null</span>, root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> RootCompleted: &#123;</span><br><span class="line">            <span class="comment">// The work completed. Ready to commit.</span></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                !isSync &amp;&amp;</span><br><span class="line">                workInProgressRootLatestProcessedExpirationTime !== Sync &amp;&amp;</span><br><span class="line">                workInProgressRootCanSuspendUsingConfig !== <span class="literal">null</span></span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// If we have exceeded the minimum loading delay, which probably</span></span><br><span class="line">                <span class="comment">// means we have shown a spinner already, we might have to suspend</span></span><br><span class="line">                <span class="comment">// a bit longer to ensure that the spinner is shown for enough time.</span></span><br><span class="line">                <span class="keyword">const</span> msUntilTimeout = computeMsUntilSuspenseLoadingDelay(</span><br><span class="line">                    workInProgressRootLatestProcessedExpirationTime,</span><br><span class="line">                    expirationTime,</span><br><span class="line">                    workInProgressRootCanSuspendUsingConfig,</span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">if</span> (msUntilTimeout &gt; <span class="number">10</span>) &#123;</span><br><span class="line">                    root.timeoutHandle = scheduleTimeout(</span><br><span class="line">                        commitRoot.bind(<span class="literal">null</span>, root),</span><br><span class="line">                        msUntilTimeout,</span><br><span class="line">                    );</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> commitRoot.bind(<span class="literal">null</span>, root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            invariant(<span class="literal">false</span>, <span class="string">&#x27;Unknown root exit status.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="先进入workLoopSync"><a href="#先进入workLoopSync" class="headerlink" title="先进入workLoopSync"></a>先进入<code>workLoopSync</code></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopSync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// debugger;</span></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="comment">// Already timed out, so perform work without checking if we need to yield.</span></span><br><span class="line">    <span class="comment">// 构建fiber树</span></span><br><span class="line">    <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 每次都返回他的子节点生层的fiber, 给workInProgress添加child的fiber</span></span><br><span class="line">        <span class="comment">// debugger</span></span><br><span class="line">        workInProgress = performUnitOfWork(workInProgress);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// debugger;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>workInProgress</code>是 current.alternate</p>
<h3 id="performUnitOfWork"><a href="#performUnitOfWork" class="headerlink" title="performUnitOfWork"></a>performUnitOfWork</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">unitOfWork: Fiber</span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The current, flushed, state of this fiber is the alternate. Ideally</span></span><br><span class="line">    <span class="comment">// nothing should rely on this, but relying on it here means that we don&#x27;t</span></span><br><span class="line">    <span class="comment">// need an additional field on the work in progress.</span></span><br><span class="line">    <span class="keyword">const</span> current = unitOfWork.alternate; <span class="comment">// unitOfWork是备份，current是本体</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> next;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        next = beginWork(current, unitOfWork, renderExpirationTime); <span class="comment">// 返回了当前子节点的fiber</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unitOfWork.memoizedProps = unitOfWork.pendingProps; <span class="comment">// 记住props</span></span><br><span class="line">    <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有子节点了,就找兄弟节点，都没有，返回父节点的兄弟节点</span></span><br><span class="line">        <span class="comment">// If this doesn&#x27;t spawn new work, complete the current work.</span></span><br><span class="line">        next = completeUnitOfWork(unitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReactCurrentOwner.current = <span class="literal">null</span>; <span class="comment">// 重置</span></span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    current: Fiber | null, <span class="regexp">//</span> 本体 （old）</span></span></span><br><span class="line"><span class="function"><span class="params">    workInProgress: Fiber, <span class="regexp">//</span> 备份 （new）</span></span></span><br><span class="line"><span class="function"><span class="params">    renderExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> updateExpirationTime = workInProgress.expirationTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before entering the begin phase, clear the expiration time.</span></span><br><span class="line">    <span class="comment">// 清除到期时间</span></span><br><span class="line">    workInProgress.expirationTime = NoWork;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照tag的执行不同的方法</span></span><br><span class="line">    <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> IndeterminateComponent: &#123;</span><br><span class="line">            <span class="comment">// 2 function类型组件是这个tag</span></span><br><span class="line">            <span class="keyword">return</span> mountIndeterminateComponent(</span><br><span class="line">                current,</span><br><span class="line">                workInProgress,</span><br><span class="line">                workInProgress.type,</span><br><span class="line">                renderExpirationTime,</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">            <span class="comment">// 从这里开始和上一步不一样了</span></span><br><span class="line">            <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">            <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">            <span class="comment">// 是否一样，不一样则合并defaultProps属性并返回结果</span></span><br><span class="line">            <span class="keyword">const</span> resolvedProps =</span><br><span class="line">                workInProgress.elementType === Component</span><br><span class="line">                    ? unresolvedProps</span><br><span class="line">                    : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">            <span class="keyword">return</span> updateClassComponent(</span><br><span class="line">                <span class="comment">// 返回child fiber</span></span><br><span class="line">                current,</span><br><span class="line">                workInProgress,</span><br><span class="line">                Component,</span><br><span class="line">                resolvedProps,</span><br><span class="line">                renderExpirationTime,</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一次执行的这个</span></span><br><span class="line">        <span class="keyword">case</span> HostRoot: <span class="comment">// 3 根节点</span></span><br><span class="line">            <span class="keyword">return</span> updateHostRoot(current, workInProgress, renderExpirationTime);</span><br><span class="line">        <span class="keyword">case</span> HostComponent: <span class="comment">// 5 子组件的根节点(最外层节点)</span></span><br><span class="line">            <span class="keyword">return</span> updateHostComponent(current, workInProgress, renderExpirationTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="updateHostRoot"><a href="#updateHostRoot" class="headerlink" title="updateHostRoot"></a>updateHostRoot</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostRoot</span>(<span class="params">current, workInProgress, renderExpirationTime</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 把一些变量入栈了，放在了文件全局变量中,意义不明</span></span><br><span class="line">    pushHostRootContext(workInProgress);</span><br><span class="line">    <span class="comment">// 跟新队列</span></span><br><span class="line">    <span class="keyword">const</span> updateQueue = workInProgress.updateQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从变量名得知意思</span></span><br><span class="line">    <span class="keyword">const</span> nextProps = workInProgress.pendingProps;</span><br><span class="line">    <span class="keyword">const</span> prevState = workInProgress.memoizedState;</span><br><span class="line">    <span class="keyword">const</span> prevChildren = prevState !== <span class="literal">null</span> ? prevState.element : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以理解为初始化赋值一些数据，如workInProgress.memoizedState等</span></span><br><span class="line">    processUpdateQueue(workInProgress, updateQueue, nextProps, <span class="literal">null</span>, renderExpirationTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> nextState = workInProgress.memoizedState; <span class="comment">// 是一个ReactNode</span></span><br><span class="line">    <span class="comment">// Caution: React DevTools currently depends on this property</span></span><br><span class="line">    <span class="comment">// being called &quot;element&quot;.</span></span><br><span class="line">    <span class="keyword">const</span> nextChildren = nextState.element;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> root: FiberRoot = workInProgress.stateNode;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        (current === <span class="literal">null</span> || current.child === <span class="literal">null</span>) &amp;&amp;</span><br><span class="line">        root.hydrate &amp;&amp;</span><br><span class="line">        enterHydrationState(workInProgress)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Otherwise reset hydration state in case we aborted and resumed another</span></span><br><span class="line">        <span class="comment">// root.</span></span><br><span class="line">        <span class="comment">// 给workInProgress添加了child属性</span></span><br><span class="line">        reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);</span><br><span class="line">        resetHydrationState(); <span class="comment">// 重置了一些属性,目前意义未知</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里就走完了一个循环，然后看child再来一个流程</span></span><br><span class="line">    <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="processUpdateQueue"><a href="#processUpdateQueue" class="headerlink" title="processUpdateQueue"></a>processUpdateQueue</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">processUpdateQueue</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    queue: UpdateQueue&lt;State&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    props: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    instance: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    renderExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    hasForceUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆了queue(部分属性),执行后queue === workInProgress.updateQueue，好像并没有什么变化</span></span><br><span class="line">    queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These values may change as we process the queue.</span></span><br><span class="line">    <span class="keyword">let</span> newBaseState = queue.baseState;</span><br><span class="line">    <span class="keyword">let</span> newFirstUpdate = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newExpirationTime = NoWork;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate through the list of updates to compute the result.</span></span><br><span class="line">    <span class="keyword">let</span> update = queue.firstUpdate;</span><br><span class="line">    <span class="keyword">let</span> resultState = newBaseState;</span><br><span class="line">    <span class="keyword">while</span> (update !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> updateExpirationTime = update.expirationTime;</span><br><span class="line">        <span class="keyword">if</span> (updateExpirationTime &lt; renderExpirationTime) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This update does have sufficient priority.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Mark the event time of this update as relevant to this render pass.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> This should ideally use the true event time of this update rather than</span></span><br><span class="line">            <span class="comment">// its priority which is a derived and not reverseable value.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> We should skip this update if it was already committed but currently</span></span><br><span class="line">            <span class="comment">// we have no way of detecting the difference between a committed and suspended</span></span><br><span class="line">            <span class="comment">// update here.</span></span><br><span class="line">            <span class="comment">// 不知道做了什么，因为第一次初始化时大部分都是null，仅仅是一些变量的初始化处理，下面也都是这样</span></span><br><span class="line">            markRenderEventTimeAndConfig(updateExpirationTime, update.suspenseConfig);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process it and compute a new result.</span></span><br><span class="line">            <span class="comment">// 更新组件state</span></span><br><span class="line">            resultState = getStateFromUpdate(</span><br><span class="line">                workInProgress,</span><br><span class="line">                queue,</span><br><span class="line">                update,</span><br><span class="line">                resultState,</span><br><span class="line">                props,</span><br><span class="line">                instance,</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">const</span> callback = update.callback;</span><br><span class="line">            <span class="keyword">if</span> (callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">                workInProgress.effectTag |= Callback;</span><br><span class="line">                <span class="comment">// Set this to null, in case it was mutated during an aborted render.</span></span><br><span class="line">                update.nextEffect = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (queue.lastEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.firstEffect = queue.lastEffect = update;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    queue.lastEffect.nextEffect = update;</span><br><span class="line">                    queue.lastEffect = update;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Continue to the next update.</span></span><br><span class="line">        update = update.next; <span class="comment">// 下一个更新</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newFirstUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.lastUpdate = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newFirstCapturedUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.lastCapturedUpdate = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        workInProgress.effectTag |= Callback;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newFirstUpdate === <span class="literal">null</span> &amp;&amp; newFirstCapturedUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We processed every update, without skipping. That means the new base</span></span><br><span class="line">        <span class="comment">// state is the same as the result state.</span></span><br><span class="line">        newBaseState = resultState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue.baseState = newBaseState;</span><br><span class="line">    queue.firstUpdate = newFirstUpdate;</span><br><span class="line">    queue.firstCapturedUpdate = newFirstCapturedUpdate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the remaining expiration time to be whatever is remaining in the queue.</span></span><br><span class="line">    <span class="comment">// This should be fine because the only two other things that contribute to</span></span><br><span class="line">    <span class="comment">// expiration time are props and context. We&#x27;re already in the middle of the</span></span><br><span class="line">    <span class="comment">// begin phase by the time we start processing the queue, so we&#x27;ve already</span></span><br><span class="line">    <span class="comment">// dealt with the props. Context in components that specify</span></span><br><span class="line">    <span class="comment">// shouldComponentUpdate is tricky; but we&#x27;ll have to account for</span></span><br><span class="line">    <span class="comment">// that regardless.</span></span><br><span class="line">    workInProgress.expirationTime = newExpirationTime; <span class="comment">// 剩余到期时间？</span></span><br><span class="line">    workInProgress.memoizedState = resultState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="reconcileChildren-gt-reconcileChildFibers"><a href="#reconcileChildren-gt-reconcileChildFibers" class="headerlink" title="reconcileChildren -&gt; reconcileChildFibers"></a>reconcileChildren -&gt; reconcileChildFibers</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">workInProgress.child = reconcileChildFibers(</span><br><span class="line">    workInProgress,</span><br><span class="line">    current.child,</span><br><span class="line">    nextChildren,</span><br><span class="line">    renderExpirationTime,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileSingleElement</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    element: ReactElement,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> key = element.key;</span><br><span class="line">    <span class="keyword">let</span> child = currentFirstChild;</span><br><span class="line">    <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (element.type === REACT_FRAGMENT_TYPE) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// created是一个fiber</span></span><br><span class="line">        <span class="comment">// 更具element创建fiber</span></span><br><span class="line">        <span class="keyword">const</span> created = createFiberFromElement(element, returnFiber.mode, expirationTime);</span><br><span class="line">        created.ref = coerceRef(returnFiber, currentFirstChild, element); <span class="comment">// 处理ref,因为例子上没，先不看</span></span><br><span class="line">        created.return = returnFiber; <span class="comment">// 父节点</span></span><br><span class="line">        <span class="keyword">return</span> created;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">placeSingleChild</span>(<span class="params">newFiber: Fiber</span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This is simpler for the single child case. We only need to do a</span></span><br><span class="line">    <span class="comment">// placement for inserting new children.</span></span><br><span class="line">    <span class="comment">// shouldTrackSideEffects是直接传参为true（运行时）</span></span><br><span class="line">    <span class="keyword">if</span> (shouldTrackSideEffects &amp;&amp; newFiber.alternate === <span class="literal">null</span>) &#123;</span><br><span class="line">        newFiber.effectTag = Placement; <span class="comment">// 0 -&gt; 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newFiber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This API will tag the children with the side-effect of the reconciliation</span></span><br><span class="line"><span class="comment">// itself. They will be added to the side-effect list as we pass through the</span></span><br><span class="line"><span class="comment">// children and the parent.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildFibers</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChild: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function is not recursive.</span></span><br><span class="line">    <span class="comment">// If the top level item is an array, we treat it as a set of children,</span></span><br><span class="line">    <span class="comment">// not as a fragment. Nested arrays on the other hand will be treated as</span></span><br><span class="line">    <span class="comment">// fragment nodes. Recursion happens at the normal flow.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle top level unkeyed fragments as if they were arrays.</span></span><br><span class="line">    <span class="comment">// This leads to an ambiguity between &lt;&gt;&#123;[...]&#125;&lt;/&gt; and &lt;&gt;...&lt;/&gt;.</span></span><br><span class="line">    <span class="comment">// We treat the ambiguous cases above the same.</span></span><br><span class="line">    <span class="comment">// 是否fragment</span></span><br><span class="line">    <span class="keyword">const</span> isUnkeyedTopLevelFragment =</span><br><span class="line">        <span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">        newChild !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        newChild.type === REACT_FRAGMENT_TYPE &amp;&amp;</span><br><span class="line">        newChild.key === <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isUnkeyedTopLevelFragment) &#123;</span><br><span class="line">        newChild = newChild.props.children; <span class="comment">// 如果是fragment取他的子节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle object types</span></span><br><span class="line">    <span class="comment">// newChild可能是一个children</span></span><br><span class="line">    <span class="keyword">const</span> isObject = <span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (</span><br><span class="line">            newChild.$$typeof <span class="comment">// 子节点是单一的</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">                <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">                    reconcileSingleElement(</span><br><span class="line">                        returnFiber,</span><br><span class="line">                        currentFirstChild,</span><br><span class="line">                        newChild,</span><br><span class="line">                        expirationTime,</span><br><span class="line">                    ),</span><br><span class="line">                );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="updateClassComponent"><a href="#updateClassComponent" class="headerlink" title="updateClassComponent"></a>updateClassComponent</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateClassComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    Component: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextProps,</span></span></span><br><span class="line"><span class="function"><span class="params">    renderExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Push context providers early to prevent context stack mismatches.</span></span><br><span class="line">    <span class="comment">// During mounting we don&#x27;t know the child context yet as the instance doesn&#x27;t exist.</span></span><br><span class="line">    <span class="comment">// We will invalidate the child context in finishClassComponent() right after rendering.</span></span><br><span class="line">    <span class="comment">// 是否有context</span></span><br><span class="line">    <span class="keyword">let</span> hasContext;</span><br><span class="line">    <span class="keyword">if</span> (isLegacyContextProvider(Component)) &#123;</span><br><span class="line">        hasContext = <span class="literal">true</span>;</span><br><span class="line">        pushLegacyContextProvider(workInProgress);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hasContext = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// context相关,先不管</span></span><br><span class="line">    prepareToReadContext(workInProgress, renderExpirationTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line">    <span class="keyword">let</span> shouldUpdate;</span><br><span class="line">    <span class="keyword">if</span> (instance === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// An class component without an instance only mounts if it suspended</span></span><br><span class="line">            <span class="comment">// inside a non- concurrent tree, in an inconsistent state. We want to</span></span><br><span class="line">            <span class="comment">// tree it like a new mount, even though an empty version of it already</span></span><br><span class="line">            <span class="comment">// committed. Disconnect the alternate pointers.</span></span><br><span class="line">            current.alternate = <span class="literal">null</span>;</span><br><span class="line">            workInProgress.alternate = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// Since this is conceptually a new fiber, schedule a Placement effect</span></span><br><span class="line">            workInProgress.effectTag |= Placement;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// In the initial pass we might need to construct the instance.</span></span><br><span class="line">        <span class="comment">// 构造实例</span></span><br><span class="line">        constructClassInstance(workInProgress, Component, nextProps, renderExpirationTime);</span><br><span class="line">        <span class="comment">// 执行渲染前的生命周期</span></span><br><span class="line">        mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);</span><br><span class="line">        shouldUpdate = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> nextUnitOfWork = finishClassComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        shouldUpdate,</span><br><span class="line">        hasContext,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nextUnitOfWork;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="constructClassInstance"><a href="#constructClassInstance" class="headerlink" title="constructClassInstance"></a>constructClassInstance</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructClassInstance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    ctor: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    props: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    renderExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> isLegacyContextConsumer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> unmaskedContext = emptyContextObject;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> contextType = ctor.contextType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这 前景：从root -&gt; LocaleProvider,一层层下去</span></span><br><span class="line">    <span class="comment">// debugger</span></span><br><span class="line">    <span class="comment">// 获取context ? context相关，先不看</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> contextType === <span class="string">&#x27;object&#x27;</span> &amp;&amp; contextType !== <span class="literal">null</span>) &#123;</span><br><span class="line">        context = readContext((contextType: any));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        unmaskedContext = getUnmaskedContext(workInProgress, ctor, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">const</span> contextTypes = ctor.contextTypes;</span><br><span class="line">        isLegacyContextConsumer = contextTypes !== <span class="literal">null</span> &amp;&amp; contextTypes !== <span class="literal">undefined</span>;</span><br><span class="line">        context = isLegacyContextConsumer</span><br><span class="line">            ? getMaskedContext(workInProgress, unmaskedContext)</span><br><span class="line">            : emptyContextObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new 当前组件（class）,获得实例</span></span><br><span class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> ctor(props, context);</span><br><span class="line">    <span class="keyword">const</span> state = (workInProgress.memoizedState =</span><br><span class="line">        instance.state !== <span class="literal">null</span> &amp;&amp; instance.state !== <span class="literal">undefined</span> ? instance.state : <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// workInProgress和instance互相添加为属性，stateNode和_reactInternalFiber，能够让双方互相找到</span></span><br><span class="line">    <span class="comment">// 更新了instance的updater方法（直接被替换了一个新的）</span></span><br><span class="line">    adoptClassInstance(workInProgress, instance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache unmasked context so we can avoid recreating masked context unless necessary.</span></span><br><span class="line">    <span class="comment">// ReactFiberContext usually updates this cache but can&#x27;t for newly-created instances.</span></span><br><span class="line">    <span class="comment">// 在contextType有数据时是true</span></span><br><span class="line">    <span class="keyword">if</span> (isLegacyContextConsumer) &#123;</span><br><span class="line">        cacheContext(workInProgress, unmaskedContext, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mountClassInstance"><a href="#mountClassInstance" class="headerlink" title="mountClassInstance"></a>mountClassInstance</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Invokes the mount life-cycles on a previously never rendered instance.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountClassInstance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    ctor: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    newProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    renderExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 更新state等数据</span></span><br><span class="line">    <span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line">    instance.props = newProps;</span><br><span class="line">    instance.state = workInProgress.memoizedState;</span><br><span class="line">    instance.refs = emptyRefsObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> contextType = ctor.contextType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// context</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> contextType === <span class="string">&#x27;object&#x27;</span> &amp;&amp; contextType !== <span class="literal">null</span>) &#123;</span><br><span class="line">        instance.context = readContext(contextType);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> unmaskedContext = getUnmaskedContext(workInProgress, ctor, <span class="literal">true</span>);</span><br><span class="line">        instance.context = getMaskedContext(workInProgress, unmaskedContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> updateQueue = workInProgress.updateQueue;</span><br><span class="line">    <span class="keyword">if</span> (updateQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">        processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);</span><br><span class="line">        instance.state = workInProgress.memoizedState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理getDerivedStateFromProps，第一个看到的生命周期处理</span></span><br><span class="line">    <span class="comment">// getDerivedStateFromProps 有返回值，做Object.assign处理，否则返回原state</span></span><br><span class="line">    <span class="comment">// workInProgress.memoizedState被更新了</span></span><br><span class="line">    <span class="comment">// 现在还处于渲染前</span></span><br><span class="line">    <span class="keyword">const</span> getDerivedStateFromProps = ctor.getDerivedStateFromProps;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> getDerivedStateFromProps === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);</span><br><span class="line">        instance.state = workInProgress.memoizedState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In order to support react-lifecycles-compat polyfilled components,</span></span><br><span class="line">    <span class="comment">// Unsafe lifecycles should not be invoked for components using the new APIs.</span></span><br><span class="line">    <span class="comment">// 如果使用了新的生命周期函数，就不调用老的不安全的生命周期函数componentWillMount</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        <span class="keyword">typeof</span> ctor.getDerivedStateFromProps !== <span class="string">&#x27;function&#x27;</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> instance.getSnapshotBeforeUpdate !== <span class="string">&#x27;function&#x27;</span> &amp;&amp;</span><br><span class="line">        (<span class="keyword">typeof</span> instance.UNSAFE_componentWillMount === <span class="string">&#x27;function&#x27;</span> ||</span><br><span class="line">            <span class="keyword">typeof</span> instance.componentWillMount === <span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// 调用componentWillMount、UNSAFE_componentWillMount</span></span><br><span class="line">        callComponentWillMount(workInProgress, instance);</span><br><span class="line">        <span class="comment">// If we had additional state updates during this life-cycle, let&#x27;s</span></span><br><span class="line">        <span class="comment">// process them now.</span></span><br><span class="line">        updateQueue = workInProgress.updateQueue;</span><br><span class="line">        <span class="keyword">if</span> (updateQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">            processUpdateQueue(</span><br><span class="line">                workInProgress,</span><br><span class="line">                updateQueue,</span><br><span class="line">                newProps,</span><br><span class="line">                instance,</span><br><span class="line">                renderExpirationTime,</span><br><span class="line">            );</span><br><span class="line">            instance.state = workInProgress.memoizedState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.componentDidMount === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        workInProgress.effectTag |= Update; <span class="comment">// effectTag添加Update</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="finishClassComponent"><a href="#finishClassComponent" class="headerlink" title="finishClassComponent"></a>finishClassComponent</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishClassComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    Component: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    shouldUpdate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">    hasContext: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">    renderExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Refs should update even if shouldComponentUpdate returns false</span></span><br><span class="line">    <span class="comment">// 标记ref,表示workInProgress上存在ref属性，通过effectTag</span></span><br><span class="line">    <span class="comment">// debugger</span></span><br><span class="line">    markRef(current, workInProgress);</span><br><span class="line">    <span class="comment">//  是否包含DidCapture标记</span></span><br><span class="line">    <span class="keyword">const</span> didCaptureError = (workInProgress.effectTag &amp; DidCapture) !== NoEffect;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!shouldUpdate &amp;&amp; !didCaptureError) &#123;</span><br><span class="line">        <span class="comment">// Context providers should defer to sCU for rendering</span></span><br><span class="line">        <span class="keyword">if</span> (hasContext) &#123;</span><br><span class="line">            invalidateContextProvider(workInProgress, Component, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rerender</span></span><br><span class="line">    ReactCurrentOwner.current = workInProgress;</span><br><span class="line">    <span class="keyword">let</span> nextChildren;</span><br><span class="line">    <span class="comment">// 包含DidCapture标记 &amp;&amp; getDerivedStateFromError不是函数</span></span><br><span class="line">    <span class="keyword">if</span> (didCaptureError &amp;&amp; <span class="keyword">typeof</span> Component.getDerivedStateFromError !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// If we captured an error, but getDerivedStateFrom catch is not defined,</span></span><br><span class="line">        <span class="comment">// unmount all the children. componentDidCatch will schedule an update to</span></span><br><span class="line">        <span class="comment">// re-render a fallback. This is temporary until we migrate everyone to</span></span><br><span class="line">        <span class="comment">// the new API.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Warn in a future release.</span></span><br><span class="line">        nextChildren = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enableProfilerTimer) &#123;</span><br><span class="line">            stopProfilerTimerIfRunning(workInProgress);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 正常渲染</span></span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// debugger</span></span><br><span class="line">            <span class="comment">// 执行render, 即React.createElement</span></span><br><span class="line">            <span class="comment">// 把es6模板转成React.createElement应该是loader完成的,具体怎么转的就先不管了</span></span><br><span class="line">            <span class="comment">// 见createElement.md</span></span><br><span class="line">            nextChildren = instance.render();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// React DevTools reads this flag.</span></span><br><span class="line">    <span class="comment">// React DevTools需要</span></span><br><span class="line">    workInProgress.effectTag |= PerformedWork;</span><br><span class="line">    <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; didCaptureError) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 和reconcileChildFibers代码一样，唯一区别是调用时shouldTrackSideEffects为false</span></span><br><span class="line">        reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Memoize state using the values we just used to render.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Restructure so we never read values from the instance.</span></span><br><span class="line">    <span class="comment">// 记住state, 这个是preState?</span></span><br><span class="line">    workInProgress.memoizedState = instance.state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The context might have changed so we need to recalculate it.</span></span><br><span class="line">    <span class="keyword">if</span> (hasContext) &#123;</span><br><span class="line">        invalidateContextProvider(workInProgress, Component, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="reconcileChildFibers-和-mountChildFibers"><a href="#reconcileChildFibers-和-mountChildFibers" class="headerlink" title="reconcileChildFibers 和 mountChildFibers"></a>reconcileChildFibers 和 mountChildFibers</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reconcileChildFibers = ChildReconciler(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mountChildFibers = ChildReconciler(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextChildren: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    renderExpirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If this is a fresh new component that hasn&#x27;t been rendered yet, we</span></span><br><span class="line">        <span class="comment">// won&#x27;t update its child set by applying minimal side-effects. Instead,</span></span><br><span class="line">        <span class="comment">// we will add them all to the child before it gets rendered. That means</span></span><br><span class="line">        <span class="comment">// we can optimize this reconciliation pass by not tracking side-effects.</span></span><br><span class="line">        workInProgress.child = mountChildFibers(</span><br><span class="line">            workInProgress,</span><br><span class="line">            <span class="literal">null</span>,</span><br><span class="line">            nextChildren,</span><br><span class="line">            renderExpirationTime,</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If the current child is the same as the work in progress, it means that</span></span><br><span class="line">        <span class="comment">// we haven&#x27;t yet started any work on these children. Therefore, we use</span></span><br><span class="line">        <span class="comment">// the clone algorithm to create a copy of all the current children.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we had any progressed work already, that is invalid at this point so</span></span><br><span class="line">        <span class="comment">// let&#x27;s throw it out.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把子节点转换成一个fiber</span></span><br><span class="line">        <span class="comment">// debugger;</span></span><br><span class="line">        workInProgress.child = reconcileChildFibers(</span><br><span class="line">            workInProgress,</span><br><span class="line">            current.child,</span><br><span class="line">            nextChildren,</span><br><span class="line">            renderExpirationTime,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="updateHostComponent"><a href="#updateHostComponent" class="headerlink" title="updateHostComponent"></a>updateHostComponent</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">current, workInProgress, renderExpirationTime</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// debugger</span></span><br><span class="line">    pushHostContext(workInProgress);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">        tryToClaimNextHydratableInstance(workInProgress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> type = workInProgress.type;</span><br><span class="line">    <span class="keyword">const</span> nextProps = workInProgress.pendingProps;</span><br><span class="line">    <span class="keyword">const</span> prevProps = current !== <span class="literal">null</span> ? current.memoizedProps : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> nextChildren = nextProps.children;</span><br><span class="line">    <span class="keyword">const</span> isDirectTextChild = shouldSetTextContent(type, nextProps); <span class="comment">// 子节点是文本节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDirectTextChild) &#123;</span><br><span class="line">        <span class="comment">// 如果是文本节点</span></span><br><span class="line">        <span class="comment">// We special case a direct text child of a host node. This is a common</span></span><br><span class="line">        <span class="comment">// case. We won&#x27;t handle it as a reified child. We will instead handle</span></span><br><span class="line">        <span class="comment">// this in the host environment that also have access to this prop. That</span></span><br><span class="line">        <span class="comment">// avoids allocating another HostText fiber and traversing it.</span></span><br><span class="line">        nextChildren = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevProps !== <span class="literal">null</span> &amp;&amp; shouldSetTextContent(type, prevProps)) &#123;</span><br><span class="line">        <span class="comment">// If we&#x27;re switching from a direct text child to a normal child, or to</span></span><br><span class="line">        <span class="comment">// empty, we need to schedule the text content to be reset.</span></span><br><span class="line">        workInProgress.effectTag |= ContentReset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    markRef(current, workInProgress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check the host config to see if the children are offscreen/hidden.</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        workInProgress.mode &amp; ConcurrentMode &amp;&amp;</span><br><span class="line">        renderExpirationTime !== Never &amp;&amp;</span><br><span class="line">        shouldDeprioritizeSubtree(type, nextProps)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);</span><br><span class="line">    <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="reconcileChildFibers（详细）"><a href="#reconcileChildFibers（详细）" class="headerlink" title="reconcileChildFibers（详细）"></a>reconcileChildFibers（详细）</h3><p>见 reconcileChildFibers.md</p>
<h3 id="completeUnitOfWork"><a href="#completeUnitOfWork" class="headerlink" title="completeUnitOfWork"></a>completeUnitOfWork</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeUnitOfWork</span>(<span class="params">unitOfWork: Fiber</span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Attempt to complete the current unit of work, then move to the next</span></span><br><span class="line">    <span class="comment">// sibling. If there are no more siblings, return to the parent fiber.</span></span><br><span class="line">    <span class="comment">// 翻译：结束当前的工作单元，然后移动到下一个兄弟。如果没有，返回父fiber</span></span><br><span class="line">    workInProgress = unitOfWork;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// The current, flushed, state of this fiber is the alternate. Ideally</span></span><br><span class="line">        <span class="comment">// nothing should rely on this, but relying on it here means that we don&#x27;t</span></span><br><span class="line">        <span class="comment">// need an additional field on the work in progress.</span></span><br><span class="line">        <span class="keyword">const</span> current = workInProgress.alternate;</span><br><span class="line">        <span class="keyword">const</span> returnFiber = workInProgress.return;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if the work completed or if something threw.</span></span><br><span class="line">        <span class="keyword">if</span> ((workInProgress.effectTag &amp; Incomplete) === NoEffect) &#123;</span><br><span class="line">            <span class="keyword">let</span> next;</span><br><span class="line">            <span class="keyword">if</span> (!enableProfilerTimer || (workInProgress.mode &amp; ProfileMode) === NoMode) &#123;</span><br><span class="line">                next = completeWork(current, workInProgress, renderExpirationTime);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                startProfilerTimer(workInProgress);</span><br><span class="line">                next = completeWork(current, workInProgress, renderExpirationTime);</span><br><span class="line">                <span class="comment">// Update render duration assuming we didn&#x27;t error.</span></span><br><span class="line">                stopProfilerTimerIfRunningAndRecordDelta(workInProgress, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            resetChildExpirationTime(workInProgress); <span class="comment">// 重置时间</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (next !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Completing this fiber spawned new work. Work on that next.</span></span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                returnFiber !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                <span class="comment">// Do not append effects to parents if a sibling failed to complete</span></span><br><span class="line">                (returnFiber.effectTag &amp; Incomplete) === NoEffect</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// Append all the effects of the subtree and this fiber onto the effect</span></span><br><span class="line">                <span class="comment">// list of the parent. The completion order of the children affects the</span></span><br><span class="line">                <span class="comment">// side-effect order.</span></span><br><span class="line">                <span class="keyword">if</span> (returnFiber.firstEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">                    returnFiber.firstEffect = workInProgress.firstEffect;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (workInProgress.lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (returnFiber.lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">                        returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;</span><br><span class="line">                    &#125;</span><br><span class="line">                    returnFiber.lastEffect = workInProgress.lastEffect;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If this fiber had side-effects, we append it AFTER the children&#x27;s</span></span><br><span class="line">                <span class="comment">// side-effects. We can perform certain side-effects earlier if needed,</span></span><br><span class="line">                <span class="comment">// by doing multiple passes over the effect list. We don&#x27;t want to</span></span><br><span class="line">                <span class="comment">// schedule our own side-effect on our own list because if end up</span></span><br><span class="line">                <span class="comment">// reusing children we&#x27;ll schedule this effect onto itself since we&#x27;re</span></span><br><span class="line">                <span class="comment">// at the end.</span></span><br><span class="line">                <span class="keyword">const</span> effectTag = workInProgress.effectTag;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Skip both NoWork and PerformedWork tags when creating the effect</span></span><br><span class="line">                <span class="comment">// list. PerformedWork effect is read by React DevTools but shouldn&#x27;t be</span></span><br><span class="line">                <span class="comment">// committed.</span></span><br><span class="line">                <span class="comment">// debugger</span></span><br><span class="line">                <span class="comment">// effect添加，</span></span><br><span class="line">                <span class="keyword">if</span> (effectTag &gt; PerformedWork) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (returnFiber.lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">                        returnFiber.lastEffect.nextEffect = workInProgress;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        returnFiber.firstEffect = workInProgress;</span><br><span class="line">                    &#125;</span><br><span class="line">                    returnFiber.lastEffect = workInProgress;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This fiber did not complete because something threw. Pop values off</span></span><br><span class="line">            <span class="comment">// the stack without entering the complete phase. If this is a boundary,</span></span><br><span class="line">            <span class="comment">// capture values if possible.</span></span><br><span class="line">            <span class="keyword">const</span> next = unwindWork(workInProgress, renderExpirationTime);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Because this fiber did not complete, don&#x27;t reset its expiration time.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; (workInProgress.mode &amp; ProfileMode) !== NoMode) &#123;</span><br><span class="line">                <span class="comment">// Record the render duration for the fiber that errored.</span></span><br><span class="line">                stopProfilerTimerIfRunningAndRecordDelta(workInProgress, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Include the time spent working on failed children before continuing.</span></span><br><span class="line">                <span class="keyword">let</span> actualDuration = workInProgress.actualDuration;</span><br><span class="line">                <span class="keyword">let</span> child = workInProgress.child;</span><br><span class="line">                <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    actualDuration += child.actualDuration;</span><br><span class="line">                    child = child.sibling;</span><br><span class="line">                &#125;</span><br><span class="line">                workInProgress.actualDuration = actualDuration;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (next !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If completing this work spawned new work, do that next. We&#x27;ll come</span></span><br><span class="line">                <span class="comment">// back here again.</span></span><br><span class="line">                <span class="comment">// Since we&#x27;re restarting, remove anything that is not a host effect</span></span><br><span class="line">                <span class="comment">// from the effect tag.</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> The name stopFailedWorkTimer is misleading because Suspense</span></span><br><span class="line">                <span class="comment">// also captures and restarts.</span></span><br><span class="line">                stopFailedWorkTimer(workInProgress);</span><br><span class="line">                next.effectTag &amp;= HostEffectMask;</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">            &#125;</span><br><span class="line">            stopWorkTimer(workInProgress);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (returnFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Mark the parent fiber as incomplete and clear its effect list.</span></span><br><span class="line">                returnFiber.firstEffect = returnFiber.lastEffect = <span class="literal">null</span>;</span><br><span class="line">                returnFiber.effectTag |= Incomplete;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> siblingFiber = workInProgress.sibling; <span class="comment">// 返回相邻节点</span></span><br><span class="line">        <span class="keyword">if</span> (siblingFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If there is more work to do in this returnFiber, do that next.</span></span><br><span class="line">            <span class="keyword">return</span> siblingFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Otherwise, return to the parent 没有就从父节点中找相邻节点</span></span><br><span class="line">        workInProgress = returnFiber;</span><br><span class="line">    &#125; <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We&#x27;ve reached the root.</span></span><br><span class="line">    <span class="keyword">if</span> (workInProgressRootExitStatus === RootIncomplete) &#123;</span><br><span class="line">        workInProgressRootExitStatus = RootCompleted;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>事件系统</title>
    <url>/my-notes/2020/09/10/react/%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>上接<code>completeWork.md</code> 搜索 <code>setInitialDOMProperties</code></p>
<h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><h3 id="setInitialDOMProperties"><a href="#setInitialDOMProperties" class="headerlink" title="setInitialDOMProperties"></a>setInitialDOMProperties</h3><p>给 dom 设置属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInitialDOMProperties</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    tag: string,</span></span></span><br><span class="line"><span class="function"><span class="params">    domElement: Element,</span></span></span><br><span class="line"><span class="function"><span class="params">    rootContainerElement: Element | Document,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextProps: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">    isCustomComponentTag: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> propKey <span class="keyword">in</span> nextProps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nextProps.hasOwnProperty(propKey)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> nextProp = nextProps[propKey];</span><br><span class="line">        <span class="keyword">if</span> (propKey === STYLE) &#123;</span><br><span class="line">            <span class="comment">// style</span></span><br><span class="line">            <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nextProp) &#123;</span><br><span class="line">                    <span class="comment">// Freeze the next style object so that we can assume it won&#x27;t be</span></span><br><span class="line">                    <span class="comment">// mutated. We have already warned for this in the past.</span></span><br><span class="line">                    <span class="built_in">Object</span>.freeze(nextProp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Relies on `updateStylesByID` not mutating `styleUpdates`.</span></span><br><span class="line">            setValueForStyles(domElement, nextProp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === DANGEROUSLY_SET_INNER_HTML) &#123;</span><br><span class="line">            <span class="comment">// dangerouslySetInnerHTML</span></span><br><span class="line">            <span class="keyword">const</span> nextHtml = nextProp ? nextProp[HTML] : <span class="literal">undefined</span>;</span><br><span class="line">            <span class="keyword">if</span> (nextHtml != <span class="literal">null</span>) &#123;</span><br><span class="line">                setInnerHTML(domElement, nextHtml);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === CHILDREN) &#123;</span><br><span class="line">            <span class="comment">// children</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> nextProp === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// Avoid setting initial textContent when the text is empty. In IE11 setting</span></span><br><span class="line">                <span class="comment">// textContent on a &lt;textarea&gt; will cause the placeholder to not</span></span><br><span class="line">                <span class="comment">// show within the &lt;textarea&gt; until it has been focused and blurred again.</span></span><br><span class="line">                <span class="comment">// https://github.com/facebook/react/issues/6731#issuecomment-254874553</span></span><br><span class="line">                <span class="keyword">const</span> canSetTextContent = tag !== <span class="string">&#x27;textarea&#x27;</span> || nextProp !== <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (canSetTextContent) &#123;</span><br><span class="line">                    setTextContent(domElement, nextProp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> nextProp === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">                setTextContent(domElement, <span class="string">&#x27;&#x27;</span> + nextProp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">            propKey === SUPPRESS_CONTENT_EDITABLE_WARNING ||</span><br><span class="line">            propKey === SUPPRESS_HYDRATION_WARNING</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// Noop</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === AUTOFOCUS) &#123;</span><br><span class="line">            <span class="comment">// We polyfill it separately on the client during commit.</span></span><br><span class="line">            <span class="comment">// We could have excluded it in the property list instead of</span></span><br><span class="line">            <span class="comment">// adding a special case here, but then it wouldn&#x27;t be emitted</span></span><br><span class="line">            <span class="comment">// on server rendering (but we *do* want to emit it in SSR).</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (registrationNameModules.hasOwnProperty(propKey)) &#123;</span><br><span class="line">            <span class="comment">// registrationNameModules包含了所有支持的事件名，如onClick、onChange等</span></span><br><span class="line">            <span class="comment">// 判断是否存在事件绑定</span></span><br><span class="line">            <span class="keyword">if</span> (nextProp != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (__DEV__ &amp;&amp; <span class="keyword">typeof</span> nextProp !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                    warnForInvalidEventListener(propKey, nextProp);</span><br><span class="line">                &#125;</span><br><span class="line">                ensureListeningTo(rootContainerElement, propKey); <span class="comment">// 事件绑定</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextProp != <span class="literal">null</span>) &#123;</span><br><span class="line">            setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ensureListeningTo"><a href="#ensureListeningTo" class="headerlink" title="ensureListeningTo"></a>ensureListeningTo</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureListeningTo</span>(<span class="params">rootContainerElement: Element | Node, registrationName: string</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="comment">// debugger</span></span><br><span class="line">    <span class="comment">// DOCUMENT的type，顾名思义</span></span><br><span class="line">    <span class="keyword">const</span> isDocumentOrFragment =</span><br><span class="line">        rootContainerElement.nodeType === DOCUMENT_NODE ||</span><br><span class="line">        rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;</span><br><span class="line">    <span class="comment">// doc就是document</span></span><br><span class="line">    <span class="keyword">const</span> doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;</span><br><span class="line">    listenTo(registrationName, doc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listenTo"><a href="#listenTo" class="headerlink" title="listenTo"></a>listenTo</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * We listen for bubbled touch events on the document object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Firefox v8.01 (and possibly others) exhibited strange behavior when</span></span><br><span class="line"><span class="comment"> * mounting `onmousemove` events at some node that was not the document</span></span><br><span class="line"><span class="comment"> * element. The symptoms were that if your mouse is not moving over something</span></span><br><span class="line"><span class="comment"> * contained within that mount point (for example on the background) the</span></span><br><span class="line"><span class="comment"> * top-level listeners for `onmousemove` won&#x27;t be called. However, if you</span></span><br><span class="line"><span class="comment"> * register the `mousemove` on the document object, then it will of course</span></span><br><span class="line"><span class="comment"> * catch all `mousemove`s. This along with iOS quirks, justifies restricting</span></span><br><span class="line"><span class="comment"> * top-level listeners to the document object only, at least for these</span></span><br><span class="line"><span class="comment"> * movement types of events and possibly all events.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see </span>http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but</span></span><br><span class="line"><span class="comment"> * they bubble to document.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>registrationName Name of listener (e.g. `onClick`).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;object&#125;</span> </span>mountAt Container where to mount the listener</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">listenTo</span>(<span class="params">registrationName: string, mountAt: Document | Element | Node</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> listeningSet = getListeningSetForElement(mountAt);</span><br><span class="line">    <span class="comment">// 获取事件依赖事件，有些事件可能会被多个事件触发，所以要给这些事件也监听</span></span><br><span class="line">    <span class="comment">// 如onChange会被blur、input等等其他事件触发</span></span><br><span class="line">    <span class="keyword">const</span> dependencies = registrationNameDependencies[registrationName];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dependencies.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> dependency = dependencies[i];</span><br><span class="line">        <span class="comment">// 过滤已存在的相同事件</span></span><br><span class="line">        <span class="keyword">if</span> (!listeningSet.has(dependency)) &#123;</span><br><span class="line">            <span class="comment">// 把TOP_去掉在取小写就是他们的值</span></span><br><span class="line">            <span class="keyword">switch</span> (dependency) &#123;</span><br><span class="line">                <span class="keyword">case</span> TOP_SCROLL:</span><br><span class="line">                    trapCapturedEvent(TOP_SCROLL, mountAt);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TOP_FOCUS:</span><br><span class="line">                <span class="keyword">case</span> TOP_BLUR:</span><br><span class="line">                    trapCapturedEvent(TOP_FOCUS, mountAt);</span><br><span class="line">                    trapCapturedEvent(TOP_BLUR, mountAt);</span><br><span class="line">                    <span class="comment">// We set the flag for a single dependency later in this function,</span></span><br><span class="line">                    <span class="comment">// but this ensures we mark both as attached rather than just one.</span></span><br><span class="line">                    listeningSet.add(TOP_BLUR);</span><br><span class="line">                    listeningSet.add(TOP_FOCUS);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TOP_CANCEL:</span><br><span class="line">                <span class="keyword">case</span> TOP_CLOSE:</span><br><span class="line">                    <span class="keyword">if</span> (isEventSupported(getRawEventName(dependency))) &#123;</span><br><span class="line">                        trapCapturedEvent(dependency, mountAt);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TOP_INVALID:</span><br><span class="line">                <span class="keyword">case</span> TOP_SUBMIT:</span><br><span class="line">                <span class="keyword">case</span> TOP_RESET:</span><br><span class="line">                    <span class="comment">// We listen to them on the target DOM elements.</span></span><br><span class="line">                    <span class="comment">// Some of them bubble so we don&#x27;t want them to fire twice.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">// By default, listen on the top level to all non-media events.</span></span><br><span class="line">                    <span class="comment">// Media events don&#x27;t bubble so adding the listener wouldn&#x27;t do anything.</span></span><br><span class="line">                    <span class="comment">// 媒体事件不冒泡</span></span><br><span class="line">                    <span class="keyword">const</span> isMediaEvent = mediaEventTypes.indexOf(dependency) !== <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!isMediaEvent) &#123;</span><br><span class="line">                        trapBubbledEvent(dependency, mountAt); <span class="comment">// 添加冒泡事件</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            listeningSet.add(dependency);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getListeningSetForElement"><a href="#getListeningSetForElement" class="headerlink" title="getListeningSetForElement"></a>getListeningSetForElement</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Summary of `ReactBrowserEventEmitter` event handling:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - Top-level delegation is used to trap most native browser events. This</span></span><br><span class="line"><span class="comment"> *    may only occur in the main thread and is the responsibility of</span></span><br><span class="line"><span class="comment"> *    ReactDOMEventListener, which is injected and can therefore support</span></span><br><span class="line"><span class="comment"> *    pluggable event sources. This is the only work that occurs in the main</span></span><br><span class="line"><span class="comment"> *    thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - We normalize and de-duplicate events to account for browser quirks. This</span></span><br><span class="line"><span class="comment"> *    may be done in the worker thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - Forward these native events (with the associated top-level type used to</span></span><br><span class="line"><span class="comment"> *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want</span></span><br><span class="line"><span class="comment"> *    to extract any synthetic events.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - The `EventPluginHub` will then process each event by annotating them with</span></span><br><span class="line"><span class="comment"> *    &quot;dispatches&quot;, a sequence of listeners and IDs that care about that event.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - The `EventPluginHub` then dispatches the events.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Overview of React and the event system:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * +------------+    .</span></span><br><span class="line"><span class="comment"> * |    DOM     |    .</span></span><br><span class="line"><span class="comment"> * +------------+    .</span></span><br><span class="line"><span class="comment"> *       |           .</span></span><br><span class="line"><span class="comment"> *       v           .</span></span><br><span class="line"><span class="comment"> * +------------+    .</span></span><br><span class="line"><span class="comment"> * | ReactEvent |    .</span></span><br><span class="line"><span class="comment"> * |  Listener  |    .</span></span><br><span class="line"><span class="comment"> * +------------+    .                         +-----------+</span></span><br><span class="line"><span class="comment"> *       |           .               +--------+|SimpleEvent|</span></span><br><span class="line"><span class="comment"> *       |           .               |         |Plugin     |</span></span><br><span class="line"><span class="comment"> * +-----|------+    .               v         +-----------+</span></span><br><span class="line"><span class="comment"> * |     |      |    .    +--------------+                    +------------+</span></span><br><span class="line"><span class="comment"> * |     +-----------.---&gt;|EventPluginHub|                    |    Event   |</span></span><br><span class="line"><span class="comment"> * |            |    .    |              |     +-----------+  | Propagators|</span></span><br><span class="line"><span class="comment"> * | ReactEvent |    .    |              |     |TapEvent   |  |------------|</span></span><br><span class="line"><span class="comment"> * |  Emitter   |    .    |              |&lt;---+|Plugin     |  |other plugin|</span></span><br><span class="line"><span class="comment"> * |            |    .    |              |     +-----------+  |  utilities |</span></span><br><span class="line"><span class="comment"> * |     +-----------.---&gt;|              |                    +------------+</span></span><br><span class="line"><span class="comment"> * |     |      |    .    +--------------+</span></span><br><span class="line"><span class="comment"> * +-----|------+    .                ^        +-----------+</span></span><br><span class="line"><span class="comment"> *       |           .                |        |Enter/Leave|</span></span><br><span class="line"><span class="comment"> *       +           .                +-------+|Plugin     |</span></span><br><span class="line"><span class="comment"> * +-------------+   .                         +-----------+</span></span><br><span class="line"><span class="comment"> * | application |   .</span></span><br><span class="line"><span class="comment"> * |-------------|   .</span></span><br><span class="line"><span class="comment"> * |             |   .</span></span><br><span class="line"><span class="comment"> * |             |   .</span></span><br><span class="line"><span class="comment"> * +-------------+   .</span></span><br><span class="line"><span class="comment"> *                   .</span></span><br><span class="line"><span class="comment"> *    React Core     .  General Purpose Event Plugin System</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PossiblyWeakMap = <span class="keyword">typeof</span> <span class="built_in">WeakMap</span> === <span class="string">&#x27;function&#x27;</span> ? <span class="built_in">WeakMap</span> : <span class="built_in">Map</span>;</span><br><span class="line"><span class="keyword">const</span> elementListeningSets:</span><br><span class="line">    | <span class="built_in">WeakMap</span></span><br><span class="line">    | <span class="built_in">Map</span>&lt;Document | Element | Node, <span class="built_in">Set</span>&lt;DOMTopLevelEventType | string&gt;&gt; = <span class="keyword">new</span> PossiblyWeakMap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getListeningSetForElement</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    element: Document | Element | Node,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Set</span>&lt;<span class="title">DOMTopLevelEventType</span> | <span class="title">string</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> listeningSet = elementListeningSets.get(element);</span><br><span class="line">    <span class="keyword">if</span> (listeningSet === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        listeningSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        elementListeningSets.set(element, listeningSet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listeningSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="trapBubbledEvent"><a href="#trapBubbledEvent" class="headerlink" title="trapBubbledEvent"></a>trapBubbledEvent</h3><p>绑定冒泡事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">trapBubbledEvent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    topLevelType: DOMTopLevelEventType,</span></span></span><br><span class="line"><span class="function"><span class="params">    element: Document | Element | Node,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    trapEventForPluginEventSystem(element, topLevelType, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="trapEventForPluginEventSystem"><a href="#trapEventForPluginEventSystem" class="headerlink" title="trapEventForPluginEventSystem"></a>trapEventForPluginEventSystem</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trapEventForPluginEventSystem</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    element: Document | Element | Node,</span></span></span><br><span class="line"><span class="function"><span class="params">    topLevelType: DOMTopLevelEventType,</span></span></span><br><span class="line"><span class="function"><span class="params">    capture: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> listener;</span><br><span class="line">    <span class="comment">// 事件优先级</span></span><br><span class="line">    <span class="keyword">switch</span> (getEventPriority(topLevelType)) &#123;</span><br><span class="line">        <span class="keyword">case</span> DiscreteEvent:</span><br><span class="line">            listener = dispatchDiscreteEvent.bind(<span class="literal">null</span>, topLevelType, PLUGIN_EVENT_SYSTEM);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UserBlockingEvent:</span><br><span class="line">            listener = dispatchUserBlockingUpdate.bind(<span class="literal">null</span>, topLevelType, PLUGIN_EVENT_SYSTEM);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ContinuousEvent:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            listener = dispatchEvent.bind(<span class="literal">null</span>, topLevelType, PLUGIN_EVENT_SYSTEM);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> rawEventName = getRawEventName(topLevelType); <span class="comment">// 获取原始事件名称</span></span><br><span class="line">    <span class="comment">// 在document监听事件事件</span></span><br><span class="line">    <span class="keyword">if</span> (capture) &#123;</span><br><span class="line">        addEventCaptureListener(element, rawEventName, listener);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addEventBubbleListener(element, rawEventName, listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h2><p>从<code>dispatchDiscreteEvent</code>开始，见上<code>trapEventForPluginEventSystem</code></p>
<h3 id="dispatchDiscreteEvent"><a href="#dispatchDiscreteEvent" class="headerlink" title="dispatchDiscreteEvent"></a>dispatchDiscreteEvent</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事件的执行开始</span></span><br><span class="line"><span class="comment">// dispatchEvent是最终要执行的事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchDiscreteEvent</span>(<span class="params">topLevelType, eventSystemFlags, nativeEvent</span>) </span>&#123;</span><br><span class="line">    flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);</span><br><span class="line">    discreteUpdates(dispatchEvent, topLevelType, eventSystemFlags, nativeEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="flushDiscreteUpdatesIfNeeded"><a href="#flushDiscreteUpdatesIfNeeded" class="headerlink" title="flushDiscreteUpdatesIfNeeded"></a>flushDiscreteUpdatesIfNeeded</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lastFlushedEventTimeStamp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">flushDiscreteUpdatesIfNeeded</span>(<span class="params">timeStamp: number</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// event.timeStamp isn&#x27;t overly reliable due to inconsistencies in</span></span><br><span class="line">    <span class="comment">// how different browsers have historically provided the time stamp.</span></span><br><span class="line">    <span class="comment">// Some browsers provide high-resolution time stamps for all events,</span></span><br><span class="line">    <span class="comment">// some provide low-resoltion time stamps for all events. FF &lt; 52</span></span><br><span class="line">    <span class="comment">// even mixes both time stamps together. Some browsers even report</span></span><br><span class="line">    <span class="comment">// negative time stamps or time stamps that are 0 (iOS9) in some cases.</span></span><br><span class="line">    <span class="comment">// Given we are only comparing two time stamps with equality (!==),</span></span><br><span class="line">    <span class="comment">// we are safe from the resolution differences. If the time stamp is 0</span></span><br><span class="line">    <span class="comment">// we bail-out of preventing the flush, which can affect semantics,</span></span><br><span class="line">    <span class="comment">// such as if an earlier flush removes or adds event listeners that</span></span><br><span class="line">    <span class="comment">// are fired in the subsequent flush. However, this is the same</span></span><br><span class="line">    <span class="comment">// behaviour as we had before this change, so the risks are low.</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        !isInsideEventHandler &amp;&amp;</span><br><span class="line">        (!enableEventAPI || timeStamp === <span class="number">0</span> || lastFlushedEventTimeStamp !== timeStamp)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// 记录时间戳</span></span><br><span class="line">        lastFlushedEventTimeStamp = timeStamp;</span><br><span class="line">        flushDiscreteUpdatesImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="flushDiscreteUpdatesImpl"><a href="#flushDiscreteUpdatesImpl" class="headerlink" title="flushDiscreteUpdatesImpl"></a>flushDiscreteUpdatesImpl</h3><p>flushDiscreteUpdatesImpl 在不同环境下引用不同</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在ReactDom.js直接执行</span></span><br><span class="line">setBatchingImplementation(</span><br><span class="line">    batchedUpdates,</span><br><span class="line">    discreteUpdates,</span><br><span class="line">    flushDiscreteUpdates,</span><br><span class="line">    batchedEventUpdates,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flushDiscreteUpdatesImpl = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setBatchingImplementation</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    _batchedUpdatesImpl,</span></span></span><br><span class="line"><span class="function"><span class="params">    _discreteUpdatesImpl,</span></span></span><br><span class="line"><span class="function"><span class="params">    _flushDiscreteUpdatesImpl,</span></span></span><br><span class="line"><span class="function"><span class="params">    _batchedEventUpdatesImpl,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    batchedUpdatesImpl = _batchedUpdatesImpl;</span><br><span class="line">    discreteUpdatesImpl = _discreteUpdatesImpl;</span><br><span class="line">    flushDiscreteUpdatesImpl = _flushDiscreteUpdatesImpl;</span><br><span class="line">    batchedEventUpdatesImpl = _batchedEventUpdatesImpl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在浏览器环境就是<code>flushDiscreteUpdates</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">flushDiscreteUpdates</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Should be able to flush inside batchedUpdates, but not inside `act`.</span></span><br><span class="line">    <span class="comment">// However, `act` uses `batchedUpdates`, so there&#x27;s no way to distinguish</span></span><br><span class="line">    <span class="comment">// those two cases. Need to fix this before exposing flushDiscreteUpdates</span></span><br><span class="line">    <span class="comment">// as a public API.</span></span><br><span class="line">    <span class="keyword">if</span> ((executionContext &amp; (BatchedContext | RenderContext | CommitContext)) !== NoContext) &#123;</span><br><span class="line">        <span class="comment">// We&#x27;re already rendering, so we can&#x27;t synchronously flush pending work.</span></span><br><span class="line">        <span class="comment">// This is probably a nested event dispatch triggered by a lifecycle/effect,</span></span><br><span class="line">        <span class="comment">// like `el.focus()`. Exit.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 刷新待处理？</span></span><br><span class="line">    flushPendingDiscreteUpdates();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!revertPassiveEffectsChange) &#123;</span><br><span class="line">        <span class="comment">// If the discrete updates scheduled passive effects, flush them now so that</span></span><br><span class="line">        <span class="comment">// they fire before the next serial event.</span></span><br><span class="line">        flushPassiveEffects();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="flushPassiveEffects"><a href="#flushPassiveEffects" class="headerlink" title="flushPassiveEffects"></a>flushPassiveEffects</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">flushPassiveEffects</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rootWithPendingPassiveEffects === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> root = rootWithPendingPassiveEffects;</span><br><span class="line">    <span class="keyword">const</span> expirationTime = pendingPassiveEffectsExpirationTime;</span><br><span class="line">    rootWithPendingPassiveEffects = <span class="literal">null</span>;</span><br><span class="line">    pendingPassiveEffectsExpirationTime = NoWork;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> prevInteractions: <span class="built_in">Set</span>&lt;Interaction&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (enableSchedulerTracing) &#123;</span><br><span class="line">        prevInteractions = __interactionsRef.current;</span><br><span class="line">        __interactionsRef.current = root.memoizedInteractions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> prevExecutionContext = executionContext;</span><br><span class="line">    executionContext |= CommitContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: This currently assumes there are no passive effects on the root</span></span><br><span class="line">    <span class="comment">// fiber, because the root is not part of its own effect list. This could</span></span><br><span class="line">    <span class="comment">// change in the future.</span></span><br><span class="line">    <span class="keyword">let</span> effect = root.current.firstEffect;</span><br><span class="line">    <span class="keyword">while</span> (effect !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                commitPassiveHookEffects(effect);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                invariant(effect !== <span class="literal">null</span>, <span class="string">&#x27;Should be working on an effect.&#x27;</span>);</span><br><span class="line">                captureCommitPhaseError(effect, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        effect = effect.nextEffect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enableSchedulerTracing) &#123;</span><br><span class="line">        __interactionsRef.current = ((prevInteractions: any): <span class="built_in">Set</span>&lt;Interaction&gt;);</span><br><span class="line">        finishPendingInteractions(root, expirationTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    executionContext = prevExecutionContext;</span><br><span class="line">    flushSyncCallbackQueue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If additional passive effects were scheduled, increment a counter. If this</span></span><br><span class="line">    <span class="comment">// exceeds the limit, we&#x27;ll fire a warning.</span></span><br><span class="line">    nestedPassiveUpdateCount =</span><br><span class="line">        rootWithPendingPassiveEffects === <span class="literal">null</span> ? <span class="number">0</span> : nestedPassiveUpdateCount + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="discreteUpdates"><a href="#discreteUpdates" class="headerlink" title="discreteUpdates"></a>discreteUpdates</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">discreteUpdates</span>(<span class="params">fn, a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> prevIsInsideEventHandler = isInsideEventHandler;</span><br><span class="line">    isInsideEventHandler = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> discreteUpdatesImpl(fn, a, b, c);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        isInsideEventHandler = prevIsInsideEventHandler;</span><br><span class="line">        <span class="keyword">if</span> (!isInsideEventHandler) &#123;</span><br><span class="line">            finishEventHandler();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="discreteUpdatesImpl"><a href="#discreteUpdatesImpl" class="headerlink" title="discreteUpdatesImpl"></a>discreteUpdatesImpl</h3><p>即 <code>discreteUpdates</code>，理由见<code>flushDiscreteUpdatesImpl</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">discreteUpdates</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">R</span>&gt;(<span class="params">fn: (A, B, C) =&gt; R, a: A, b: B, c: C</span>): <span class="title">R</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> prevExecutionContext = executionContext;</span><br><span class="line">    <span class="comment">// 添加执行content</span></span><br><span class="line">    executionContext |= DiscreteEventContext;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Should this</span></span><br><span class="line">        <span class="keyword">return</span> runWithPriority(UserBlockingPriority, fn.bind(<span class="literal">null</span>, a, b, c));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        executionContext = prevExecutionContext;</span><br><span class="line">        <span class="keyword">if</span> (executionContext === NoContext) &#123;</span><br><span class="line">            <span class="comment">// Flush the immediate callbacks that were scheduled during this batch</span></span><br><span class="line">            <span class="comment">// 事件结束后运行同步队列</span></span><br><span class="line">            flushSyncCallbackQueue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="runWithPriority"><a href="#runWithPriority" class="headerlink" title="runWithPriority"></a>runWithPriority</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">runWithPriority</span>&lt;<span class="title">T</span>&gt;(<span class="params">reactPriorityLevel: ReactPriorityLevel, fn: () =&gt; T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 转换优先级？ 99 -&gt; 1</span></span><br><span class="line">    <span class="keyword">const</span> priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);</span><br><span class="line">    <span class="keyword">return</span> Scheduler_runWithPriority(priorityLevel, fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Scheduler-runWithPriority"><a href="#Scheduler-runWithPriority" class="headerlink" title="Scheduler_runWithPriority"></a>Scheduler_runWithPriority</h3><p>最终执行<code>eventHandler</code> 即 <code>dispatchEvent</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_runWithPriority</span>(<span class="params">priorityLevel, eventHandler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (priorityLevel) &#123;</span><br><span class="line">        <span class="keyword">case</span> ImmediatePriority:</span><br><span class="line">        <span class="keyword">case</span> UserBlockingPriority:</span><br><span class="line">        <span class="keyword">case</span> NormalPriority:</span><br><span class="line">        <span class="keyword">case</span> LowPriority:</span><br><span class="line">        <span class="keyword">case</span> IdlePriority:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            priorityLevel = NormalPriority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> previousPriorityLevel = currentPriorityLevel; <span class="comment">// 3</span></span><br><span class="line">    currentPriorityLevel = priorityLevel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> eventHandler(); <span class="comment">// 运行react事件</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dispatchEvent"><a href="#dispatchEvent" class="headerlink" title="dispatchEvent"></a>dispatchEvent</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatchEvent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    topLevelType: DOMTopLevelEventType,</span></span></span><br><span class="line"><span class="function"><span class="params">    eventSystemFlags: EventSystemFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">    nativeEvent: AnyNativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_enabled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> nativeEventTarget = getEventTarget(nativeEvent); <span class="comment">// 获得事件发出的目标dom</span></span><br><span class="line">    <span class="keyword">let</span> targetInst = getClosestInstanceFromNode(nativeEventTarget); <span class="comment">// 获得dom对应的fiber</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        targetInst !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> targetInst.tag === <span class="string">&#x27;number&#x27;</span> &amp;&amp;</span><br><span class="line">        !isFiberMounted(targetInst) <span class="comment">// 是否mounted状态？</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// If we get an event (ex: img onload) before committing that</span></span><br><span class="line">        <span class="comment">// component&#x27;s mount, ignore it for now (that is, treat it as if it was an</span></span><br><span class="line">        <span class="comment">// event on a non-React tree). We might also consider queueing events and</span></span><br><span class="line">        <span class="comment">// dispatching them after the mount.</span></span><br><span class="line">        targetInst = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enableEventAPI) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dispatchEventForPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dispatchEventForPluginEventSystem"><a href="#dispatchEventForPluginEventSystem" class="headerlink" title="dispatchEventForPluginEventSystem"></a>dispatchEventForPluginEventSystem</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchEventForPluginEventSystem</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    topLevelType: DOMTopLevelEventType,</span></span></span><br><span class="line"><span class="function"><span class="params">    eventSystemFlags: EventSystemFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">    nativeEvent: AnyNativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">    targetInst: null | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>意义不明,先不管</span></span><br><span class="line">    <span class="keyword">const</span> bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Event queue being processed in the same cycle allows</span></span><br><span class="line">        <span class="comment">// `preventDefault`.</span></span><br><span class="line">        batchedEventUpdates(handleTopLevel, bookKeeping);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        releaseTopLevelCallbackBookKeeping(bookKeeping);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="batchedEventUpdates"><a href="#batchedEventUpdates" class="headerlink" title="batchedEventUpdates"></a>batchedEventUpdates</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">batchedEventUpdates</span>(<span class="params">fn, bookkeeping</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInsideEventHandler) &#123;</span><br><span class="line">        <span class="comment">// If we are currently inside another batch, we need to wait until it</span></span><br><span class="line">        <span class="comment">// fully completes before restoring state.</span></span><br><span class="line">        <span class="keyword">return</span> fn(bookkeeping);</span><br><span class="line">    &#125;</span><br><span class="line">    isInsideEventHandler = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> batchedEventUpdatesImpl(fn, bookkeeping);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        isInsideEventHandler = <span class="literal">false</span>;</span><br><span class="line">        finishEventHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="handleTopLevel"><a href="#handleTopLevel" class="headerlink" title="handleTopLevel"></a>handleTopLevel</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleTopLevel</span>(<span class="params">bookKeeping: BookKeepingInstance</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> targetInst = bookKeeping.targetInst;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop through the hierarchy, in case there&#x27;s any nested components.</span></span><br><span class="line">    <span class="comment">// It&#x27;s important that we build the array of ancestors before calling any</span></span><br><span class="line">    <span class="comment">// event handlers, because event handlers can modify the DOM, leading to</span></span><br><span class="line">    <span class="comment">// inconsistencies with ReactMount&#x27;s node cache. See #1105.</span></span><br><span class="line">    <span class="keyword">let</span> ancestor = targetInst;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ancestor) &#123;</span><br><span class="line">            <span class="keyword">const</span> ancestors = bookKeeping.ancestors;</span><br><span class="line">            ((ancestors: any): <span class="built_in">Array</span>&lt;Fiber | <span class="literal">null</span>&gt;).push(ancestor);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> root = findRootContainerNode(ancestor); <span class="comment">// 根据fiber获得fiber根节点的dom div#app</span></span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bookKeeping.ancestors.push(ancestor);</span><br><span class="line">        ancestor = getClosestInstanceFromNode(root);</span><br><span class="line">    &#125; <span class="keyword">while</span> (ancestor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bookKeeping.ancestors.length; i++) &#123;</span><br><span class="line">        targetInst = bookKeeping.ancestors[i];</span><br><span class="line">        <span class="keyword">const</span> eventTarget = getEventTarget(bookKeeping.nativeEvent);</span><br><span class="line">        <span class="keyword">const</span> topLevelType = ((bookKeeping.topLevelType: any): DOMTopLevelEventType);</span><br><span class="line">        <span class="keyword">const</span> nativeEvent = ((bookKeeping.nativeEvent: any): AnyNativeEvent);</span><br><span class="line"></span><br><span class="line">        runExtractedPluginEventsInBatch(topLevelType, targetInst, nativeEvent, eventTarget);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="runExtractedPluginEventsInBatch"><a href="#runExtractedPluginEventsInBatch" class="headerlink" title="runExtractedPluginEventsInBatch"></a>runExtractedPluginEventsInBatch</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">runExtractedPluginEventsInBatch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    topLevelType: TopLevelType,</span></span></span><br><span class="line"><span class="function"><span class="params">    targetInst: null | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    nativeEvent: AnyNativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">    nativeEventTarget: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 返回当前点击event(react event),</span></span><br><span class="line">    <span class="comment">// 添加了_dispatchListeners属性存放事件(包括父节点的)</span></span><br><span class="line">    <span class="comment">// events可能是个数组</span></span><br><span class="line">    <span class="keyword">const</span> events = extractPluginEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);</span><br><span class="line">    runEventsInBatch(events); <span class="comment">// 运行事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="extractPluginEvents"><a href="#extractPluginEvents" class="headerlink" title="extractPluginEvents"></a>extractPluginEvents</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allows registered plugins an opportunity to extract events from top-level</span></span><br><span class="line"><span class="comment"> * native browser events.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;*&#125;</span> </span>An accumulation of synthetic events.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@internal</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractPluginEvents</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    topLevelType: TopLevelType,</span></span></span><br><span class="line"><span class="function"><span class="params">    targetInst: null | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    nativeEvent: AnyNativeEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">    nativeEventTarget: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Array</span>&lt;<span class="title">ReactSyntheticEvent</span>&gt; | <span class="title">ReactSyntheticEvent</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> events = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; plugins.length; i++) &#123;</span><br><span class="line">        <span class="comment">// empty, 一般事件、鼠标事件、onChange、select、输入事件</span></span><br><span class="line">        <span class="comment">// 这些不同的事件可能会同时触发</span></span><br><span class="line">        <span class="comment">// Not every plugin in the ordering may be loaded at runtime.</span></span><br><span class="line">        <span class="keyword">const</span> possiblePlugin: PluginModule&lt;AnyNativeEvent&gt; = plugins[i];</span><br><span class="line">        <span class="keyword">if</span> (possiblePlugin) &#123;</span><br><span class="line">            <span class="comment">// 返回react事件的event</span></span><br><span class="line">            <span class="keyword">const</span> extractedEvents = possiblePlugin.extractEvents(</span><br><span class="line">                topLevelType,</span><br><span class="line">                targetInst,</span><br><span class="line">                nativeEvent,</span><br><span class="line">                nativeEventTarget,</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (extractedEvents) &#123;</span><br><span class="line">                events = accumulateInto(events, extractedEvents);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> events;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>possiblePlugin.extractEvents = SimpleEventPlugin.extractEvents</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SimpleEventPlugin: PluginModule&lt;MouseEvent&gt; &amp; &#123;</span><br><span class="line">    getEventPriority: <span class="function">(<span class="params">topLevelType: TopLevelType</span>) =&gt;</span> EventPriority,</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    eventTypes: eventTypes,</span><br><span class="line"></span><br><span class="line">    getEventPriority(topLevelType: TopLevelType): EventPriority &#123;</span><br><span class="line">        <span class="keyword">const</span> config = topLevelEventsToDispatchConfig[topLevelType];</span><br><span class="line">        <span class="keyword">return</span> config !== <span class="literal">undefined</span> ? config.eventPriority : ContinuousEvent;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    extractEvents: <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        topLevelType: TopLevelType,</span></span></span><br><span class="line"><span class="function"><span class="params">        targetInst: null | Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">        nativeEvent: MouseEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">        nativeEventTarget: EventTarget,</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>): <span class="title">null</span> | <span class="title">ReactSyntheticEvent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];</span><br><span class="line">        <span class="keyword">if</span> (!dispatchConfig) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> EventConstructor;</span><br><span class="line">        <span class="keyword">switch</span> (topLevelType) &#123;</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_KEY_PRESS:</span><br><span class="line">                <span class="comment">// Firefox creates a keypress event for function keys too. This removes</span></span><br><span class="line">                <span class="comment">// the unwanted keypress events. Enter is however both printable and</span></span><br><span class="line">                <span class="comment">// non-printable. One would expect Tab to be as well (but it isn&#x27;t).</span></span><br><span class="line">                <span class="keyword">if</span> (getEventCharCode(nativeEvent) === <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">/* falls through */</span></span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_KEY_DOWN:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_KEY_UP:</span><br><span class="line">                EventConstructor = SyntheticKeyboardEvent;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_BLUR:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_FOCUS:</span><br><span class="line">                EventConstructor = SyntheticFocusEvent;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_CLICK:</span><br><span class="line">                <span class="comment">// Firefox creates a click event on right mouse clicks. This removes the</span></span><br><span class="line">                <span class="comment">// unwanted click events.</span></span><br><span class="line">                <span class="keyword">if</span> (nativeEvent.button === <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">/* falls through */</span></span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_AUX_CLICK:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_DOUBLE_CLICK:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_MOUSE_DOWN:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_MOUSE_MOVE:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_MOUSE_UP:</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Disabled elements should not respond to mouse events</span></span><br><span class="line">            <span class="comment">/* falls through */</span></span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_MOUSE_OUT:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_MOUSE_OVER:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_CONTEXT_MENU:</span><br><span class="line">                EventConstructor = SyntheticMouseEvent;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_DRAG:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_DRAG_END:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_DRAG_ENTER:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_DRAG_EXIT:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_DRAG_LEAVE:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_DRAG_OVER:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_DRAG_START:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_DROP:</span><br><span class="line">                EventConstructor = SyntheticDragEvent;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_TOUCH_CANCEL:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_TOUCH_END:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_TOUCH_MOVE:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_TOUCH_START:</span><br><span class="line">                EventConstructor = SyntheticTouchEvent;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_ANIMATION_END:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_ANIMATION_ITERATION:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_ANIMATION_START:</span><br><span class="line">                EventConstructor = SyntheticAnimationEvent;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_TRANSITION_END:</span><br><span class="line">                EventConstructor = SyntheticTransitionEvent;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_SCROLL:</span><br><span class="line">                EventConstructor = SyntheticUIEvent;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_WHEEL:</span><br><span class="line">                EventConstructor = SyntheticWheelEvent;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_COPY:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_CUT:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_PASTE:</span><br><span class="line">                EventConstructor = SyntheticClipboardEvent;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_GOT_POINTER_CAPTURE:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_LOST_POINTER_CAPTURE:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_POINTER_CANCEL:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_POINTER_DOWN:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_POINTER_MOVE:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_POINTER_OUT:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_POINTER_OVER:</span><br><span class="line">            <span class="keyword">case</span> DOMTopLevelEventTypes.TOP_POINTER_UP:</span><br><span class="line">                EventConstructor = SyntheticPointerEvent;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (knownHTMLTopLevelTypes.indexOf(topLevelType) === <span class="number">-1</span>) &#123;</span><br><span class="line">                        warningWithoutStack(</span><br><span class="line">                            <span class="literal">false</span>,</span><br><span class="line">                            <span class="string">&#x27;SimpleEventPlugin: Unhandled event type, `%s`. This warning &#x27;</span> +</span><br><span class="line">                                <span class="string">&#x27;is likely caused by a bug in React. Please file an issue.&#x27;</span>,</span><br><span class="line">                            topLevelType,</span><br><span class="line">                        );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// HTML Events</span></span><br><span class="line">                <span class="comment">// @see http://www.w3.org/TR/html5/index.html#events-0</span></span><br><span class="line">                EventConstructor = SyntheticEvent;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据原始event构建react的event</span></span><br><span class="line">        <span class="keyword">const</span> event = EventConstructor.getPooled(</span><br><span class="line">            dispatchConfig,</span><br><span class="line">            targetInst,</span><br><span class="line">            nativeEvent,</span><br><span class="line">            nativeEventTarget,</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 先捕获后冒泡</span></span><br><span class="line">        accumulateTwoPhaseDispatches(event);</span><br><span class="line">        <span class="keyword">return</span> event;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="accumulateTwoPhaseDispatches"><a href="#accumulateTwoPhaseDispatches" class="headerlink" title="accumulateTwoPhaseDispatches"></a>accumulateTwoPhaseDispatches</h3><p>传进去的<code>event</code>能拿到对应<code>fiber</code>，根据<code>fiber</code>能拿到所有的父<code>fiber</code>，然后把所有符合的<code>fiber</code>放在一个数组中；</p>
<p>先按捕获的方式从父-&gt;子遍历得到是否有 capture 事件,在得到冒泡事件(特定标签会验证<code>disabled</code>)</p>
<p>然后所有合法的事件都放在了<code>event._dispatchListeners</code>中(一个是 function，多个是[function,function])</p>
<p>和他们的 <code>fiber</code> 放在<code>event._dispatchInstances</code>(一个是 fiber，多个是[fiber,fiber])</p>
<p>最后返回了这个<code>event</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">traverseTwoPhase</span>(<span class="params">inst, fn, arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> path = [];</span><br><span class="line">    <span class="keyword">while</span> (inst) &#123;</span><br><span class="line">        path.push(inst);</span><br><span class="line">        inst = getParent(inst);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = path.length; i-- &gt; <span class="number">0</span>; ) &#123;</span><br><span class="line">        fn(path[i], <span class="string">&#x27;captured&#x27;</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; path.length; i++) &#123;</span><br><span class="line">        fn(path[i], <span class="string">&#x27;bubbled&#x27;</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="runEventsInBatch"><a href="#runEventsInBatch" class="headerlink" title="runEventsInBatch"></a>runEventsInBatch</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">runEventsInBatch</span>(<span class="params">events: Array&lt;ReactSyntheticEvent&gt; | ReactSyntheticEvent | null</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 批量运行事件</span></span><br><span class="line">    <span class="keyword">if</span> (events !== <span class="literal">null</span>) &#123;</span><br><span class="line">        eventQueue = accumulateInto(eventQueue, events);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set `eventQueue` to null before processing it so that we can tell if more</span></span><br><span class="line">    <span class="comment">// events get enqueued while processing.</span></span><br><span class="line">    <span class="keyword">const</span> processingEventQueue = eventQueue;</span><br><span class="line">    eventQueue = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!processingEventQueue) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (多个不同事件就循环)执行executeDispatchesAndReleaseTopLevel(processingEventQueue)</span></span><br><span class="line">    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This would be a good time to rethrow if any of the event handlers threw.</span></span><br><span class="line">    rethrowCaughtError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="executeDispatchesAndReleaseTopLevel"><a href="#executeDispatchesAndReleaseTopLevel" class="headerlink" title="executeDispatchesAndReleaseTopLevel"></a>executeDispatchesAndReleaseTopLevel</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dispatches an event and releases it back into the pool, unless persistent.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;?object&#125;</span> </span>event Synthetic event to be dispatched.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> executeDispatchesAndRelease = <span class="function"><span class="keyword">function</span> (<span class="params">event: ReactSyntheticEvent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event) &#123;</span><br><span class="line">        executeDispatchesInOrder(event);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!event.isPersistent()) &#123;</span><br><span class="line">            event.constructor.release(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> executeDispatchesAndReleaseTopLevel = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> executeDispatchesAndRelease(e);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="executeDispatchesInOrder"><a href="#executeDispatchesInOrder" class="headerlink" title="executeDispatchesInOrder"></a>executeDispatchesInOrder</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Standard/simple iteration through an event&#x27;s collected dispatches.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">executeDispatchesInOrder</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dispatchListeners = event._dispatchListeners;</span><br><span class="line">    <span class="keyword">const</span> dispatchInstances = event._dispatchInstances;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(dispatchListeners)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dispatchListeners.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (event.isPropagationStopped()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Listeners and Instances are two parallel arrays that are always in sync.</span></span><br><span class="line">            executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dispatchListeners) &#123;</span><br><span class="line">        executeDispatch(event, dispatchListeners, dispatchInstances);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行完后清空</span></span><br><span class="line">    event._dispatchListeners = <span class="literal">null</span>;</span><br><span class="line">    event._dispatchInstances = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="executeDispatch"><a href="#executeDispatch" class="headerlink" title="executeDispatch"></a>executeDispatch</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dispatch the event to the listener.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;SyntheticEvent&#125;</span> </span>event SyntheticEvent to handle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> </span>listener Application-level callback</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>inst Internal component instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">executeDispatch</span>(<span class="params">event, listener, inst</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> type = event.type || <span class="string">&#x27;unknown-event&#x27;</span>;</span><br><span class="line">    event.currentTarget = getNodeFromInstance(inst);</span><br><span class="line">    <span class="comment">// 这里执行了用户写的事件</span></span><br><span class="line">    invokeGuardedCallbackAndCatchFirstError(type, listener, <span class="literal">undefined</span>, event);</span><br><span class="line">    event.currentTarget = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Same as invokeGuardedCallback, but instead of returning an error, it stores</span></span><br><span class="line"><span class="comment"> * it in a global so it can be rethrown by `rethrowCaughtError` later.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> See if caughtError and rethrowError can be unified.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>name of the guard to use for logging or debugging</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>func The function to invoke</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>context The context to use when calling the function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;...*&#125;</span> </span>args Arguments for function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">invokeGuardedCallbackAndCatchFirstError</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>, <span class="title">E</span>, <span class="title">F</span>, <span class="title">Context</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    name: string | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    func: (a: A, b: B, c: C, d: D, e: E, f: F) =&gt; void,</span></span></span><br><span class="line"><span class="function"><span class="params">    context: Context,</span></span></span><br><span class="line"><span class="function"><span class="params">    a: A,</span></span></span><br><span class="line"><span class="function"><span class="params">    b: B,</span></span></span><br><span class="line"><span class="function"><span class="params">    c: C,</span></span></span><br><span class="line"><span class="function"><span class="params">    d: D,</span></span></span><br><span class="line"><span class="function"><span class="params">    e: E,</span></span></span><br><span class="line"><span class="function"><span class="params">    f: F,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    invokeGuardedCallback.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (hasError) &#123;</span><br><span class="line">        <span class="keyword">const</span> error = clearCaughtError();</span><br><span class="line">        <span class="keyword">if</span> (!hasRethrowError) &#123;</span><br><span class="line">            hasRethrowError = <span class="literal">true</span>;</span><br><span class="line">            rethrowError = error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Call a function while guarding against errors that happens within it.</span></span><br><span class="line"><span class="comment"> * Returns an error if it throws, otherwise null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In production, this is implemented using a try-catch. The reason we don&#x27;t</span></span><br><span class="line"><span class="comment"> * use a try-catch directly is so that we can swap out a different</span></span><br><span class="line"><span class="comment"> * implementation in DEV mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>name of the guard to use for logging or debugging</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>func The function to invoke</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>context The context to use when calling the function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;...*&#125;</span> </span>args Arguments for function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">invokeGuardedCallback</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>, <span class="title">E</span>, <span class="title">F</span>, <span class="title">Context</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    name: string | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    func: (a: A, b: B, c: C, d: D, e: E, f: F) =&gt; mixed,</span></span></span><br><span class="line"><span class="function"><span class="params">    context: Context,</span></span></span><br><span class="line"><span class="function"><span class="params">    a: A,</span></span></span><br><span class="line"><span class="function"><span class="params">    b: B,</span></span></span><br><span class="line"><span class="function"><span class="params">    c: C,</span></span></span><br><span class="line"><span class="function"><span class="params">    d: D,</span></span></span><br><span class="line"><span class="function"><span class="params">    e: E,</span></span></span><br><span class="line"><span class="function"><span class="params">    f: F,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    hasError = <span class="literal">false</span>;</span><br><span class="line">    caughtError = <span class="literal">null</span>;</span><br><span class="line">    invokeGuardedCallbackImpl.apply(reporter, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> invokeGuardedCallbackImpl = <span class="function"><span class="keyword">function</span> &lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>, <span class="title">D</span>, <span class="title">E</span>, <span class="title">F</span>, <span class="title">Context</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    name: string | null,</span></span></span><br><span class="line"><span class="function"><span class="params">    func: (a: A, b: B, c: C, d: D, e: E, f: F) =&gt; mixed,</span></span></span><br><span class="line"><span class="function"><span class="params">    context: Context,</span></span></span><br><span class="line"><span class="function"><span class="params">    a: A,</span></span></span><br><span class="line"><span class="function"><span class="params">    b: B,</span></span></span><br><span class="line"><span class="function"><span class="params">    c: C,</span></span></span><br><span class="line"><span class="function"><span class="params">    d: D,</span></span></span><br><span class="line"><span class="function"><span class="params">    e: E,</span></span></span><br><span class="line"><span class="function"><span class="params">    f: F,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> funcArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// func就是用户写的方法</span></span><br><span class="line">        func.apply(context, funcArgs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">this</span>.onError(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行完后就是各种变量的释放和运行参数的重置或回归，然后执行同步队列</p>
<p>见 <code>schedule.md</code> -&gt; <code>flushSyncCallbackQueue</code></p>
<p>根据跟新重新构建<code>fiber</code>,然后渲染(<code>renderRoot</code>-&gt;<code>commitRoot</code>)</p>
]]></content>
      <tags>
        <tag>react源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码阅读笔记（2）(Vue的生命周期)</title>
    <url>/my-notes/2018/01/23/vue/2/</url>
    <content><![CDATA[<p><a href="https://github.com/liutao/vue2.0-source/blob/master/%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%A0%97%E5%AD%90%E6%9F%A5%E7%9C%8BVue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.md">参考了的文章</a><br>以文章提供的思路自己过一遍代码</p>
<p>————-咯咯咯———-</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>以下实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">  var vm &#x3D; new Vue(&#123;</span><br><span class="line">    el: &#39;#app&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: &#39;第一个vue实例&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      child: &#123;</span><br><span class="line">        template: &quot;&lt;div&gt;&#123;&#123;a&#125;&#125;&lt;&#x2F;div&gt;&quot;,</span><br><span class="line">        inject: [&#39;a&#39;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    provide: &#123;</span><br><span class="line">      a: &#39;a&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>以<code>new Vue</code>开始，让我们来看一下 vue 都做了哪些工作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Vue (options) &#123; &#x2F;&#x2F; vue定义的地方</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp;</span><br><span class="line">    !(this instanceof Vue)) &#123; &#x2F;&#x2F; 是不是new Vue()</span><br><span class="line">    warn(&#39;Vue is a constructor and should be called with the &#96;new&#96; keyword&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  this._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue) &#x2F;&#x2F; _init</span><br></pre></td></tr></table></figure>

<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>这里 vue 只触发了一个方法<code>this._init(options)</code><br>跟进<code>_init</code>方法 src/core/instance/init.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.prototype._init &#x3D; function (options?: Object) &#123;</span><br><span class="line">  const vm: Component &#x3D; this</span><br><span class="line">  &#x2F;&#x2F; a uid</span><br><span class="line">  vm._uid &#x3D; uid++</span><br><span class="line"></span><br><span class="line">  let startTag, endTag</span><br><span class="line">  &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    startTag &#x3D; &#96;vue-perf-init:$&#123;vm._uid&#125;&#96;</span><br><span class="line">    endTag &#x3D; &#96;vue-perf-end:$&#123;vm._uid&#125;&#96;</span><br><span class="line">    mark(startTag)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; a flag to avoid this being observed</span><br><span class="line">  vm._isVue &#x3D; true</span><br><span class="line">  &#x2F;&#x2F; merge options options是传进来的,options._isComponent是什么，貌似没有手动传这个参数？？</span><br><span class="line">  if (options &amp;&amp; options._isComponent) &#123; &#x2F;&#x2F; _isComponent是内部创建子组件时才会添加为true的属性</span><br><span class="line">    &#x2F;&#x2F; optimize internal component instantiation</span><br><span class="line">    &#x2F;&#x2F; since dynamic options merging is pretty slow, and none of the</span><br><span class="line">    &#x2F;&#x2F; internal component options needs special treatment.</span><br><span class="line">    initInternalComponent(vm, options)</span><br><span class="line">  &#125; else &#123; &#x2F;&#x2F; 在这个案例下走的是else</span><br><span class="line">    vm.$options &#x3D; mergeOptions(</span><br><span class="line">      resolveConstructorOptions(vm.constructor),</span><br><span class="line">      options || &#123;&#125;,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;* istanbul ignore else *&#x2F;</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">    initProxy(vm)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    vm._renderProxy &#x3D; vm</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; expose real self</span><br><span class="line">  vm._self &#x3D; vm</span><br><span class="line">  initLifecycle(vm)</span><br><span class="line">  initEvents(vm)</span><br><span class="line">  initRender(vm)</span><br><span class="line">  callHook(vm, &#39;beforeCreate&#39;)</span><br><span class="line">  initInjections(vm) &#x2F;&#x2F; resolve injections before data&#x2F;props</span><br><span class="line">  initState(vm)</span><br><span class="line">  initProvide(vm) &#x2F;&#x2F; resolve provide after data&#x2F;props</span><br><span class="line">  callHook(vm, &#39;created&#39;)</span><br><span class="line"></span><br><span class="line">  &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    vm._name &#x3D; formatComponentName(vm, false)</span><br><span class="line">    mark(endTag)</span><br><span class="line">    measure(&#96;$&#123;vm._name&#125; init&#96;, startTag, endTag)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (vm.$options.el) &#123;</span><br><span class="line">    vm.$mount(vm.$options.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子没有内部子组件，所以走 else 路线，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm.$options &#x3D; mergeOptions(</span><br><span class="line">  resolveConstructorOptions(vm.constructor),</span><br><span class="line">  options || &#123;&#125;,</span><br><span class="line">  vm</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="resolveConstructorOptions"><a href="#resolveConstructorOptions" class="headerlink" title="resolveConstructorOptions"></a>resolveConstructorOptions</h3><p>这里的<code>mergeOptions</code>应该是一个类似 Object.assign 的方法，<code>resolveConstructorOptions</code>猜不出意思,不过根据参考文章和具体代码，我知道了这个方法是在<code>Vue.extend</code>上才会被完全使用,在目前的情况下，这里原封不动的返回了 options</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function resolveConstructorOptions (Ctor: Class&lt;Component&gt;) &#123;</span><br><span class="line">  let options &#x3D; Ctor.options</span><br><span class="line">  &#x2F;&#x2F; 有super属性，说明Ctor是通过Vue.extend()方法创建的子类</span><br><span class="line">  if (Ctor.super) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  return options &#x2F;&#x2F; 在这里options没有经过任何处理就直接返回了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mergeOptions"><a href="#mergeOptions" class="headerlink" title="mergeOptions"></a>mergeOptions</h3><p>现在来看<code>mergeOptions</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Merge two option objects into a new one. 合并两个boject</span><br><span class="line"> * Core utility used in both instantiation and inheritance.</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function mergeOptions (</span><br><span class="line">  parent: Object,</span><br><span class="line">  child: Object,</span><br><span class="line">  vm?: Component</span><br><span class="line">): Object &#123; &#x2F;&#x2F; ts语法，必要返回一个object</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">    checkComponents(child) &#x2F;&#x2F; 判断组件名是否合法</span><br><span class="line">  &#125;</span><br><span class="line">  normalizeProps(child) &#x2F;&#x2F; 格式化prop，暂不深究？</span><br><span class="line">  normalizeDirectives(child) &#x2F;&#x2F; 格式化directive，暂不深究？</span><br><span class="line">  const extendsFrom &#x3D; child.extends &#x2F;&#x2F; options.extends</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * var CompA &#x3D; &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 在没有调用 &#96;Vue.extend&#96; 时候继承 CompA</span><br><span class="line">    var CompB &#x3D; &#123;</span><br><span class="line">      extends: CompA,</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    在这种情况下才会有extends</span><br><span class="line">   *&#x2F;</span><br><span class="line">  if (extendsFrom) &#123;</span><br><span class="line">    parent &#x3D; typeof extendsFrom &#x3D;&#x3D;&#x3D; &#39;function&#39;</span><br><span class="line">      ? mergeOptions(parent, extendsFrom.options, vm)</span><br><span class="line">      : mergeOptions(parent, extendsFrom, vm)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * var mixin &#x3D; &#123;</span><br><span class="line">      created: function () &#123; console.log(1) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">      created: function () &#123; console.log(2) &#125;,</span><br><span class="line">      mixins: [mixin]</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F; &#x3D;&gt; 1</span><br><span class="line">    &#x2F;&#x2F; &#x3D;&gt; 2</span><br><span class="line">    这里也是</span><br><span class="line">   *&#x2F;</span><br><span class="line">  if (child.mixins) &#123;</span><br><span class="line">    for (let i &#x3D; 0, l &#x3D; child.mixins.length; i &lt; l; i++) &#123;</span><br><span class="line">      let mixin &#x3D; child.mixins[i]</span><br><span class="line">      if (mixin.prototype instanceof Vue) &#123;</span><br><span class="line">        mixin &#x3D; mixin.options</span><br><span class="line">      &#125;</span><br><span class="line">      parent &#x3D; mergeOptions(parent, mixin, vm)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const options &#x3D; &#123;&#125;</span><br><span class="line">  let key</span><br><span class="line">  for (key in parent) &#123; &#x2F;&#x2F; components,directives,filters,_base</span><br><span class="line">    mergeField(key) &#x2F;&#x2F; strats[key] &#x3D; mergeAssets</span><br><span class="line">  &#125;</span><br><span class="line">  for (key in child) &#123; &#x2F;&#x2F; el、data</span><br><span class="line">    if (!hasOwn(parent, key)) &#123;</span><br><span class="line">      mergeField(key) &#x2F;&#x2F; strats.el &#x3D; defaultStrat strats.data</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function mergeField (key) &#123;</span><br><span class="line">    const strat &#x3D; strats[key] || defaultStrat</span><br><span class="line">    options[key] &#x3D; strat(parent[key], child[key], vm, key)</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(options)</span><br><span class="line">  &#x2F;*</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;components&quot;:&#123;&#125;,</span><br><span class="line">    &quot;directives&quot;:&#123;&#125;,</span><br><span class="line">    &quot;filters&quot;:&#123;&#125;,</span><br><span class="line">    &quot;el&quot;:&quot;#app&quot;,</span><br><span class="line">    data:funcion mergedInstanceDataFn,</span><br><span class="line">    _base: Vue</span><br><span class="line">  &#125;</span><br><span class="line">   *&#x2F;</span><br><span class="line">  return options &#x2F;&#x2F; components,directives,filters,_base,el,data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给 options 添加了 components,directives,filters,_base,el,data 属性</p>
<h3 id="initProxy"><a href="#initProxy" class="headerlink" title="initProxy"></a>initProxy</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">initProxy &#x3D; function initProxy (vm) &#123;</span><br><span class="line">    if (hasProxy) &#123;</span><br><span class="line">      &#x2F;&#x2F; determine which proxy handler to use</span><br><span class="line">      const options &#x3D; vm.$options</span><br><span class="line">      console.log(options)</span><br><span class="line">      const handlers &#x3D; options.render &amp;&amp; options.render._withStripped</span><br><span class="line">        ? getHandler</span><br><span class="line">        : hasHandler</span><br><span class="line">      vm._renderProxy &#x3D; new Proxy(vm, handlers)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      vm._renderProxy &#x3D; vm</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在开发环境中，如果支持 es6 的 proxy 语法，vm._renderProxy 等于一个 proxy 对象,<del>具体有什么用还未知，所以暂不深究</del><br>在下面的解读中，我已经知道最终的 render 生成函数就是在 vm._renderProxy 的环境下执行的。</p>
<h3 id="initLifecycle"><a href="#initLifecycle" class="headerlink" title="initLifecycle"></a>initLifecycle</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function initLifecycle (vm: Component) &#123;</span><br><span class="line">  const options &#x3D; vm.$options</span><br><span class="line">  console.log(options)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; locate first non-abstract parent</span><br><span class="line">  let parent &#x3D; options.parent</span><br><span class="line">  if (parent &amp;&amp; !options.abstract) &#123; &#x2F;&#x2F; 抽象节点相关？abstract暂不清楚在哪里用到</span><br><span class="line">    while (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class="line">      parent &#x3D; parent.$parent</span><br><span class="line">    &#125;</span><br><span class="line">    parent.$children.push(vm)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vm.$parent &#x3D; parent &#x2F;&#x2F; 在这里是undefined</span><br><span class="line">  vm.$root &#x3D; parent ? parent.$root : vm &#x2F;&#x2F; 在这里是vm</span><br><span class="line"></span><br><span class="line">  vm.$children &#x3D; []</span><br><span class="line">  vm.$refs &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">  vm._watcher &#x3D; null</span><br><span class="line">  vm._inactive &#x3D; null</span><br><span class="line">  vm._directInactive &#x3D; false</span><br><span class="line">  vm._isMounted &#x3D; false</span><br><span class="line">  vm._isDestroyed &#x3D; false</span><br><span class="line">  vm._isBeingDestroyed &#x3D; false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化生命周期相关的标识</p>
<p>options.abstract 用于判断是否是抽象组件，组件的父子关系建立会跳过抽象组件，抽象组件比如 keep-alive、transition 等。所有的子组件$root 都指向顶级组件。</p>
<h3 id="initEvents"><a href="#initEvents" class="headerlink" title="initEvents"></a>initEvents</h3><p>初始化 event 相关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function initEvents (vm: Component) &#123;</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Object.create(null)没有继承任何原型方法，也就是说它的原型链没有上一层。</span><br><span class="line">    console.log(Object.create(&#123;&#125;).toString);   &#x2F;&#x2F; function toString() &#123; [native code] &#125;</span><br><span class="line">    console.log(Object.create(null).toString); &#x2F;&#x2F; undefined</span><br><span class="line">    之前看到的也同理，只怪当初没baidu</span><br><span class="line">  *&#x2F;</span><br><span class="line">  vm._events &#x3D; Object.create(null) &#x2F;&#x2F; 比&#123;&#125;更干净</span><br><span class="line">  vm._hasHookEvent &#x3D; false</span><br><span class="line">  &#x2F;&#x2F; init parent attached events</span><br><span class="line">  const listeners &#x3D; vm.$options._parentListeners</span><br><span class="line">  if (listeners) &#123; &#x2F;&#x2F; 在这里是undefined</span><br><span class="line">    updateComponentListeners(vm, listeners)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_parentListeners 是父组件中绑定在自定义标签上的事件，供子组件处理。</p>
<h3 id="initRender"><a href="#initRender" class="headerlink" title="initRender"></a>initRender</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function initRender (vm: Component) &#123;</span><br><span class="line">  vm.$vnode &#x3D; null &#x2F;&#x2F; the placeholder node in parent tree</span><br><span class="line">  vm._vnode &#x3D; null &#x2F;&#x2F; the root of the child tree</span><br><span class="line">  vm._staticTrees &#x3D; null</span><br><span class="line">  const parentVnode &#x3D; vm.$options._parentVnode</span><br><span class="line">  const renderContext &#x3D; parentVnode &amp;&amp; parentVnode.context &#x2F;&#x2F; undefined</span><br><span class="line">  vm.$slots &#x3D; resolveSlots(vm.$options._renderChildren, renderContext) &#x2F;&#x2F; 都是undefined，具体使用到的时候再细看</span><br><span class="line">  vm.$scopedSlots &#x3D; emptyObject &#x2F;&#x2F; Object.freeze(&#123;&#125;)</span><br><span class="line">  &#x2F;&#x2F; bind the createElement fn to this instance</span><br><span class="line">  &#x2F;&#x2F; so that we get proper render context inside it.</span><br><span class="line">  &#x2F;&#x2F; args order: tag, data, children, normalizationType, alwaysNormalize</span><br><span class="line">  &#x2F;&#x2F; internal version is used by render functions compiled from templates</span><br><span class="line">  vm._c &#x3D; (a, b, c, d) &#x3D;&gt; createElement(vm, a, b, c, d, false) &#x2F;&#x2F; 等具体调用到的时候再来细看</span><br><span class="line">  &#x2F;&#x2F; normalization is always applied for the public version, used in</span><br><span class="line">  &#x2F;&#x2F; user-written render functions.</span><br><span class="line">  vm.$createElement &#x3D; (a, b, c, d) &#x3D;&gt; createElement(vm, a, b, c, d, true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$slots、$scopedSlots、$createElement 相关</p>
<h3 id="callHook"><a href="#callHook" class="headerlink" title="callHook"></a>callHook</h3><h3 id="initInjections"><a href="#initInjections" class="headerlink" title="initInjections"></a>initInjections</h3><h3 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function initState (vm: Component) &#123;</span><br><span class="line">  vm._watchers &#x3D; []</span><br><span class="line">  const opts &#x3D; vm.$options</span><br><span class="line">  if (opts.props) initProps(vm, opts.props)</span><br><span class="line">  if (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  if (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    observe(vm._data &#x3D; &#123;&#125;, true &#x2F;* asRootData *&#x2F;)</span><br><span class="line">  &#125;</span><br><span class="line">  if (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  if (opts.watch) initWatch(vm, opts.watch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显这里是 props、methods、data、computed、watch 相关操作</p>
<h4 id="initProps"><a href="#initProps" class="headerlink" title="initProps"></a>initProps</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function initProvide (vm: Component) &#123;</span><br><span class="line">  const provide &#x3D; vm.$options.provide</span><br><span class="line">  console.log(provide)</span><br><span class="line">  if (provide) &#123;</span><br><span class="line">    vm._provided &#x3D; typeof provide &#x3D;&#x3D;&#x3D; &#39;function&#39;</span><br><span class="line">      ? provide.call(vm)</span><br><span class="line">      : provide</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="initMethods"><a href="#initMethods" class="headerlink" title="initMethods"></a>initMethods</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function initMethods (vm: Component, methods: Object) &#123;</span><br><span class="line">  const props &#x3D; vm.$options.props</span><br><span class="line">  for (const key in methods) &#123;</span><br><span class="line">    vm[key] &#x3D; methods[key] &#x3D;&#x3D; null ? noop : bind(methods[key], vm) &#x2F;&#x2F; 给函数绑定环境</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      if (methods[key] &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 不空</span><br><span class="line">        warn(</span><br><span class="line">          &#96;method &quot;$&#123;key&#125;&quot; has an undefined value in the component definition. &#96; +</span><br><span class="line">          &#96;Did you reference the function correctly?&#96;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      if (props &amp;&amp; hasOwn(props, key)) &#123; &#x2F;&#x2F; 判断props里面的变量和methods的方法命名不同</span><br><span class="line">        warn(</span><br><span class="line">          &#96;method &quot;$&#123;key&#125;&quot; has already been defined as a prop.&#96;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="initData"><a href="#initData" class="headerlink" title="initData"></a>initData</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function initData (vm: Component) &#123;</span><br><span class="line">  let data &#x3D; vm.$options.data</span><br><span class="line">  data &#x3D; vm._data &#x3D; typeof data &#x3D;&#x3D;&#x3D; &#39;function&#39;</span><br><span class="line">    ? getData(data, vm) &#x2F;&#x2F; data.call(vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line">  if (!isPlainObject(data)) &#123; &#x2F;&#x2F; typeof is &#39;object&#39; ?</span><br><span class="line">    data &#x3D; &#123;&#125;</span><br><span class="line">    process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; warn(</span><br><span class="line">      &#39;data functions should return an object:\n&#39; +</span><br><span class="line">      &#39;https:&#x2F;&#x2F;vuejs.org&#x2F;v2&#x2F;guide&#x2F;components.html#data-Must-Be-a-Function&#39;,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; proxy data on instance</span><br><span class="line">  const keys &#x3D; Object.keys(data)</span><br><span class="line">  const props &#x3D; vm.$options.props</span><br><span class="line">  let i &#x3D; keys.length</span><br><span class="line">  while (i--) &#123;</span><br><span class="line">    if (props &amp;&amp; hasOwn(props, keys[i])) &#123; &#x2F;&#x2F; 判断props是否已有key</span><br><span class="line">      process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; warn(</span><br><span class="line">        &#96;The data property &quot;$&#123;keys[i]&#125;&quot; is already declared as a prop. &#96; +</span><br><span class="line">        &#96;Use prop default value instead.&#96;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; else if (!isReserved(keys[i])) &#123; &#x2F;&#x2F; 不以$ _ 开头</span><br><span class="line">      proxy(vm, &#96;_data&#96;, keys[i]) &#x2F;&#x2F; 设置了vm[key], vm._data[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; observe data</span><br><span class="line">  observe(data, true &#x2F;* asRootData *&#x2F;) &#x2F;&#x2F; 监听数据 data.__ob__ &#x3D; new Observer(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先得到一个至少是{}的 object 类型的 data 数据，遍历 data，设置了 vm[key], vm._data[key]，最后给 data 设置了监听,具体什么用暂时未知</p>
<h3 id="initComputed"><a href="#initComputed" class="headerlink" title="initComputed"></a>initComputed</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function initComputed (vm: Component, computed: Object) &#123;</span><br><span class="line">  const watchers &#x3D; vm._computedWatchers &#x3D; Object.create(null)</span><br><span class="line"></span><br><span class="line">  for (const key in computed) &#123;</span><br><span class="line">    const userDef &#x3D; computed[key]</span><br><span class="line">    let getter &#x3D; typeof userDef &#x3D;&#x3D;&#x3D; &#39;function&#39; ? userDef : userDef.get</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      if (getter &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#96;No getter function has been defined for computed property &quot;$&#123;key&#125;&quot;.&#96;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">        getter &#x3D; noop</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; create internal watcher for the computed property.</span><br><span class="line">    &#x2F;&#x2F; 为computed属性添加watcher</span><br><span class="line">    watchers[key] &#x3D; new Watcher(vm, getter, noop, computedWatcherOptions)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; component-defined computed properties are already defined on the</span><br><span class="line">    &#x2F;&#x2F; component prototype. We only need to define computed properties defined</span><br><span class="line">    &#x2F;&#x2F; at instantiation here.</span><br><span class="line">    if (!(key in vm)) &#123; &#x2F;&#x2F; computed属性只能定义在computed，不能和data，props等属性重复</span><br><span class="line">      defineComputed(vm, key, userDef) &#x2F;&#x2F; watcher.evaluate()看到这一步，下面再来细看</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="initWatch"><a href="#initWatch" class="headerlink" title="initWatch"></a>initWatch</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function initWatch (vm: Component, watch: Object) &#123;</span><br><span class="line">  for (const key in watch) &#123;</span><br><span class="line">    const handler &#x3D; watch[key]</span><br><span class="line">    if (Array.isArray(handler)) &#123;</span><br><span class="line">      for (let i &#x3D; 0; i &lt; handler.length; i++) &#123;</span><br><span class="line">        createWatcher(vm, key, handler[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      createWatcher(vm, key, handler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createWatcher (vm: Component, key: string, handler: any) &#123;</span><br><span class="line">  let options</span><br><span class="line">  if (isPlainObject(handler)) &#123;</span><br><span class="line">    options &#x3D; handler</span><br><span class="line">    handler &#x3D; handler.handler</span><br><span class="line">  &#125;</span><br><span class="line">  if (typeof handler &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">    handler &#x3D; vm[handler]</span><br><span class="line">  &#125;</span><br><span class="line">  vm.$watch(key, handler, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了 vm.$watch</p>
<h3 id="initProvide"><a href="#initProvide" class="headerlink" title="initProvide"></a>initProvide</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function initProvide (vm: Component) &#123;</span><br><span class="line">  const provide &#x3D; vm.$options.provide</span><br><span class="line">  if (provide) &#123;</span><br><span class="line">    vm._provided &#x3D; typeof provide &#x3D;&#x3D;&#x3D; &#39;function&#39;</span><br><span class="line">      ? provide.call(vm)</span><br><span class="line">      : provide</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mount"><a href="#mount" class="headerlink" title="$mount"></a>$mount</h2><p>vm.$mount(vm.$options.el)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$mount &#x3D; function (</span><br><span class="line">  el?: string | Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  el &#x3D; el &amp;&amp; query(el) &#x2F;&#x2F; query基本等于doucment.querySelecter</span><br><span class="line"></span><br><span class="line">  &#x2F;* istanbul ignore if || Do not mount Vue to &lt;html&gt; or &lt;body&gt;  *&#x2F;</span><br><span class="line">  if (el &#x3D;&#x3D;&#x3D; document.body || el &#x3D;&#x3D;&#x3D; document.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; warn(</span><br><span class="line">      &#96;Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.&#96;</span><br><span class="line">    )</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const options &#x3D; this.$options</span><br><span class="line">  console.log(options.render) &#x2F;&#x2F; 在这里是undefined</span><br><span class="line">  &#x2F;&#x2F; resolve template&#x2F;el and convert to render function</span><br><span class="line">  if (!options.render) &#123;</span><br><span class="line">    let template &#x3D; options.template</span><br><span class="line">    console.log(template) &#x2F;&#x2F; undefined</span><br><span class="line">    if (template) &#123;</span><br><span class="line">      if (typeof template &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">        if (template.charAt(0) &#x3D;&#x3D;&#x3D; &#39;#&#39;) &#123;</span><br><span class="line">          template &#x3D; idToTemplate(template)</span><br><span class="line">          &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">          if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; !template) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              &#96;Template element not found or is empty: $&#123;options.template&#125;&#96;,</span><br><span class="line">              this</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (template.nodeType) &#123;</span><br><span class="line">        template &#x3D; template.innerHTML</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">          warn(&#39;invalid template option:&#39; + template, this)</span><br><span class="line">        &#125;</span><br><span class="line">        return this</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (el) &#123;</span><br><span class="line">      template &#x3D; getOuterHTML(el) &#x2F;&#x2F; el.outerHTML</span><br><span class="line">    &#125;</span><br><span class="line">    if (template) &#123;</span><br><span class="line">      &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(&#39;compile&#39;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const &#123; render, staticRenderFns &#125; &#x3D; compileToFunctions(template, &#123;</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        delimiters: options.delimiters</span><br><span class="line">      &#125;, this)</span><br><span class="line">      options.render &#x3D; render</span><br><span class="line">      options.staticRenderFns &#x3D; staticRenderFns</span><br><span class="line"></span><br><span class="line">      &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(&#39;compile end&#39;)</span><br><span class="line">        measure(&#96;$&#123;this._name&#125; compile&#96;, &#39;compile&#39;, &#39;compile end&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return mount.call(this, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="compileToFunctions"><a href="#compileToFunctions" class="headerlink" title="compileToFunctions"></a>compileToFunctions</h3><p>一步套一步，最重要的是 Convert HTML string to AST(转换 ast)的过程，先是 parse 方法，这里面调用了 parseHTML 的方法<br>注： /src/platforms/web/compiler/index.js options 里的基本属性在这个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Convert HTML string to AST.</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function parse (</span><br><span class="line">  template: string,</span><br><span class="line">  options: CompilerOptions</span><br><span class="line">): ASTElement | void &#123;</span><br><span class="line">  warn &#x3D; options.warn || baseWarn</span><br><span class="line">  platformGetTagNamespace &#x3D; options.getTagNamespace || no</span><br><span class="line">  platformMustUseProp &#x3D; options.mustUseProp || no</span><br><span class="line">  platformIsPreTag &#x3D; options.isPreTag || no</span><br><span class="line">  preTransforms &#x3D; pluckModuleFunction(options.modules, &#39;preTransformNode&#39;)</span><br><span class="line">  transforms &#x3D; pluckModuleFunction(options.modules, &#39;transformNode&#39;)</span><br><span class="line">  postTransforms &#x3D; pluckModuleFunction(options.modules, &#39;postTransformNode&#39;)</span><br><span class="line">  delimiters &#x3D; options.delimiters</span><br><span class="line">  console.log(options.modules)</span><br><span class="line">  const stack &#x3D; []</span><br><span class="line">  const preserveWhitespace &#x3D; options.preserveWhitespace !&#x3D;&#x3D; false</span><br><span class="line">  let root</span><br><span class="line">  let currentParent</span><br><span class="line">  let inVPre &#x3D; false</span><br><span class="line">  let inPre &#x3D; false</span><br><span class="line">  let warned &#x3D; false</span><br><span class="line"></span><br><span class="line">  function warnOnce (msg) &#123;</span><br><span class="line">    if (!warned) &#123;</span><br><span class="line">      warned &#x3D; true</span><br><span class="line">      warn(msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function endPre (element) &#123;</span><br><span class="line">    &#x2F;&#x2F; check pre state</span><br><span class="line">    if (element.pre) &#123;</span><br><span class="line">      inVPre &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line">    if (platformIsPreTag(element.tag)) &#123;</span><br><span class="line">      inPre &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  parseHTML(template, &#123;</span><br><span class="line">    warn,</span><br><span class="line">    expectHTML: options.expectHTML,</span><br><span class="line">    isUnaryTag: options.isUnaryTag,</span><br><span class="line">    canBeLeftOpenTag: options.canBeLeftOpenTag,</span><br><span class="line">    shouldDecodeNewlines: options.shouldDecodeNewlines,</span><br><span class="line">    start (tag, attrs, unary) &#123;</span><br><span class="line">      &#x2F;&#x2F; check namespace.</span><br><span class="line">      &#x2F;&#x2F; inherit parent ns if there is one</span><br><span class="line">      const ns &#x3D; (currentParent &amp;&amp; currentParent.ns) || platformGetTagNamespace(tag)</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; handle IE svg bug</span><br><span class="line">      &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">      if (isIE &amp;&amp; ns &#x3D;&#x3D;&#x3D; &#39;svg&#39;) &#123;</span><br><span class="line">        attrs &#x3D; guardIESVGBug(attrs)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const element: ASTElement &#x3D; &#123;</span><br><span class="line">        type: 1,</span><br><span class="line">        tag,</span><br><span class="line">        attrsList: attrs,</span><br><span class="line">        attrsMap: makeAttrsMap(attrs),</span><br><span class="line">        parent: currentParent,</span><br><span class="line">        children: []</span><br><span class="line">      &#125;</span><br><span class="line">      if (ns) &#123;</span><br><span class="line">        element.ns &#x3D; ns</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 判断是不是style或者script</span><br><span class="line">      if (isForbiddenTag(element) &amp;&amp; !isServerRendering()) &#123;</span><br><span class="line">        element.forbidden &#x3D; true</span><br><span class="line">        process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; warn(</span><br><span class="line">          &#39;Templates should only be responsible for mapping the state to the &#39; +</span><br><span class="line">          &#39;UI. Avoid placing tags with side-effects in your templates, such as &#39; +</span><br><span class="line">          &#96;&lt;$&#123;tag&#125;&gt;&#96; + &#39;, as they will not be parsed.&#39;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; apply pre-transforms</span><br><span class="line">      for (let i &#x3D; 0; i &lt; preTransforms.length; i++) &#123;</span><br><span class="line">        preTransforms[i](element, options)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!inVPre) &#123; &#x2F;&#x2F; 是不是v-pre?</span><br><span class="line">        processPre(element)</span><br><span class="line">        if (element.pre) &#123;</span><br><span class="line">          inVPre &#x3D; true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (platformIsPreTag(element.tag)) &#123; &#x2F;&#x2F; 是不是pre标签</span><br><span class="line">        inPre &#x3D; true</span><br><span class="line">      &#125;</span><br><span class="line">      if (inVPre) &#123;</span><br><span class="line">        processRawAttrs(element)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; debugger</span><br><span class="line">        processFor(element) &#x2F;&#x2F; 检测v-for 详细阅读等到单独再看，下同</span><br><span class="line">        processIf(element) &#x2F;&#x2F; 检测v-if</span><br><span class="line">        processOnce(element) &#x2F;&#x2F; 检测v-once</span><br><span class="line">        processKey(element) &#x2F;&#x2F; 检测key属性</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; determine whether this is a plain element after</span><br><span class="line">        &#x2F;&#x2F; removing structural attributes</span><br><span class="line">        element.plain &#x3D; !element.key &amp;&amp; !attrs.length</span><br><span class="line"></span><br><span class="line">        processRef(element) &#x2F;&#x2F; 检测ref属性</span><br><span class="line">        processSlot(element) &#x2F;&#x2F; 检测slot属性</span><br><span class="line">        processComponent(element) &#x2F;&#x2F; 检测is属性</span><br><span class="line">        for (let i &#x3D; 0; i &lt; transforms.length; i++) &#123;</span><br><span class="line">          transforms[i](element, options) &#x2F;&#x2F; 检测class和style</span><br><span class="line">        &#125;</span><br><span class="line">        processAttrs(element) &#x2F;&#x2F; 检测attr</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      function checkRootConstraints (el) &#123;</span><br><span class="line">        if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">          if (el.tag &#x3D;&#x3D;&#x3D; &#39;slot&#39; || el.tag &#x3D;&#x3D;&#x3D; &#39;template&#39;) &#123;</span><br><span class="line">            warnOnce(</span><br><span class="line">              &#96;Cannot use &lt;$&#123;el.tag&#125;&gt; as component root element because it may &#96; +</span><br><span class="line">              &#39;contain multiple nodes.&#39;</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">          if (el.attrsMap.hasOwnProperty(&#39;v-for&#39;)) &#123;</span><br><span class="line">            warnOnce(</span><br><span class="line">              &#39;Cannot use v-for on stateful component root element because &#39; +</span><br><span class="line">              &#39;it renders multiple elements.&#39;</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; tree management</span><br><span class="line">      if (!root) &#123;</span><br><span class="line">        root &#x3D; element</span><br><span class="line">        checkRootConstraints(root) &#x2F;&#x2F; 检测根节点的合法性</span><br><span class="line">      &#125; else if (!stack.length) &#123;</span><br><span class="line">        &#x2F;&#x2F; allow root elements with v-if, v-else-if and v-else</span><br><span class="line">        if (root.if &amp;&amp; (element.elseif || element.else)) &#123;</span><br><span class="line">          checkRootConstraints(element)</span><br><span class="line">          addIfCondition(root, &#123;</span><br><span class="line">            exp: element.elseif,</span><br><span class="line">            block: element</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; else if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">          warnOnce(</span><br><span class="line">            &#96;Component template should contain exactly one root element. &#96; +</span><br><span class="line">            &#96;If you are using v-if on multiple elements, &#96; +</span><br><span class="line">            &#96;use v-else-if to chain them instead.&#96;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (currentParent &amp;&amp; !element.forbidden) &#123;</span><br><span class="line">        if (element.elseif || element.else) &#123;</span><br><span class="line">          processIfConditions(element, currentParent)</span><br><span class="line">        &#125; else if (element.slotScope) &#123; &#x2F;&#x2F; scoped slot</span><br><span class="line">          currentParent.plain &#x3D; false</span><br><span class="line">          const name &#x3D; element.slotTarget || &#39;&quot;default&quot;&#39;</span><br><span class="line">          ;(currentParent.scopedSlots || (currentParent.scopedSlots &#x3D; &#123;&#125;))[name] &#x3D; element</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          currentParent.children.push(element) &#x2F;&#x2F; 添加子节点</span><br><span class="line">          element.parent &#x3D; currentParent &#x2F;&#x2F; 指向父节点</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (!unary) &#123;</span><br><span class="line">        currentParent &#x3D; element</span><br><span class="line">        stack.push(element)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        endPre(element)</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; apply post-transforms</span><br><span class="line">      for (let i &#x3D; 0; i &lt; postTransforms.length; i++) &#123;</span><br><span class="line">        postTransforms[i](element, options)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    end () &#123;</span><br><span class="line">      &#x2F;&#x2F; remove trailing whitespace</span><br><span class="line">      const element &#x3D; stack[stack.length - 1]</span><br><span class="line">      const lastNode &#x3D; element.children[element.children.length - 1]</span><br><span class="line">      if (lastNode &amp;&amp; lastNode.type &#x3D;&#x3D;&#x3D; 3 &amp;&amp; lastNode.text &#x3D;&#x3D;&#x3D; &#39; &#39; &amp;&amp; !inPre) &#123;</span><br><span class="line">        element.children.pop()</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; pop stack</span><br><span class="line">      stack.length -&#x3D; 1</span><br><span class="line">      currentParent &#x3D; stack[stack.length - 1]</span><br><span class="line">      endPre(element) &#x2F;&#x2F; 如果有pre指令，做相关操作</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    chars (text: string) &#123;</span><br><span class="line">      if (!currentParent) &#123; &#x2F;&#x2F; 没有currentParent表示text在前面，类似于xxx&lt;xxx&gt;&lt;&#x2F;xxx&gt;这样的</span><br><span class="line">        if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">          if (text &#x3D;&#x3D;&#x3D; template) &#123;</span><br><span class="line">            warnOnce(</span><br><span class="line">              &#39;Component template requires a root element, rather than just text.&#39;</span><br><span class="line">            )</span><br><span class="line">          &#125; else if ((text &#x3D; text.trim())) &#123;</span><br><span class="line">            warnOnce(</span><br><span class="line">              &#96;text &quot;$&#123;text&#125;&quot; outside root element will be ignored.&#96;</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; IE textarea placeholder bug</span><br><span class="line">      &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">      if (isIE &amp;&amp;</span><br><span class="line">          currentParent.tag &#x3D;&#x3D;&#x3D; &#39;textarea&#39; &amp;&amp;</span><br><span class="line">          currentParent.attrsMap.placeholder &#x3D;&#x3D;&#x3D; text) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      const children &#x3D; currentParent.children</span><br><span class="line">      text &#x3D; inPre || text.trim()</span><br><span class="line">        ? decodeHTMLCached(text)</span><br><span class="line">        &#x2F;&#x2F; only preserve whitespace if its not right after a starting tag</span><br><span class="line">        : preserveWhitespace &amp;&amp; children.length ? &#39; &#39; : &#39;&#39;</span><br><span class="line">      if (text) &#123;</span><br><span class="line">        let expression</span><br><span class="line">        if (!inVPre &amp;&amp; text !&#x3D;&#x3D; &#39; &#39; &amp;&amp; (expression &#x3D; parseText(text, delimiters))) &#123; &#x2F;&#x2F; 表达式解析</span><br><span class="line">          children.push(&#123;</span><br><span class="line">            type: 2,</span><br><span class="line">            expression,</span><br><span class="line">            text</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; else if (text !&#x3D;&#x3D; &#39; &#39; || !children.length || children[children.length - 1].text !&#x3D;&#x3D; &#39; &#39;) &#123;</span><br><span class="line">          children.push(&#123;</span><br><span class="line">            type: 3,</span><br><span class="line">            text</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">export function parseHTML (html, options) &#123;</span><br><span class="line">  const stack &#x3D; []</span><br><span class="line">  const expectHTML &#x3D; options.expectHTML</span><br><span class="line">  const isUnaryTag &#x3D; options.isUnaryTag || no</span><br><span class="line">  const canBeLeftOpenTag &#x3D; options.canBeLeftOpenTag || no</span><br><span class="line">  let index &#x3D; 0</span><br><span class="line">  let last, lastTag</span><br><span class="line">  while (html) &#123; &#x2F;&#x2F; html是&#39;&lt;xxx&gt;xxxx&lt;&#x2F;xxx&gt;&#39;</span><br><span class="line">    debugger</span><br><span class="line">    last &#x3D; html</span><br><span class="line">    &#x2F;&#x2F; Make sure we&#39;re not in a plaintext content element like script&#x2F;style</span><br><span class="line">    if (!lastTag || !isPlainTextElement(lastTag)) &#123;</span><br><span class="line">      let textEnd &#x3D; html.indexOf(&#39;&lt;&#39;) &#x2F;&#x2F; 以&lt;开头</span><br><span class="line">      if (textEnd &#x3D;&#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 起始位</span><br><span class="line">        &#x2F;&#x2F; Comment:</span><br><span class="line">        if (comment.test(html)) &#123; &#x2F;&#x2F; 注释</span><br><span class="line">          const commentEnd &#x3D; html.indexOf(&#39;--&gt;&#39;)</span><br><span class="line"></span><br><span class="line">          if (commentEnd &gt;&#x3D; 0) &#123;</span><br><span class="line">            advance(commentEnd + 3)</span><br><span class="line">            continue</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; http:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Conditional_comment#Downlevel-revealed_conditional_comment</span><br><span class="line">        if (conditionalComment.test(html)) &#123; &#x2F;&#x2F; xml?</span><br><span class="line">          const conditionalEnd &#x3D; html.indexOf(&#39;]&gt;&#39;)</span><br><span class="line"></span><br><span class="line">          if (conditionalEnd &gt;&#x3D; 0) &#123;</span><br><span class="line">            advance(conditionalEnd + 2)</span><br><span class="line">            continue</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Doctype:</span><br><span class="line">        const doctypeMatch &#x3D; html.match(doctype)</span><br><span class="line">        if (doctypeMatch) &#123;</span><br><span class="line">          advance(doctypeMatch[0].length)</span><br><span class="line">          continue</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; End tag:</span><br><span class="line">        const endTagMatch &#x3D; html.match(endTag) &#x2F;&#x2F; 结束标签&lt;&#x2F;xxx&gt;</span><br><span class="line">        if (endTagMatch) &#123;</span><br><span class="line">          const curIndex &#x3D; index</span><br><span class="line">          advance(endTagMatch[0].length)</span><br><span class="line">          parseEndTag(endTagMatch[1], curIndex, index)</span><br><span class="line">          continue</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Start tag:</span><br><span class="line">        const startTagMatch &#x3D; parseStartTag() &#x2F;&#x2F; 开始标签&lt;xxx&gt;</span><br><span class="line">        if (startTagMatch) &#123;</span><br><span class="line">          handleStartTag(startTagMatch)</span><br><span class="line">          continue</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; html不以&lt;开头</span><br><span class="line">      let text, rest, next</span><br><span class="line">      if (textEnd &gt;&#x3D; 0) &#123; &#x2F;&#x2F; html中还存在&lt;</span><br><span class="line">        rest &#x3D; html.slice(textEnd)</span><br><span class="line">        while (</span><br><span class="line">          !endTag.test(rest) &amp;&amp;</span><br><span class="line">          !startTagOpen.test(rest) &amp;&amp;</span><br><span class="line">          !comment.test(rest) &amp;&amp;</span><br><span class="line">          !conditionalComment.test(rest)</span><br><span class="line">        ) &#123;</span><br><span class="line">          &#x2F;&#x2F; &lt; in plain text, be forgiving and treat it as text</span><br><span class="line">          next &#x3D; rest.indexOf(&#39;&lt;&#39;, 1)</span><br><span class="line">          if (next &lt; 0) break</span><br><span class="line">          textEnd +&#x3D; next</span><br><span class="line">          rest &#x3D; html.slice(textEnd)</span><br><span class="line">        &#125;</span><br><span class="line">        text &#x3D; html.substring(0, textEnd) &#x2F;&#x2F; 截取到&lt;前的部分</span><br><span class="line">        advance(textEnd)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (textEnd &lt; 0) &#123;</span><br><span class="line">        text &#x3D; html</span><br><span class="line">        html &#x3D; &#39;&#39;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (options.chars &amp;&amp; text) &#123;</span><br><span class="line">        options.chars(text)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      var stackedTag &#x3D; lastTag.toLowerCase()</span><br><span class="line">      var reStackedTag &#x3D; reCache[stackedTag] || (reCache[stackedTag] &#x3D; new RegExp(&#39;([\\s\\S]*?)(&lt;&#x2F;&#39; + stackedTag + &#39;[^&gt;]*&gt;)&#39;, &#39;i&#39;))</span><br><span class="line">      var endTagLength &#x3D; 0</span><br><span class="line">      var rest &#x3D; html.replace(reStackedTag, function (all, text, endTag) &#123;</span><br><span class="line">        endTagLength &#x3D; endTag.length</span><br><span class="line">        if (!isPlainTextElement(stackedTag) &amp;&amp; stackedTag !&#x3D;&#x3D; &#39;noscript&#39;) &#123;</span><br><span class="line">          text &#x3D; text</span><br><span class="line">            .replace(&#x2F;&lt;!--([\s\S]*?)--&gt;&#x2F;g, &#39;$1&#39;)</span><br><span class="line">            .replace(&#x2F;&lt;!\[CDATA\[([\s\S]*?)]]&gt;&#x2F;g, &#39;$1&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">        if (options.chars) &#123;</span><br><span class="line">          options.chars(text)</span><br><span class="line">        &#125;</span><br><span class="line">        return &#39;&#39;</span><br><span class="line">      &#125;)</span><br><span class="line">      index +&#x3D; html.length - rest.length</span><br><span class="line">      html &#x3D; rest</span><br><span class="line">      parseEndTag(stackedTag, index - endTagLength, index)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (html &#x3D;&#x3D;&#x3D; last) &#123;</span><br><span class="line">      options.chars &amp;&amp; options.chars(html)</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; !stack.length &amp;&amp; options.warn) &#123;</span><br><span class="line">        options.warn(&#96;Mal-formatted tag at end of template: &quot;$&#123;html&#125;&quot;&#96;)</span><br><span class="line">      &#125;</span><br><span class="line">      break</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Clean up any remaining tags 清除剩余的标签，这里因该是清除了不合法的标签，如只有单个的p标签之类的</span><br><span class="line">  parseEndTag()</span><br><span class="line"></span><br><span class="line">  function advance (n) &#123;</span><br><span class="line">    index +&#x3D; n</span><br><span class="line">    html &#x3D; html.substring(n) &#x2F;&#x2F; html截取</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function parseStartTag () &#123;</span><br><span class="line">    const start &#x3D; html.match(startTagOpen)</span><br><span class="line">    console.log(start)</span><br><span class="line">    if (start) &#123;</span><br><span class="line">      const match &#x3D; &#123;</span><br><span class="line">        tagName: start[1], &#x2F;&#x2F; 标签名</span><br><span class="line">        attrs: [],</span><br><span class="line">        start: index &#x2F;&#x2F; 起始位置</span><br><span class="line">      &#125;</span><br><span class="line">      advance(start[0].length)</span><br><span class="line">      let end, attr</span><br><span class="line">      while (!(end &#x3D; html.match(startTagClose)) &amp;&amp; (attr &#x3D; html.match(attribute))) &#123;</span><br><span class="line">        &#x2F;&#x2F; end匹配标签末尾&gt; attr匹配该标签的属性</span><br><span class="line">        advance(attr[0].length)</span><br><span class="line">        match.attrs.push(attr) &#x2F;&#x2F; 添加属性</span><br><span class="line">      &#125;</span><br><span class="line">      if (end) &#123;</span><br><span class="line">        match.unarySlash &#x3D; end[1]</span><br><span class="line">        advance(end[0].length)</span><br><span class="line">        match.end &#x3D; index &#x2F;&#x2F; 标签末尾的位置</span><br><span class="line">        return match</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function handleStartTag (match) &#123;</span><br><span class="line">    const tagName &#x3D; match.tagName &#x2F;&#x2F; 标签名</span><br><span class="line">    const unarySlash &#x3D; match.unarySlash</span><br><span class="line"></span><br><span class="line">    if (expectHTML) &#123;</span><br><span class="line">      if (lastTag &#x3D;&#x3D;&#x3D; &#39;p&#39; &amp;&amp; isNonPhrasingTag(tagName)) &#123; &#x2F;&#x2F; isNonPhrasingTag：判断标签是不是集合(这个集合代表什么暂时不清楚)内的标签</span><br><span class="line">        parseEndTag(lastTag)</span><br><span class="line">      &#125;</span><br><span class="line">      if (canBeLeftOpenTag(tagName) &amp;&amp; lastTag &#x3D;&#x3D;&#x3D; tagName) &#123;</span><br><span class="line">        parseEndTag(tagName)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const unary &#x3D; isUnaryTag(tagName) || tagName &#x3D;&#x3D;&#x3D; &#39;html&#39; &amp;&amp; lastTag &#x3D;&#x3D;&#x3D; &#39;head&#39; || !!unarySlash</span><br><span class="line"></span><br><span class="line">    const l &#x3D; match.attrs.length</span><br><span class="line">    const attrs &#x3D; new Array(l)</span><br><span class="line">    for (let i &#x3D; 0; i &lt; l; i++) &#123;</span><br><span class="line">      const args &#x3D; match.attrs[i]</span><br><span class="line">      &#x2F;&#x2F; hackish work around FF bug https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id&#x3D;369778</span><br><span class="line">      if (IS_REGEX_CAPTURING_BROKEN &amp;&amp; args[0].indexOf(&#39;&quot;&quot;&#39;) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">        if (args[3] &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123; delete args[3] &#125;</span><br><span class="line">        if (args[4] &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123; delete args[4] &#125;</span><br><span class="line">        if (args[5] &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123; delete args[5] &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      const value &#x3D; args[3] || args[4] || args[5] || &#39;&#39;</span><br><span class="line">      attrs[i] &#x3D; &#123;</span><br><span class="line">        name: args[1],</span><br><span class="line">        value: decodeAttr(</span><br><span class="line">          value,</span><br><span class="line">          options.shouldDecodeNewlines</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!unary) &#123;</span><br><span class="line">      stack.push(&#123; tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs &#125;)</span><br><span class="line">      lastTag &#x3D; tagName</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (options.start) &#123;</span><br><span class="line">      options.start(tagName, attrs, unary, match.start, match.end)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function parseEndTag (tagName, start, end) &#123;</span><br><span class="line">    let pos, lowerCasedTagName</span><br><span class="line">    if (start &#x3D;&#x3D; null) start &#x3D; index</span><br><span class="line">    if (end &#x3D;&#x3D; null) end &#x3D; index</span><br><span class="line"></span><br><span class="line">    if (tagName) &#123;</span><br><span class="line">      lowerCasedTagName &#x3D; tagName.toLowerCase()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Find the closest opened tag of the same type</span><br><span class="line">    if (tagName) &#123; &#x2F;&#x2F; 找到和闭合标签对应的开始标签 &lt;&#x2F;p&gt; --&gt; &lt;p&gt;</span><br><span class="line">      for (pos &#x3D; stack.length - 1; pos &gt;&#x3D; 0; pos--) &#123;</span><br><span class="line">        if (stack[pos].lowerCasedTag &#x3D;&#x3D;&#x3D; lowerCasedTagName) &#123;</span><br><span class="line">          break</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; If no tag name is provided, clean shop</span><br><span class="line">      pos &#x3D; 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (pos &gt;&#x3D; 0) &#123;</span><br><span class="line">      &#x2F;&#x2F; Close all the open elements, up the stack</span><br><span class="line">      for (let i &#x3D; stack.length - 1; i &gt;&#x3D; pos; i--) &#123;</span><br><span class="line">        if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp;</span><br><span class="line">            (i &gt; pos || !tagName) &amp;&amp;</span><br><span class="line">            options.warn) &#123;</span><br><span class="line">          options.warn(</span><br><span class="line">            &#96;tag &lt;$&#123;stack[i].tag&#125;&gt; has no matching end tag.&#96;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        if (options.end) &#123;</span><br><span class="line">          options.end(stack[i].tag, start, end)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Remove the open elements from the stack</span><br><span class="line">      stack.length &#x3D; pos</span><br><span class="line">      lastTag &#x3D; pos &amp;&amp; stack[pos - 1].tag</span><br><span class="line">    &#125; else if (lowerCasedTagName &#x3D;&#x3D;&#x3D; &#39;br&#39;) &#123;</span><br><span class="line">      if (options.start) &#123;</span><br><span class="line">        options.start(tagName, [], true, start, end)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (lowerCasedTagName &#x3D;&#x3D;&#x3D; &#39;p&#39;) &#123;</span><br><span class="line">      if (options.start) &#123;</span><br><span class="line">        options.start(tagName, [], false, start, end)</span><br><span class="line">      &#125;</span><br><span class="line">      if (options.end) &#123;</span><br><span class="line">        options.end(tagName, start, end)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一层一层的解析 html，从<div><p></p></div> –&gt; <p></p></div> –&gt; … –&gt; </div>, 把每一个标签所含的属性、指令等提取出来，放在一个对象中，最终返回下面结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: 1,</span><br><span class="line">  tag: &#39;div&#39;,</span><br><span class="line">  plain: false,</span><br><span class="line">  parent: undefined,</span><br><span class="line">  attrs: [&#123;name:&#39;id&#39;, value: &#39;&quot;app&quot;&#39;&#125;],</span><br><span class="line">  attrsList: [&#123;name:&#39;id&#39;, value: &#39;app&#39;&#125;],</span><br><span class="line">  attrsMap: &#123;id: &#39;app&#39;&#125;,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    type: 1,</span><br><span class="line">    tag: &#39;p&#39;,</span><br><span class="line">    plain: true,</span><br><span class="line">    parent: ast,</span><br><span class="line">    attrs: [],</span><br><span class="line">    attrsList: [],</span><br><span class="line">    attrsMap: &#123;&#125;,</span><br><span class="line">    children: [&#123;</span><br><span class="line">      expression: &quot;_s(message)&quot;,</span><br><span class="line">      text: &quot;&#123;&#123;message&#125;&#125;&quot;,</span><br><span class="line">      type: 2</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是静态节点的判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Goal of the optimizer: walk the generated template AST tree</span><br><span class="line"> * and detect sub-trees that are purely static, i.e. parts of</span><br><span class="line"> * the DOM that never needs to change.</span><br><span class="line"> * 删除ast中的静态（永远不会改变的）节点？</span><br><span class="line"> * Once we detect these sub-trees, we can: 优点</span><br><span class="line"> *</span><br><span class="line"> * 1. Hoist them into constants, so that we no longer need to</span><br><span class="line"> *    create fresh nodes for them on each re-render;</span><br><span class="line"> *    在重新渲染的时候不用再去管这些节点</span><br><span class="line"> * 2. Completely skip them in the patching process.在修补的时候无视他们？</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function optimize (root: ?ASTElement, options: CompilerOptions) &#123;</span><br><span class="line">  &#x2F;&#x2F; debugger</span><br><span class="line">  if (!root) return</span><br><span class="line">  isStaticKey &#x3D; genStaticKeysCached(options.staticKeys || &#39;&#39;)</span><br><span class="line">  isPlatformReservedTag &#x3D; options.isReservedTag || no</span><br><span class="line">  &#x2F;&#x2F; first pass: mark all non-static nodes.</span><br><span class="line">  markStatic(root)</span><br><span class="line">  &#x2F;&#x2F; second pass: mark static roots.</span><br><span class="line">  markStaticRoots(root, false)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 得到结果</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  type: 1,</span><br><span class="line">  tag: &#39;div&#39;,</span><br><span class="line">  plain: false,</span><br><span class="line">  parent: undefined,</span><br><span class="line">  attrs: [&#123;name:&#39;id&#39;, value: &#39;&quot;app&quot;&#39;&#125;],</span><br><span class="line">  attrsList: [&#123;name:&#39;id&#39;, value: &#39;app&#39;&#125;],</span><br><span class="line">  attrsMap: &#123;id: &#39;app&#39;&#125;,</span><br><span class="line">  static: false,</span><br><span class="line">  staticRoot: false,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    type: 1,</span><br><span class="line">    tag: &#39;p&#39;,</span><br><span class="line">    plain: true,</span><br><span class="line">    parent: ast,</span><br><span class="line">    attrs: [],</span><br><span class="line">    attrsList: [],</span><br><span class="line">    attrsMap: &#123;&#125;,</span><br><span class="line">    static: false,</span><br><span class="line">    staticRoot: false,</span><br><span class="line">    children: [&#123;</span><br><span class="line">      expression: &quot;_s(message)&quot;,</span><br><span class="line">      text: &quot;&#123;&#123;message&#125;&#125;&quot;,</span><br><span class="line">      type: 2,</span><br><span class="line">      static: false</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; ps:按照例子其实children里有更多项的，但我不知道怎么复制打印出来的对象，就用了别人的输出</span><br></pre></td></tr></table></figure>

<p>optimize 通过遍历 ast，主要判断了节点是不是 static(markStatic 方法)，staticRoot(markStaticRoots 方法)，<br>接下去是进行 generate 处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function generate (</span><br><span class="line">  ast: ASTElement | void,</span><br><span class="line">  options: CompilerOptions</span><br><span class="line">): &#123;</span><br><span class="line">  render: string,</span><br><span class="line">  staticRenderFns: Array&lt;string&gt;</span><br><span class="line">&#125; &#123;</span><br><span class="line">  &#x2F;&#x2F; save previous staticRenderFns so generate calls can be nested</span><br><span class="line">  const prevStaticRenderFns: Array&lt;string&gt; &#x3D; staticRenderFns</span><br><span class="line">  const currentStaticRenderFns: Array&lt;string&gt; &#x3D; staticRenderFns &#x3D; []</span><br><span class="line">  const prevOnceCount &#x3D; onceCount</span><br><span class="line">  onceCount &#x3D; 0</span><br><span class="line">  currentOptions &#x3D; options</span><br><span class="line">  warn &#x3D; options.warn || baseWarn</span><br><span class="line">  transforms &#x3D; pluckModuleFunction(options.modules, &#39;transformCode&#39;)</span><br><span class="line">  dataGenFns &#x3D; pluckModuleFunction(options.modules, &#39;genData&#39;)</span><br><span class="line">  platformDirectives &#x3D; options.directives || &#123;&#125;</span><br><span class="line">  isPlatformReservedTag &#x3D; options.isReservedTag || no</span><br><span class="line">  const code &#x3D; ast ? genElement(ast) : &#39;_c(&quot;div&quot;)&#39; &#x2F;&#x2F; 生成render函数</span><br><span class="line">  staticRenderFns &#x3D; prevStaticRenderFns</span><br><span class="line">  onceCount &#x3D; prevOnceCount</span><br><span class="line">  return &#123;</span><br><span class="line">    render: &#96;with(this)&#123;return $&#123;code&#125;&#125;&#96;,</span><br><span class="line">    staticRenderFns: currentStaticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genElement (el: ASTElement): string &#123;</span><br><span class="line">  if (el.staticRoot &amp;&amp; !el.staticProcessed) &#123;</span><br><span class="line">    return genStatic(el) &#x2F;&#x2F; static render</span><br><span class="line">  &#125; else if (el.once &amp;&amp; !el.onceProcessed) &#123;</span><br><span class="line">    return genOnce(el) &#x2F;&#x2F; once render</span><br><span class="line">  &#125; else if (el.for &amp;&amp; !el.forProcessed) &#123;</span><br><span class="line">    return genFor(el) &#x2F;&#x2F; for render</span><br><span class="line">  &#125; else if (el.if &amp;&amp; !el.ifProcessed) &#123;</span><br><span class="line">    return genIf(el) &#x2F;&#x2F; if render</span><br><span class="line">  &#125; else if (el.tag &#x3D;&#x3D;&#x3D; &#39;template&#39; &amp;&amp; !el.slotTarget) &#123;</span><br><span class="line">    return genChildren(el) || &#39;void 0&#39; &#x2F;&#x2F; template render</span><br><span class="line">  &#125; else if (el.tag &#x3D;&#x3D;&#x3D; &#39;slot&#39;) &#123;</span><br><span class="line">    return genSlot(el) &#x2F;&#x2F; slot render</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; component or element</span><br><span class="line">    let code</span><br><span class="line">    if (el.component) &#123; &#x2F;&#x2F; component render</span><br><span class="line">      code &#x3D; genComponent(el.component, el)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      const data &#x3D; el.plain ? undefined : genData(el) &#x2F;&#x2F; 拼接属性 生成头结点render</span><br><span class="line"></span><br><span class="line">      const children &#x3D; el.inlineTemplate ? null : genChildren(el, true) &#x2F;&#x2F; 遍历生成子节点render</span><br><span class="line">      code &#x3D; &#96;_c(&#39;$&#123;el.tag&#125;&#39;$&#123;</span><br><span class="line">        data ? &#96;,$&#123;data&#125;&#96; : &#39;&#39; &#x2F;&#x2F; data</span><br><span class="line">      &#125;$&#123;</span><br><span class="line">        children ? &#96;,$&#123;children&#125;&#96; : &#39;&#39; &#x2F;&#x2F; children</span><br><span class="line">      &#125;)&#96;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; module transforms</span><br><span class="line">    for (let i &#x3D; 0; i &lt; transforms.length; i++) &#123;</span><br><span class="line">      code &#x3D; transforms[i](el, code)</span><br><span class="line">    &#125;</span><br><span class="line">    return code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genChildren (el: ASTElement, checkSkip?: boolean): string | void &#123;</span><br><span class="line">  const children &#x3D; el.children</span><br><span class="line">  if (children.length) &#123;</span><br><span class="line">    const el: any &#x3D; children[0]</span><br><span class="line">    &#x2F;&#x2F; optimize single v-for</span><br><span class="line">    if (children.length &#x3D;&#x3D;&#x3D; 1 &amp;&amp;</span><br><span class="line">        el.for &amp;&amp;</span><br><span class="line">        el.tag !&#x3D;&#x3D; &#39;template&#39; &amp;&amp;</span><br><span class="line">        el.tag !&#x3D;&#x3D; &#39;slot&#39;) &#123;</span><br><span class="line">      return genElement(el)</span><br><span class="line">    &#125;</span><br><span class="line">    const normalizationType &#x3D; checkSkip ? getNormalizationType(children) : 0</span><br><span class="line">    return &#96;[$&#123;children.map(genNode).join(&#39;,&#39;)&#125;]$&#123;</span><br><span class="line">      normalizationType ? &#96;,$&#123;normalizationType&#125;&#96; : &#39;&#39;</span><br><span class="line">    &#125;&#96;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function genNode (node: ASTNode): string &#123;</span><br><span class="line">  if (node.type &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">    return genElement(node)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return genText(node)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>generate –&gt; genElement –&gt; {<br>直接 render<br>children –&gt; 遍历判断+render<br>}</p>
<p>最终返回了一个静态节点的 render 和动态节点的 render。</p>
<p>然后进行错误和建议的判断和提示</p>
<p>然后是把 render 字符串通过 new Function 生成 render 函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; turn code into functions 生成render函数</span><br><span class="line">    const res &#x3D; &#123;&#125;</span><br><span class="line">    const fnGenErrors &#x3D; []</span><br><span class="line">    res.render &#x3D; makeFunction(compiled.render, fnGenErrors)</span><br><span class="line">    const l &#x3D; compiled.staticRenderFns.length</span><br><span class="line">    res.staticRenderFns &#x3D; new Array(l)</span><br><span class="line">    for (let i &#x3D; 0; i &lt; l; i++) &#123;</span><br><span class="line">      res.staticRenderFns[i] &#x3D; makeFunction(compiled.staticRenderFns[i], fnGenErrors)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    。。。。。。</span><br><span class="line"></span><br><span class="line">    return (functionCompileCache[key] &#x3D; res)</span><br><span class="line"></span><br><span class="line">    。。。。。。</span><br><span class="line"></span><br><span class="line">    render &#x3D; function () &#123;</span><br><span class="line">      with(this)&#123;return _c(&#39;div&#39;,&#123;attrs:&#123;&quot;id&quot;:&quot;app&quot;&#125;&#125;,[_c(&#39;p&#39;,[_v(_s(message))])])&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>顺便一提，render 里面的_c,_v 之类的方法在 src/core/instance/render.js 中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.prototype._o &#x3D; markOnce</span><br><span class="line">Vue.prototype._n &#x3D; toNumber</span><br><span class="line">Vue.prototype._s &#x3D; _toString</span><br><span class="line">Vue.prototype._l &#x3D; renderList</span><br><span class="line">Vue.prototype._t &#x3D; renderSlot</span><br><span class="line">Vue.prototype._q &#x3D; looseEqual</span><br><span class="line">Vue.prototype._i &#x3D; looseIndexOf</span><br><span class="line">Vue.prototype._m &#x3D; renderStatic</span><br><span class="line">Vue.prototype._f &#x3D; resolveFilter</span><br><span class="line">Vue.prototype._k &#x3D; checkKeyCodes</span><br><span class="line">Vue.prototype._b &#x3D; bindObjectProps</span><br><span class="line">Vue.prototype._v &#x3D; createTextVNode</span><br><span class="line">Vue.prototype._e &#x3D; createEmptyVNode</span><br><span class="line">Vue.prototype._u &#x3D; resolveScopedSlots</span><br></pre></td></tr></table></figure>

<p>又回到$mount 方法</p>
<p>return mount.call(this, el, hydrating)</p>
<h3 id="mountComponent-src-core-instance-lifecycle-js"><a href="#mountComponent-src-core-instance-lifecycle-js" class="headerlink" title="mountComponent /src/core/instance/lifecycle.js"></a>mountComponent /src/core/instance/lifecycle.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; public mount method</span><br><span class="line">Vue.prototype.$mount &#x3D; function (</span><br><span class="line">  el?: string | Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  el &#x3D; el &amp;&amp; inBrowser ? query(el) : undefined</span><br><span class="line">  return mountComponent(this, el, hydrating)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function mountComponent (</span><br><span class="line">  vm: Component,</span><br><span class="line">  el: ?Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  vm.$el &#x3D; el</span><br><span class="line">  if (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render &#x3D; createEmptyVNode</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">      if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !&#x3D;&#x3D; &#39;#&#39;) ||</span><br><span class="line">        vm.$options.el || el) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#39;You are using the runtime-only build of Vue where the template &#39; +</span><br><span class="line">          &#39;compiler is not available. Either pre-compile the templates into &#39; +</span><br><span class="line">          &#39;render functions, or use the compiler-included build.&#39;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#39;Failed to mount component: template or render function not defined.&#39;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, &#39;beforeMount&#39;) &#x2F;&#x2F; beforeMount处理</span><br><span class="line">  debugger</span><br><span class="line"></span><br><span class="line">  let updateComponent</span><br><span class="line">  &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      const name &#x3D; vm._name</span><br><span class="line">      const id &#x3D; vm._uid</span><br><span class="line">      const startTag &#x3D; &#96;vue-perf-start:$&#123;id&#125;&#96;</span><br><span class="line">      const endTag &#x3D; &#96;vue-perf-end:$&#123;id&#125;&#96;</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      const vnode &#x3D; vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(&#96;$&#123;name&#125; render&#96;, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(&#96;$&#123;name&#125; patch&#96;, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    updateComponent &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vm._watcher &#x3D; new Watcher(vm, updateComponent, noop)</span><br><span class="line">  hydrating &#x3D; false</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; manually mounted instance, call mounted on self</span><br><span class="line">  &#x2F;&#x2F; mounted is called for render-created child components in its inserted hook</span><br><span class="line">  if (vm.$vnode &#x3D;&#x3D; null) &#123;</span><br><span class="line">    vm._isMounted &#x3D; true</span><br><span class="line">    callHook(vm, &#39;mounted&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  return vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mountComponent 方法定义了 updateComponent，并设置了监听，最后又到了 Wathcer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: Object</span><br><span class="line">  ) &#123;</span><br><span class="line">    this.vm &#x3D; vm</span><br><span class="line">    vm._watchers.push(this)</span><br><span class="line">    &#x2F;&#x2F; options</span><br><span class="line">    if (options) &#123;</span><br><span class="line">      this.deep &#x3D; !!options.deep</span><br><span class="line">      this.user &#x3D; !!options.user</span><br><span class="line">      this.lazy &#x3D; !!options.lazy</span><br><span class="line">      this.sync &#x3D; !!options.sync</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.deep &#x3D; this.user &#x3D; this.lazy &#x3D; this.sync &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line">    this.cb &#x3D; cb</span><br><span class="line">    this.id &#x3D; ++uid &#x2F;&#x2F; uid for batching</span><br><span class="line">    this.active &#x3D; true</span><br><span class="line">    this.dirty &#x3D; this.lazy &#x2F;&#x2F; for lazy watchers</span><br><span class="line">    this.deps &#x3D; []</span><br><span class="line">    this.newDeps &#x3D; []</span><br><span class="line">    this.depIds &#x3D; new Set()</span><br><span class="line">    this.newDepIds &#x3D; new Set()</span><br><span class="line">    this.expression &#x3D; process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;</span><br><span class="line">      ? expOrFn.toString()</span><br><span class="line">      : &#39;&#39;</span><br><span class="line">    &#x2F;&#x2F; parse expression for getter</span><br><span class="line">    if (typeof expOrFn &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      this.getter &#x3D; expOrFn</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.getter &#x3D; parsePath(expOrFn)</span><br><span class="line">      if (!this.getter) &#123;</span><br><span class="line">        this.getter &#x3D; function () &#123;&#125;</span><br><span class="line">        process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; warn(</span><br><span class="line">          &#96;Failed watching path: &quot;$&#123;expOrFn&#125;&quot; &#96; +</span><br><span class="line">          &#39;Watcher only accepts simple dot-delimited paths. &#39; +</span><br><span class="line">          &#39;For full control, use a function instead.&#39;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.value &#x3D; this.lazy</span><br><span class="line">      ? undefined</span><br><span class="line">      : this.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Evaluate the getter, and re-collect dependencies.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  get () &#123;</span><br><span class="line">    pushTarget(this)</span><br><span class="line">    let value</span><br><span class="line">    const vm &#x3D; this.vm</span><br><span class="line">    if (this.user) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        value &#x3D; this.getter.call(vm, vm)</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        handleError(e, vm, &#96;getter for watcher &quot;$&#123;this.expression&#125;&quot;&#96;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      value &#x3D; this.getter.call(vm, vm)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; &quot;touch&quot; every property so they are all tracked as</span><br><span class="line">    &#x2F;&#x2F; dependencies for deep watching</span><br><span class="line">    if (this.deep) &#123;</span><br><span class="line">      traverse(value)</span><br><span class="line">    &#125;</span><br><span class="line">    popTarget()</span><br><span class="line">    this.cleanupDeps()</span><br><span class="line">    return value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Watcher 里面定义了 getter，又在最后调用了 get()方法，然后在 get 里面，又使用了 getter 方法，其实就是 updateComponent 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm._update(vm._render(), hydrating)</span><br></pre></td></tr></table></figure>

<p>updateComponent 里面，显示执行了 vm._render()，然后执行 vm._update()</p>
<h3 id="vm-render"><a href="#vm-render" class="headerlink" title="vm._render()"></a>vm._render()</h3><p>vm._render()在 src/core/instance/render.js 中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.prototype._render &#x3D; function (): VNode &#123;</span><br><span class="line">    const vm: Component &#x3D; this</span><br><span class="line">    const &#123;</span><br><span class="line">      render,</span><br><span class="line">      staticRenderFns,</span><br><span class="line">      _parentVnode</span><br><span class="line">    &#125; &#x3D; vm.$options</span><br><span class="line"></span><br><span class="line">    if (vm._isMounted) &#123;</span><br><span class="line">      &#x2F;&#x2F; clone slot nodes on re-renders</span><br><span class="line">      for (const key in vm.$slots) &#123;</span><br><span class="line">        vm.$slots[key] &#x3D; cloneVNodes(vm.$slots[key])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vm.$scopedSlots &#x3D; (_parentVnode &amp;&amp; _parentVnode.data.scopedSlots) || emptyObject</span><br><span class="line"></span><br><span class="line">    if (staticRenderFns &amp;&amp; !vm._staticTrees) &#123;</span><br><span class="line">      vm._staticTrees &#x3D; []</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; set parent vnode. this allows render functions to have access</span><br><span class="line">    &#x2F;&#x2F; to the data on the placeholder node.</span><br><span class="line">    vm.$vnode &#x3D; _parentVnode</span><br><span class="line">    &#x2F;&#x2F; render self</span><br><span class="line">    let vnode</span><br><span class="line">    try &#123;</span><br><span class="line">      vnode &#x3D; render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      handleError(e, vm, &#96;render function&#96;)</span><br><span class="line">      &#x2F;&#x2F; return error render result,</span><br><span class="line">      &#x2F;&#x2F; or previous vnode to prevent render error causing blank component</span><br><span class="line">      &#x2F;* istanbul ignore else *&#x2F;</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">        vnode &#x3D; vm.$options.renderError</span><br><span class="line">          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)</span><br><span class="line">          : vm._vnode</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        vnode &#x3D; vm._vnode</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; return empty vnode in case the render function errored out</span><br><span class="line">    if (!(vnode instanceof VNode)) &#123;</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; Array.isArray(vnode)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#39;Multiple root nodes returned from render function. Render function &#39; +</span><br><span class="line">          &#39;should return a single root node.&#39;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      vnode &#x3D; createEmptyVNode()</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; set parent</span><br><span class="line">    vnode.parent &#x3D; _parentVnode</span><br><span class="line">    return vnode</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，_render 返回了 vnode，而 vnode 是通过 render 函数产生的，这里的 render 函数，就是上面非静态节点的那个 render 函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function anonymous(</span><br><span class="line">) &#123;</span><br><span class="line">with(this)&#123;return _c(&#39;div&#39;,&#123;attrs:&#123;&quot;id&quot;:&quot;app&quot;&#125;&#125;,[_c(&#39;p&#39;,[_v(_s(message))]),_v(&quot; &quot;),_m(0)])&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在这里，调用了_c,_v，_m 等<br>vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false)<br>Vue.prototype._v = createTextVNode<br>Vue.prototype._m = renderStatic<br>Vue.prototype._s = _toString</p>
<p>触发上面函数，先是被 proxy 的 has 捕捉到了，然后是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sharedPropertyDefinition.get &#x3D; function proxyGetter () &#123;</span><br><span class="line">    return this[sourceKey][key] &#x2F;&#x2F; this[&#39;_data&#39;][&#39;message&#39;]</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>得到了 message 的值</p>
<h4 id="createTextVNode"><a href="#createTextVNode" class="headerlink" title="createTextVNode"></a>createTextVNode</h4><p>src/core/vdom/vnode.js<br>message 就是 vm._data.message, _toString 就是把 message 转成 string，然后是 createTextVNode</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class VNode &#123;</span><br><span class="line">  constructor (</span><br><span class="line">    tag?: string,</span><br><span class="line">    data?: VNodeData,</span><br><span class="line">    children?: ?Array&lt;VNode&gt;,</span><br><span class="line">    text?: string,</span><br><span class="line">    elm?: Node,</span><br><span class="line">    context?: Component,</span><br><span class="line">    componentOptions?: VNodeComponentOptions</span><br><span class="line">  ) &#123;</span><br><span class="line">    this.tag &#x3D; tag</span><br><span class="line">    this.data &#x3D; data</span><br><span class="line">    this.children &#x3D; children</span><br><span class="line">    this.text &#x3D; text</span><br><span class="line">    this.elm &#x3D; elm</span><br><span class="line">    this.ns &#x3D; undefined</span><br><span class="line">    this.context &#x3D; context</span><br><span class="line">    this.functionalContext &#x3D; undefined</span><br><span class="line">    this.key &#x3D; data &amp;&amp; data.key</span><br><span class="line">    this.componentOptions &#x3D; componentOptions</span><br><span class="line">    this.componentInstance &#x3D; undefined</span><br><span class="line">    this.parent &#x3D; undefined</span><br><span class="line">    this.raw &#x3D; false</span><br><span class="line">    this.isStatic &#x3D; false</span><br><span class="line">    this.isRootInsert &#x3D; true</span><br><span class="line">    this.isComment &#x3D; false</span><br><span class="line">    this.isCloned &#x3D; false</span><br><span class="line">    this.isOnce &#x3D; false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  export function createTextVNode (val: string | number) &#123;</span><br><span class="line">    return new VNode(undefined, undefined, undefined, String(val)) &#x2F;&#x2F; 返回vnode</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的 VNode 仅仅是初始化了一些值</p>
<p>然后是 createElement</p>
<h4 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h4><p>src/core/vdom/create-element.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; wrapper function for providing a more flexible interface</span><br><span class="line">&#x2F;&#x2F; 翻译：包装函数为了提供一个更灵活的接口</span><br><span class="line">&#x2F;&#x2F; without getting yelled at by flow</span><br><span class="line">export function createElement (</span><br><span class="line">  context: Component,</span><br><span class="line">  tag: any,</span><br><span class="line">  data: any,</span><br><span class="line">  children: any,</span><br><span class="line">  normalizationType: any,</span><br><span class="line">  alwaysNormalize: boolean</span><br><span class="line">): VNode &#123;</span><br><span class="line">  if (Array.isArray(data) || isPrimitive(data)) &#123;</span><br><span class="line">    normalizationType &#x3D; children</span><br><span class="line">    children &#x3D; data</span><br><span class="line">    data &#x3D; undefined</span><br><span class="line">  &#125;</span><br><span class="line">  if (alwaysNormalize) normalizationType &#x3D; ALWAYS_NORMALIZE</span><br><span class="line">  return _createElement(context, tag, data, children, normalizationType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function _createElement (</span><br><span class="line">  context: Component,</span><br><span class="line">  tag?: string | Class&lt;Component&gt; | Function | Object,</span><br><span class="line">  data?: VNodeData,</span><br><span class="line">  children?: any,</span><br><span class="line">  normalizationType?: number</span><br><span class="line">): VNode &#123;</span><br><span class="line">  debugger</span><br><span class="line">  if (data &amp;&amp; data.__ob__) &#123;</span><br><span class="line">    process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; warn(</span><br><span class="line">      &#96;Avoid using observed data object as vnode data: $&#123;JSON.stringify(data)&#125;\n&#96; +</span><br><span class="line">      &#39;Always create fresh vnode data objects in each render!&#39;,</span><br><span class="line">      context</span><br><span class="line">    )</span><br><span class="line">    return createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">  if (!tag) &#123;</span><br><span class="line">    &#x2F;&#x2F; in case of component :is set to falsy value</span><br><span class="line">    return createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; support single function children as default scoped slot</span><br><span class="line">  if (Array.isArray(children) &amp;&amp;</span><br><span class="line">      typeof children[0] &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">    data &#x3D; data || &#123;&#125;</span><br><span class="line">    data.scopedSlots &#x3D; &#123; default: children[0] &#125;</span><br><span class="line">    children.length &#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">  if (normalizationType &#x3D;&#x3D;&#x3D; ALWAYS_NORMALIZE) &#123;</span><br><span class="line">    children &#x3D; normalizeChildren(children)</span><br><span class="line">  &#125; else if (normalizationType &#x3D;&#x3D;&#x3D; SIMPLE_NORMALIZE) &#123;</span><br><span class="line">    children &#x3D; simpleNormalizeChildren(children)</span><br><span class="line">  &#125;</span><br><span class="line">  let vnode, ns</span><br><span class="line">  if (typeof tag &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">    let Ctor</span><br><span class="line">    ns &#x3D; config.getTagNamespace(tag)</span><br><span class="line">    if (config.isReservedTag(tag)) &#123;</span><br><span class="line">      &#x2F;&#x2F; platform built-in elements</span><br><span class="line">      vnode &#x3D; new VNode(</span><br><span class="line">        config.parsePlatformTagName(tag), data, children,</span><br><span class="line">        undefined, undefined, context</span><br><span class="line">      )</span><br><span class="line">    &#125; else if ((Ctor &#x3D; resolveAsset(context.$options, &#39;components&#39;, tag))) &#123;</span><br><span class="line">      &#x2F;&#x2F; component</span><br><span class="line">      vnode &#x3D; createComponent(Ctor, data, context, children, tag)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; unknown or unlisted namespaced elements</span><br><span class="line">      &#x2F;&#x2F; check at runtime because it may get assigned a namespace when its</span><br><span class="line">      &#x2F;&#x2F; parent normalizes children</span><br><span class="line">      vnode &#x3D; new VNode(</span><br><span class="line">        tag, data, children,</span><br><span class="line">        undefined, undefined, context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; direct component options &#x2F; constructor</span><br><span class="line">    vnode &#x3D; createComponent(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">  if (vnode) &#123;</span><br><span class="line">    if (ns) applyNS(vnode, ns)</span><br><span class="line">    return vnode</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把数据的 VNode 放在了标签的 VNode 里，形成了父子关系（在某些情况下会返回一个空的 VNode）</p>
<h4 id="renderStatic"><a href="#renderStatic" class="headerlink" title="renderStatic"></a>renderStatic</h4><p>src/core/instance/render-helpers/render-static.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Runtime helper for rendering static trees.</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function renderStatic (</span><br><span class="line">  index: number,</span><br><span class="line">  isInFor?: boolean</span><br><span class="line">): VNode | Array&lt;VNode&gt; &#123;</span><br><span class="line">  let tree &#x3D; this._staticTrees[index]</span><br><span class="line">  &#x2F;&#x2F; if has already-rendered static tree and not inside v-for,</span><br><span class="line">  &#x2F;&#x2F; we can reuse the same tree by doing a shallow clone.</span><br><span class="line">  &#x2F;&#x2F; 翻译：如果已存在渲染好的静态树并不在v-for之内，我们可以通过浅拷贝重用它</span><br><span class="line">  if (tree &amp;&amp; !isInFor) &#123;</span><br><span class="line">    return Array.isArray(tree)</span><br><span class="line">      ? cloneVNodes(tree)</span><br><span class="line">      : cloneVNode(tree)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; otherwise, render a fresh tree. 否则，渲染一颗新树</span><br><span class="line">  tree &#x3D; this._staticTrees[index] &#x3D;</span><br><span class="line">    this.$options.staticRenderFns[index].call(this._renderProxy)</span><br><span class="line">  markStatic(tree, &#96;__static__$&#123;index&#125;&#96;, false)</span><br><span class="line">  return tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，tree 就是上面的静态渲染 render 函数所运行的结果—-一个 VNode 对象，然后 markStatic 给 tree 添加了一些标识符</p>
<p>看到这里我们已经可以得出 vm._render()最终返回了一个 VNode 树</p>
<p>然后就是 vm._update 了</p>
<h3 id="vm-update"><a href="#vm-update" class="headerlink" title="vm._update"></a>vm._update</h3><p>该方法在 src/core/instance/lifecycle.js 里</p>
<p>vm._update 里面先是调用了 patch 方法，给 vnode 添加了一个属性 elm，vnode 的 children 也是同样道理，这个 elm 其实就是经过处理后的 html 模板了。<br>然后在父节点插入了这个 elm，就是我们最终看到的页面 dom，最后通过 removeVnodes()删除了旧的 html 和 vnode.data 里的一些东西(这里没看懂)<br>然后进行了一些赋值操作 update 就结束了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.prototype._update &#x3D; function (vnode: VNode, hydrating?: boolean) &#123;</span><br><span class="line">    const vm: Component &#x3D; this</span><br><span class="line">    if (vm._isMounted) &#123;</span><br><span class="line">      callHook(vm, &#39;beforeUpdate&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    const prevEl &#x3D; vm.$el</span><br><span class="line">    const prevVnode &#x3D; vm._vnode</span><br><span class="line">    const prevActiveInstance &#x3D; activeInstance</span><br><span class="line">    activeInstance &#x3D; vm</span><br><span class="line">    vm._vnode &#x3D; vnode</span><br><span class="line">    &#x2F;&#x2F; Vue.prototype.__patch__ is injected in entry points</span><br><span class="line">    &#x2F;&#x2F; based on the rendering backend used.</span><br><span class="line">    if (!prevVnode) &#123;</span><br><span class="line">      &#x2F;&#x2F; initial render</span><br><span class="line">      debugger</span><br><span class="line">      vm.$el &#x3D; vm.__patch__(</span><br><span class="line">        vm.$el, vnode, hydrating, false &#x2F;* removeOnly *&#x2F;,</span><br><span class="line">        vm.$options._parentElm,</span><br><span class="line">        vm.$options._refElm</span><br><span class="line">      )</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; updates</span><br><span class="line">      vm.$el &#x3D; vm.__patch__(prevVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    activeInstance &#x3D; prevActiveInstance</span><br><span class="line">    &#x2F;&#x2F; update __vue__ reference</span><br><span class="line">    if (prevEl) &#123;</span><br><span class="line">      prevEl.__vue__ &#x3D; null</span><br><span class="line">    &#125;</span><br><span class="line">    if (vm.$el) &#123;</span><br><span class="line">      vm.$el.__vue__ &#x3D; vm</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; if parent is an HOC, update its $el as well</span><br><span class="line">    if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode &#x3D;&#x3D;&#x3D; vm.$parent._vnode) &#123;</span><br><span class="line">      vm.$parent.$el &#x3D; vm.$el</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; updated hook is called by the scheduler to ensure that children are</span><br><span class="line">    &#x2F;&#x2F; updated in a parent&#39;s updated hook.</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>后面其实还有一些关于生命周期标识的操作等，不过在这里我先不做过多的研究了</p>
<p>到了这里，一个基本的流程就应经完成了，文章就先到这了，以后应该会进行整理修改（一定）</p>
<p>因面试碰到相关问题，最后对 vue 生命周期钩子做下面记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">initLifecycle(vm)</span><br><span class="line">initEvents(vm)</span><br><span class="line">initRender(vm)</span><br><span class="line">callHook(vm, &#39;beforeCreate&#39;)</span><br><span class="line">initInjections(vm) &#x2F;&#x2F; resolve injections before data&#x2F;props</span><br><span class="line">initState(vm)</span><br><span class="line">initProvide(vm) &#x2F;&#x2F; resolve provide after data&#x2F;props</span><br><span class="line">callHook(vm, &#39;created&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 转换ast</span><br><span class="line">&#x2F;&#x2F; ast处理(静态节点相关)</span><br><span class="line">&#x2F;&#x2F; 生成render函数</span><br><span class="line">callHook(vm, &#39;beforeMount&#39;) &#x2F;&#x2F; beforeMount处理</span><br><span class="line">&#x2F;&#x2F; 生成vnode树</span><br><span class="line">&#x2F;&#x2F; 替换真正的dom</span><br><span class="line">callHook(vm, &#39;mounted&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; data改变</span><br><span class="line">callHook(vm, &#39;beforeUpdate&#39;)</span><br><span class="line">&#x2F;&#x2F; vdom重构并patch</span><br><span class="line">callHook(vm, &#39;updated&#39;)</span><br><span class="line"></span><br><span class="line">Vue.prototype.$destroy</span><br><span class="line">callHook(vm, &#39;beforeDestroy&#39;)</span><br><span class="line">vm._watcher.teardown()</span><br><span class="line">vm.__patch__(vm._vnode, null)</span><br><span class="line">callHook(vm, &#39;destroyed&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
</search>
